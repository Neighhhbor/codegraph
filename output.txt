--- Start of contains_parser.py ---
import tree_sitter_python as tspython
from tree_sitter import Language, Parser
import os

class Node:
    def __init__(self, name, node_type, code=None, signature=None, parent_fullname=None):
        self.name = name
        self.node_type = node_type  # 'directory', 'module', 'class', 'function'
        self.children = []
        self.code = code
        self.signature = signature

        # 生成全名：从根节点到当前节点的路径名
        if parent_fullname:
            self.fullname = f"{parent_fullname}.{name}"
        else:
            self.fullname = name

    def add_child(self, child_node):
        self.children.append(child_node)

class ContainsParser:
    def __init__(self, project_path, repo_name):
        self.project_path = project_path
        self.repo_name = repo_name
        self.parser = self._init_parser()
        self.root = Node(repo_name, 'directory')  # 项目的根节点
        self.nodes = {repo_name: self.root}  # 存储所有创建的节点

    def _init_parser(self):
        language = Language(tspython.language(), 'python')
        parser = Parser()
        parser.set_language(language)
        return parser

    def parse(self):
        self._build_tree(self.project_path, self.root)

    def _build_tree(self, current_path, parent_node):
        for item in os.listdir(current_path):
            item_path = os.path.join(current_path, item)
            if os.path.isdir(item_path):
                # 创建目录节点
                dir_node = self._create_node(item, 'directory', parent_node)
                # 递归遍历子目录
                self._build_tree(item_path, dir_node)
            elif item.endswith(".py"):
                # 创建文件模块节点并解析
                module_node = self._create_node(item, 'module', parent_node)
                self._parse_file(item_path, module_node)

    def _create_node(self, name, node_type, parent_node):
        # 去掉文件扩展名（仅对模块节点）
        if node_type == 'module' and name.endswith('.py'):
            name = name[:-3]  # 去除 .py 后缀

        # 生成全名
        if parent_node.fullname:
            full_name = f"{parent_node.fullname}.{name}"
        else:
            full_name = name

        # 创建节点
        node = Node(name, node_type, parent_fullname=parent_node.fullname)
        parent_node.add_child(node)
        self.nodes[full_name] = node

        return node


    def _parse_file(self, file_path, module_node):
        with open(file_path, "r") as file:
            file_content = file.read()

        tree = self.parser.parse(bytes(file_content, "utf8"))

        # 递归构建文件内的树形结构
        self._extract_items(tree.root_node, file_path, module_node)

    def _extract_items(self, node, file_path, parent_node):
        for child in node.children:
            if child.type == 'class_definition':
                class_name = self._get_node_text(child.child_by_field_name('name'), file_path)
                class_signature = self._get_node_text(child, file_path)
                class_node = Node(class_name, 'class', self._get_code_segment(child, file_path), class_signature, parent_node.fullname)
                parent_node.add_child(class_node)
                # 递归处理子节点
                self._extract_items(child, file_path, class_node)

            elif child.type == 'function_definition':
                func_name = self._get_node_text(child.child_by_field_name('name'), file_path)
                func_signature = self._get_node_text(child, file_path)
                func_node = Node(func_name, 'function', self._get_code_segment(child, file_path), func_signature, parent_node.fullname)
                parent_node.add_child(func_node)
                # 递归处理子节点
                self._extract_items(child, file_path, func_node)

            else:
                # 递归处理其他子节点
                self._extract_items(child, file_path, parent_node)

    def _get_node_text(self, node, file_path):
        if node is None:
            return ""
        start_byte = node.start_byte
        end_byte = node.end_byte
        with open(file_path, "r") as file:
            file_content = file.read()
        return file_content[start_byte:end_byte]

    def _get_code_segment(self, node, file_path):
        return self._get_node_text(node, file_path)


--- End of contains_parser.py ---

--- Start of config.py ---
# 配置文件
PROJECT_PATH = "./testproject"  # 需要分析的项目路径
NEO4J_URL = "bolt://localhost:7687"     # Neo4j数据库的URL
NEO4J_USER = "neo4j"                    # Neo4j数据库的用户名
NEO4J_PASSWORD = "12341234"             # Neo4j数据库的密码

--- End of config.py ---

--- Start of neo4j_utils.py ---
from py2neo import Graph, Node, Relationship
import os

class Neo4jHandler:
    def __init__(self, url, user, password):
        self.graph = Graph(url, auth=(user, password))

    def clean_database(self):
        self.graph.run("MATCH (n) DETACH DELETE n")
        print("数据库已清空")

    def import_graph(self, code_graph):
        nx_graph = code_graph.get_graph()
        for node, attrs in nx_graph.nodes(data=True):
            full_name = node
            node_type = attrs.get('type', 'UNKNOWN').upper()

            if node_type == 'UNKNOWN':
                print(f"发现未知类型的节点: {full_name}")
                continue

            if node_type == 'FILE':
                short_name = os.path.basename(full_name)
            else:
                short_name = full_name.split('.')[-1]

            existing_node = self.graph.nodes.match(node_type, full_name=full_name).first()
            if not existing_node:
                n = Node(node_type, name=short_name, full_name=full_name, code=attrs.get('code', ''), signature=attrs.get('signature', ''), description=attrs.get('description', ''))
                self.graph.create(n)
                print(f"导入节点: {full_name} (类型: {node_type})")

        for start, end, edge_attrs in nx_graph.edges(data=True):
            start_node = self.graph.nodes.match(full_name=start).first()
            end_node = self.graph.nodes.match(full_name=end).first()
            if start_node and end_node:
                existing_rel = self.graph.match_one(nodes=(start_node, end_node), r_type=edge_attrs['relationship'])
                if not existing_rel:
                    rel = Relationship(start_node, edge_attrs['relationship'], end_node)
                    self.graph.create(rel)
                    print(f"导入关系: {start} -> {end} (类型: {edge_attrs['relationship']})")
            else:
                print(f"警告: 关系的起始节点或终止节点缺失，跳过创建关系: {start} -> {end}")

--- End of neo4j_utils.py ---

--- Start of main.py ---
import os
from code_graph import CodeGraph
from neo4j_utils import Neo4jHandler
from contains_parser import ContainsParser  # 引入包含关系的解析器
from import_parser import ImportParser  # 引入import关系的解析器
from call_parser import CallParser  # 引入调用关系的解析器
import config

def main():
    # 连接到 Neo4j 数据库
    neo4j_handler = Neo4jHandler(config.NEO4J_URL, config.NEO4J_USER, config.NEO4J_PASSWORD)
    
    # 清空 Neo4j 数据库
    neo4j_handler.clean_database()

    # 获取项目名称
    repo_name = os.path.basename(os.path.normpath(config.PROJECT_PATH))

    # 第一步：解析CONTAINS关系
    contains_parser = ContainsParser(config.PROJECT_PATH, repo_name)
    contains_parser.parse()

    # 构建代码图
    code_graph = CodeGraph()

    # 遍历树形结构并构建图，从根节点开始
    code_graph.build_graph_from_tree(contains_parser.root)

    # 第二步：解析import关系
    import_parser = ImportParser(config.PROJECT_PATH, repo_name)
    import_parser.parse()

    # 处理import关系
    for importer, imported_module in import_parser.imports:
        print(f"importer: {importer}, imported_module: {imported_module}")
        code_graph.add_import(importer, imported_module)

    # 第三步：解析调用关系
    call_parser = CallParser(config.PROJECT_PATH, repo_name)
    call_parser.parse()

    # 处理调用关系
    for caller, callee in call_parser.calls:
        code_graph.add_call(caller, callee)

    # 最后，将图导入到 Neo4j 数据库
    neo4j_handler.import_graph(code_graph)

if __name__ == "__main__":
    main()

--- End of main.py ---

--- Start of code_graph.py ---
import networkx as nx
import os

class CodeGraph:
    def __init__(self):
        self.graph = nx.DiGraph()

    def build_graph_from_tree(self, tree_root):
        # 从树的根节点开始构建图
        self._add_node(tree_root)
        self._build_edges(tree_root)

    def _add_node(self, node):
        self.graph.add_node(node.fullname, type=node.node_type, code=node.code, signature=node.signature)
        print(f"添加节点: {node.fullname} (类型: {node.node_type})")

    def _build_edges(self, node):
        for child in node.children:
            self.graph.add_edge(node.fullname, child.fullname, relationship="CONTAINS")
            self._add_node(child)
            self._build_edges(child)

    def add_call(self, caller_fullname, callee_fullname):
        if caller_fullname in self.graph and callee_fullname in self.graph:
            self.graph.add_edge(caller_fullname, callee_fullname, relationship="CALLS")
            print(f"添加调用关系: {caller_fullname} -> {callee_fullname}")
        else:
            print(f"调用关系中的节点不存在: {caller_fullname} -> {callee_fullname}")

    def add_import(self, importer_fullname, imported_fullname):
        if importer_fullname in self.graph and imported_fullname in self.graph:
            self.graph.add_edge(importer_fullname, imported_fullname, relationship="IMPORTS")
            print(f"添加import关系: {importer_fullname} -> {imported_fullname}")
        else:
            print(f"import关系中的节点不存在: {importer_fullname} -> {imported_fullname}")

    def get_graph(self):
        return self.graph

--- End of code_graph.py ---

--- Start of lsp_client.py ---
from multilspy import SyncLanguageServer
from multilspy.multilspy_config import MultilspyConfig
from multilspy.multilspy_logger import MultilspyLogger
import os
import logging

class LspClientWrapper:
    def __init__(self, project_root):
        self.project_root = os.path.abspath(project_root)  # 转换为绝对路径
        self.config = MultilspyConfig.from_dict({"code_language": "python"})
        self.logger = MultilspyLogger()
        self.slsp = SyncLanguageServer.create(self.config, self.logger, self.project_root)

    def find_definition(self, file_path, line, character):
        logging.debug(f"Starting LSP server for project: {self.project_root}")
        with self.slsp.start_server():
            abs_file_path = os.path.abspath(file_path)  # 确保文件路径是绝对路径
            logging.debug(f"Finding definition in file: {abs_file_path} at line: {line}, character: {character}")
            return self.slsp.request_definition(abs_file_path, line, character)

--- End of lsp_client.py ---

--- Start of call_parser.py ---
import os
import tree_sitter_python as tspython
from tree_sitter import Language, Parser
from lsp_client import LspClientWrapper
import logging

class CallParser:
    def __init__(self, project_path, repo_name):
        self.project_path = project_path
        self.repo_name = repo_name
        self.parser = self._init_parser()
        self.calls = []  # 存储调用关系 (caller, callee)
        self.lsp_client = LspClientWrapper(project_root=project_path)

        # 配置日志记录
        self.logger = logging.getLogger('call_parser')
        self.logger.setLevel(logging.INFO)

    def _init_parser(self):
        language = Language(tspython.language(), 'python')
        parser = Parser()
        parser.set_language(language)
        return parser

    def parse(self):
        py_files = self._get_py_files()
        for file in py_files:
            self.logger.debug(f"Parsing file: {file}")
            self._parse_file(file)

    def _get_py_files(self):
        py_files = []
        for root, _, files in os.walk(self.project_path):
            for file in files:
                if file.endswith(".py"):
                    py_files.append(os.path.join(root, file))
        return py_files

    def _parse_file(self, file_path):
        with open(file_path, "r") as file:
            file_content = file.read()

        tree = self.parser.parse(bytes(file_content, "utf8"))

        # 构建模块名称
        module_name = self._get_module_name(file_path)

        self.logger.debug(f"Module name: {module_name}")

        # 递归分析调用关系
        self._extract_calls(tree.root_node, file_path, module_name)

    def _get_module_name(self, file_path):
        relative_path = os.path.relpath(file_path, self.project_path)
        module_name = os.path.splitext(relative_path)[0].replace(os.path.sep, '.')
        return f"{self.repo_name}.{module_name}"

    def _extract_calls(self, node, file_path, current_fullname):
        for child in node.children:
            if child.type == 'class_definition' or child.type == 'function_definition':
                definition_name = self._get_node_text(child.child_by_field_name('name'), file_path)
                full_definition_name = f"{current_fullname}.{definition_name}"
                self.logger.debug(f"Extracting {child.type} - {full_definition_name}")

                # 递归处理类或函数的子节点
                self._extract_calls(child, file_path, full_definition_name)

            elif child.type == 'call':
                # 处理函数调用，记录调用关系
                callee_name = self._resolve_callee_name(child, file_path, current_fullname)
                if callee_name:
                    caller_name = current_fullname  # 调用者是当前所在的函数或类
                    self.logger.debug(f"Call statement: {self._get_node_text(child, file_path)}")
                    self.logger.debug(f"Static analysis Caller: {caller_name}")
                    self.logger.debug(f"Static analysis Callee: {callee_name}")
                    # 记录调用关系
                    self.calls.append((caller_name, callee_name))

            else:
                # 递归处理其他子节点
                self._extract_calls(child, file_path, current_fullname)

    def _resolve_callee_name(self, node, file_path, current_fullname):
        func_node = node.child_by_field_name('function')
        if not func_node:
            return None

        # 拼接被调用函数的名字
        parts = []
        while func_node:
            if func_node.type in ('identifier', 'attribute'):
                parts.insert(0, self._get_node_text(func_node, file_path))
            func_node = func_node.child_by_field_name('value')

        callee_name = ".".join(parts)
        self.logger.debug(f"Trying to resolve callee: {callee_name} in {file_path}")

        # 使用 LSP 的 request_definition 查找定义
        definition = self.lsp_client.find_definition(file_path, node.start_point[0], node.start_point[1])

        self.logger.debug(f"LSP definition result: {definition}")

        if isinstance(definition, list) and len(definition) > 0:
            definition = definition[0]  # 如果是列表，取第一个元素
        else:
            self.logger.debug(f"Definition list is empty or not a list: {definition}")
            return None

        callee_fullname = self._convert_definition_to_fullname(definition)
        self.logger.debug(f"Resolved callee full name: {callee_fullname}")
        return callee_fullname

    def _convert_definition_to_fullname(self, definition):
        # 将定义的位置转换为模块名称和函数名称的完整路径
        self.logger.debug(f"Converting definition to full name: {definition}")
        file_path = definition['absolutePath']  # 使用绝对路径
        module_name = self._get_module_name(file_path)
        
        # 通过 AST 或者其他方式解析出具体的函数名称，而不是基于行列信息的生成
        symbol_name = self._find_symbol_name(file_path, definition['range']['start']['line'], definition['range']['start']['character'])
        
        function_name = f"{module_name}.{symbol_name}"
        return function_name

    def _find_symbol_name(self, file_path, line, character):
        """
        在文件中通过行号和列号找到符号的名称
        """
        # 打开文件并读取内容
        with open(file_path, 'r') as file:
            lines = file.readlines()

        # 获取行内容
        target_line = lines[line]

        # 找到特定位置的符号名称
        # 注意：这里是一个简单的字符串操作，实际中可能需要更复杂的分析
        symbol_name = ""
        for char in target_line[character:]:
            if char.isalnum() or char == '_':
                symbol_name += char
            else:
                break

        return symbol_name

    def _get_node_text(self, node, file_path):
        if node is None:
            return ""
        start_byte = node.start_byte
        end_byte = node.end_byte
        with open(file_path, "r") as file:
            file_content = file.read()
        return file_content[start_byte:end_byte]

--- End of call_parser.py ---

--- Start of import_parser.py ---
import os
import tree_sitter_python as tspython
from tree_sitter import Language, Parser
import logging

class ImportParser:
    def __init__(self, project_path, repo_name):
        self.project_path = project_path
        self.repo_name = repo_name
        self.parser = self._init_parser()
        self.imports = []  # 存储import关系 (importer, imported_module)

        # 配置日志记录
        self.logger = logging.getLogger('import_parser')
        self.logger.setLevel(logging.DEBUG)  # 设置为DEBUG模式以输出详细信息
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def _init_parser(self):
        language = Language(tspython.language(), 'python')
        parser = Parser()
        parser.set_language(language)
        return parser

    def parse(self):
        py_files = self._get_py_files()
        self.logger.debug(f"Found {len(py_files)} Python files to parse.")
        for file in py_files:
            self.logger.info(f"Parsing file: {file}")
            self._parse_file(file)

    def _get_py_files(self):
        py_files = []
        for root, _, files in os.walk(self.project_path):
            for file in files:
                if file.endswith(".py"):
                    py_files.append(os.path.join(root, file))
        return py_files

    def _parse_file(self, file_path):
        with open(file_path, "r") as file:
            file_content = file.read()

        tree = self.parser.parse(bytes(file_content, "utf8"))

        # 构建模块名称
        module_name = self._get_module_name(file_path)
        self.logger.debug(f"Module name for file {file_path}: {module_name}")

        # 递归分析import关系
        self._extract_imports(tree.root_node, file_path, module_name)

    def _get_module_name(self, file_path):
        relative_path = os.path.relpath(file_path, self.project_path)
        module_name = os.path.splitext(relative_path)[0].replace(os.path.sep, '.')
        return f"{self.repo_name}.{module_name}"

    def _extract_imports(self, node, file_path, current_fullname):
        for child in node.children:
            if child.type == 'import_statement':
                self.logger.debug(f"Found import statement in {current_fullname}")
                # 处理import关系，记录import的模块
                for name_node in child.named_children:
                    if name_node.type == 'dotted_name' or name_node.type == 'identifier':
                        import_name = self._get_node_text(name_node, file_path)
                        self.imports.append((current_fullname, import_name))
                        self.logger.info(f"Recorded import: {current_fullname} imports {import_name}")

            elif child.type == 'import_from_statement':
                self.logger.debug(f"Found from-import statement in {current_fullname}")
                # 处理from ... import ...形式的导入
                module_name_node = child.child_by_field_name('module')
                module_name = self._get_node_text(module_name_node, file_path) if module_name_node else None

                if module_name:
                    # 记录从模块导入的关系
                    self.imports.append((current_fullname, module_name))
                    self.logger.info(f"Recorded from-import: {current_fullname} imports from {module_name}")
                    
                    # 处理具体导入的元素
                    for import_child in child.named_children:
                        if import_child.type == 'dotted_name' or import_child.type == 'identifier':
                            import_element = self._get_node_text(import_child, file_path)
                            full_import_path = f"{module_name}.{import_element}"
                            self.imports.append((current_fullname, full_import_path))
                            self.logger.info(f"Recorded from-import element: {current_fullname} imports {full_import_path}")

            else:
                # 递归处理其他子节点
                self._extract_imports(child, file_path, current_fullname)

    def _get_node_text(self, node, file_path):
        if node is None:
            return ""
        start_byte = node.start_byte
        end_byte = node.end_byte
        with open(file_path, "r") as file:
            file_content = file.read()
        return file_content[start_byte:end_byte]


--- End of import_parser.py ---

