--- Start of contains_parser.py ---
import tree_sitter_python as tspython
from tree_sitter import Language, Parser
import os

class Node:
    def __init__(self, name, node_type, code=None, signature=None, parent_fullname=None):
        self.name = name
        self.node_type = node_type  # 'directory', 'module', 'class', 'function'
        self.children = []
        self.code = code
        self.signature = signature

        # 生成全名：从根节点到当前节点的路径名
        if parent_fullname:
            self.fullname = f"{parent_fullname}.{name}"
        else:
            self.fullname = name

    def add_child(self, child_node):
        self.children.append(child_node)

class ContainsParser:
    def __init__(self, project_path, repo_name):
        self.project_path = project_path
        self.repo_name = repo_name
        self.parser = self._init_parser()
        self.root = Node(repo_name, 'directory')  # 项目的根节点
        self.nodes = {repo_name: self.root}  # 存储所有创建的节点

    def _init_parser(self):
        PY_LANGUAGE=Language(tspython.language())
        parser = Parser(PY_LANGUAGE)
        return parser

    def parse(self):
        self._build_tree(self.project_path, self.root)

    def _build_tree(self, current_path, parent_node):
        for item in os.listdir(current_path):
            item_path = os.path.join(current_path, item)
            if os.path.isdir(item_path):
                # 创建目录节点
                dir_node = self._create_node(item, 'directory', parent_node)
                # 递归遍历子目录
                self._build_tree(item_path, dir_node)
            elif item.endswith(".py"):
                # 创建文件模块节点并解析
                module_node = self._create_node(item, 'module', parent_node)
                self._parse_file(item_path, module_node)

    def _create_node(self, name, node_type, parent_node):
        # 去掉文件扩展名（仅对模块节点）
        if node_type == 'module' and name.endswith('.py'):
            name = name[:-3]  # 去除 .py 后缀

        # 生成全名
        if parent_node.fullname:
            full_name = f"{parent_node.fullname}.{name}"
        else:
            full_name = name

        # 创建节点
        node = Node(name, node_type, parent_fullname=parent_node.fullname)
        parent_node.add_child(node)
        self.nodes[full_name] = node

        return node


    def _parse_file(self, file_path, module_node):
        with open(file_path, "r") as file:
            file_content = file.read()

        tree = self.parser.parse(bytes(file_content, "utf8"))

        # 递归构建文件内的树形结构
        self._extract_items(tree.root_node, file_path, module_node)

    def _extract_items(self, node, file_path, parent_node):
        for child in node.children:
            if child.type == 'class_definition':
                class_name = self._get_node_text(child.child_by_field_name('name'), file_path)
                class_signature = self._get_node_text(child, file_path)
                class_node = Node(class_name, 'class', self._get_code_segment(child, file_path), class_signature, parent_node.fullname)
                parent_node.add_child(class_node)
                # 递归处理子节点
                self._extract_items(child, file_path, class_node)

            elif child.type == 'function_definition':
                func_name = self._get_node_text(child.child_by_field_name('name'), file_path)
                func_signature = self._get_node_text(child, file_path)
                func_node = Node(func_name, 'function', self._get_code_segment(child, file_path), func_signature, parent_node.fullname)
                parent_node.add_child(func_node)
                # 递归处理子节点
                self._extract_items(child, file_path, func_node)

            else:
                # 递归处理其他子节点
                self._extract_items(child, file_path, parent_node)

    def _get_node_text(self, node, file_path):
        if node is None:
            return ""
        start_byte = node.start_byte
        end_byte = node.end_byte
        with open(file_path, "r") as file:
            file_content = file.read()
        return file_content[start_byte:end_byte]

    def _get_code_segment(self, node, file_path):
        return self._get_node_text(node, file_path)


--- End of contains_parser.py ---

--- Start of config.py ---
# 配置文件
PROJECT_PATH = "./testproject"  # 需要分析的项目路径
NEO4J_URL = "bolt://localhost:7687"     # Neo4j数据库的URL
NEO4J_USER = "neo4j"                    # Neo4j数据库的用户名
NEO4J_PASSWORD = "12341234"             # Neo4j数据库的密码

--- End of config.py ---

--- Start of neo4j_utils.py ---
from py2neo import Graph, Node, Relationship
import os

class Neo4jHandler:
    def __init__(self, url, user, password):
        self.graph = Graph(url, auth=(user, password))

    def clean_database(self):
        self.graph.run("MATCH (n) DETACH DELETE n")
        print("数据库已清空")

    def import_graph(self, code_graph):
        nx_graph = code_graph.get_graph()
        for node, attrs in nx_graph.nodes(data=True):
            full_name = node
            node_type = attrs.get('type', 'UNKNOWN').upper()

            if node_type == 'UNKNOWN':
                print(f"发现未知类型的节点: {full_name}")
                continue

            if node_type == 'FILE':
                short_name = os.path.basename(full_name)
            else:
                short_name = full_name.split('.')[-1]

            existing_node = self.graph.nodes.match(node_type, full_name=full_name).first()
            if not existing_node:
                n = Node(node_type, name=short_name, full_name=full_name, code=attrs.get('code', ''), signature=attrs.get('signature', ''), description=attrs.get('description', ''))
                self.graph.create(n)
                print(f"导入节点: {full_name} (类型: {node_type})")

        for start, end, edge_attrs in nx_graph.edges(data=True):
            start_node = self.graph.nodes.match(full_name=start).first()
            end_node = self.graph.nodes.match(full_name=end).first()
            if start_node and end_node:
                existing_rel = self.graph.match_one(nodes=(start_node, end_node), r_type=edge_attrs['relationship'])
                if not existing_rel:
                    rel = Relationship(start_node, edge_attrs['relationship'], end_node)
                    self.graph.create(rel)
                    print(f"导入关系: {start} -> {end} (类型: {edge_attrs['relationship']})")
            else:
                print(f"警告: 关系的起始节点或终止节点缺失，跳过创建关系: {start} -> {end}")

--- End of neo4j_utils.py ---

--- Start of main.py ---
import os
from code_graph import CodeGraph
from neo4j_utils import Neo4jHandler
from contains_parser import ContainsParser  # 引入包含关系的解析器
from import_parser import ImportParser  # 引入import关系的解析器
from call_parser import CallParser  # 引入调用关系的解析器
import config

def main():
    # 连接到 Neo4j 数据库
    neo4j_handler = Neo4jHandler(config.NEO4J_URL, config.NEO4J_USER, config.NEO4J_PASSWORD)
    
    # 清空 Neo4j 数据库
    neo4j_handler.clean_database()

    # 获取项目名称
    repo_name = os.path.basename(os.path.normpath(config.PROJECT_PATH))

    # 第一步：解析CONTAINS关系
    contains_parser = ContainsParser(config.PROJECT_PATH, repo_name)
    contains_parser.parse()

    # 构建代码图
    code_graph = CodeGraph()

    # 遍历树形结构并构建图，从根节点开始
    code_graph.build_graph_from_tree(contains_parser.root)

    # 第二步：解析import关系
    import_parser = ImportParser(config.PROJECT_PATH, repo_name)
    import_parser.parse()

    # 处理import关系
    for importer, imported_module in import_parser.imports:
        print(f"importer: {importer}, imported_module: {imported_module}")
        code_graph.add_import(importer, imported_module)

    # 第三步：解析调用关系
    call_parser = CallParser(config.PROJECT_PATH, repo_name, code_graph)
    call_parser.parse()

    # 处理调用关系
    for caller, callee in call_parser.calls:
        code_graph.add_call(caller, callee)

    # 最后，将图导入到 Neo4j 数据库
    neo4j_handler.import_graph(code_graph)

if __name__ == "__main__":
    main()

--- End of main.py ---

--- Start of code_graph.py ---
import networkx as nx
import os

class CodeGraph:
    def __init__(self):
        self.graph = nx.DiGraph()

    def build_graph_from_tree(self, tree_root):
        # 从树的根节点开始构建图
        self._add_node(tree_root)
        self._build_edges(tree_root)

    def _add_node(self, node):
        self.graph.add_node(node.fullname, type=node.node_type, code=node.code, signature=node.signature)
        print(f"添加节点: {node.fullname} (类型: {node.node_type})")

    def _build_edges(self, node):
        for child in node.children:
            self.graph.add_edge(node.fullname, child.fullname, relationship="CONTAINS")
            self._add_node(child)
            self._build_edges(child)

    def add_call(self, caller_fullname, callee_fullname):
        if caller_fullname in self.graph and callee_fullname in self.graph:
            self.graph.add_edge(caller_fullname, callee_fullname, relationship="CALLS")
            print(f"添加调用关系: {caller_fullname} -> {callee_fullname}")
        else:
            print(f"调用关系中的节点不存在: {caller_fullname} -> {callee_fullname}")

    def add_import(self, importer_fullname, imported_fullname):
        if importer_fullname in self.graph and imported_fullname in self.graph:
            self.graph.add_edge(importer_fullname, imported_fullname, relationship="IMPORTS")
            print(f"添加import关系: {importer_fullname} -> {imported_fullname}")
        else:
            print(f"import关系中的节点不存在: {importer_fullname} -> {imported_fullname}")

    def get_graph(self):
        return self.graph

--- End of code_graph.py ---

--- Start of lsp_client.py ---
from multilspy import SyncLanguageServer
from multilspy.multilspy_config import MultilspyConfig
from multilspy.multilspy_logger import MultilspyLogger
import os
import logging
import time

class LspClientWrapper:
    def __init__(self, project_root):
        self.project_root = os.path.abspath(project_root)  # 转换为绝对路径
        self.config = MultilspyConfig.from_dict({"code_language": "python"})
        self.logger = MultilspyLogger()
        self.slsp = SyncLanguageServer.create(self.config, self.logger, self.project_root)

    def find_definition(self, file_path, line, character, max_retries=1, delay=1.0):
        """
        通过LSP查找定义，加入重试和延迟机制，并处理可能的异常。

        参数:
            file_path (str): 源文件的路径。
            line (int): 请求定义的行号。
            character (int): 请求定义的列号。
            max_retries (int): 最大重试次数。
            delay (float): 每次重试之间的延迟时间（秒）。

        返回:
            LSP响应的定义位置，如果失败则返回None。
        """
        logging.debug(f"Starting LSP server for project: {self.project_root}")
        abs_file_path = os.path.abspath(file_path)  # 确保文件路径是绝对路径

        attempt = 0
        while attempt < max_retries:
            attempt += 1
            try:
                with self.slsp.start_server():
                    logging.debug(f"Attempt {attempt}: Finding definition in file: {abs_file_path} at line: {line}, character: {character}")
                    result = self.slsp.request_definition(abs_file_path, line, character)
                    if result:
                        logging.debug(f"Definition found: {result}")
                        return result
                    else:
                        logging.warning(f"Attempt {attempt}: No definition found for {abs_file_path} at line: {line}, character: {character}. Retrying...")
            except AssertionError as e:
                logging.error(f"Attempt {attempt}: LSP request failed for {abs_file_path} at line: {line}, character: {character}: {e}")
            except Exception as ex:
                logging.error(f"Attempt {attempt}: Unexpected error: {ex}")
            
            time.sleep(delay)
        
        logging.error(f"Failed to find definition after {max_retries} attempts.")
        return None

--- End of lsp_client.py ---

--- Start of call_parser.py ---
import os
import re
import tree_sitter_python as tspython
from tree_sitter import Language, Parser
import logging
from lsp_client import LspClientWrapper

class CallParser:
    def __init__(self, project_path, repo_name, code_graph):
        self.project_path = project_path
        self.repo_name = repo_name
        self.code_graph = code_graph
        self.parser = self._init_parser()
        self.calls = []  # 存储调用关系 (caller, callee)
        self.defined_symbols = set()  # 存储所有定义的标识符（简单名称）

        # 配置日志记录
        self.logger = logging.getLogger('call_parser')
        self.logger.setLevel(logging.INFO)  # 设置为INFO模式以输出详细信息
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

        # 初始化LSP客户端
        self.lsp_client = LspClientWrapper(self.project_path)

    def _init_parser(self):
        PY_LANGUAGE = Language(tspython.language())
        parser = Parser(PY_LANGUAGE)
        return parser

    def parse(self):
        py_files = self._get_py_files()
        self.logger.debug(f"Found {len(py_files)} Python files to parse.")
        
        # 第一遍扫描：注册所有标识符
        for file in py_files:
            self.logger.debug(f"Scanning definitions in file: {file}")
            self._scan_definitions(file)
        
        # 第二遍解析：处理调用关系
        for file in py_files:
            self.logger.debug(f"Parsing calls in file: {file}")
            self._parse_file(file)

    def _get_py_files(self):
        py_files = []
        for root, _, files in os.walk(self.project_path):
            for file in files:
                if file.endswith(".py"):
                    py_files.append(os.path.join(root, file))
        return py_files

    def _get_module_name(self, file_path):
        """根据文件路径生成模块全名"""
        relative_path = os.path.relpath(file_path, self.project_path)
        module_name = os.path.splitext(relative_path)[0].replace(os.path.sep, '.')
        return f"{self.repo_name}.{module_name}"

    def _remove_comments(self, code):
        """移除Python代码中的注释"""
        # 移除单行注释
        code = re.sub(r'#.*', '', code)
        # 移除多行字符串（包括注释）
        code = re.sub(r'\'\'\'(.*?)\'\'\'', '', code, flags=re.DOTALL)
        code = re.sub(r'\"\"\"(.*?)\"\"\"', '', code, flags=re.DOTALL)
        return code

    def _scan_definitions(self, file_path):
        with open(file_path, "r") as file:
            file_content = file.read()

        # 去掉注释
        file_content = self._remove_comments(file_content)

        tree = self.parser.parse(bytes(file_content, "utf8"))

        # 构建模块名称
        module_name = self._get_module_name(file_path)
        self._register_definitions(tree.root_node, file_path, module_name)

    def _register_definitions(self, node, file_path, current_fullname):
        for child in node.children:
            if child.type == 'class_definition' or child.type == 'function_definition':
                # 只注册函数名或类名，不包含路径
                name = self._get_node_text(child.child_by_field_name('name'), file_path)
                self.defined_symbols.add(name)
                # 递归处理子节点
                self._register_definitions(child, file_path, current_fullname)
            else:
                # 继续递归处理其他子节点
                self._register_definitions(child, file_path, current_fullname)

    def _parse_file(self, file_path):
        with open(file_path, "r") as file:
            file_content = file.read()

        # 去掉注释
        file_content = self._remove_comments(file_content)

        tree = self.parser.parse(bytes(file_content, "utf8"))

        # 构建模块名称
        module_name = self._get_module_name(file_path)

        # 递归分析调用关系
        self._extract_calls(tree.root_node, file_path, module_name)

    def _extract_calls(self, node, file_path, current_fullname):
        for child in node.children:
            if child.type == 'function_definition':
                # 获取当前函数的全名
                func_name = self._get_node_text(child.child_by_field_name('name'), file_path)
                func_fullname = f"{current_fullname}.{func_name}"

                # 递归分析函数体内的调用
                self._extract_calls(child, file_path, func_fullname)

            elif child.type == 'call':
                # 检测到函数调用
                func_name_node = child.child_by_field_name('function')
                if func_name_node:
                    if func_name_node.type == 'identifier':
                        # 处理全局函数调用
                        callee_name = self._get_node_text(func_name_node, file_path)

                        # 检查这个函数是否在项目内定义
                        if callee_name in self.defined_symbols:
                            # 使用 LSP 查找函数定义位置
                            definition = self.lsp_client.find_definition(file_path, func_name_node.start_point[0], func_name_node.start_point[1])
                            if definition:
                                callee_fullname = self._get_fullname_from_definition(definition)
                                # 如果定义的位置也是在项目内，记录调用关系
                                if callee_fullname and callee_fullname in self.defined_symbols:
                                    self.calls.append((current_fullname, callee_fullname))
                                    self.logger.info(f"Recorded call: {current_fullname} -> {callee_fullname}")

                    elif func_name_node.type == 'attribute':
                        # 处理成员函数或静态方法调用
                        object_name_node = func_name_node.child_by_field_name('object')
                        method_name_node = func_name_node.child_by_field_name('attribute')

                        # 提取对象名和方法名
                        object_name = self._get_node_text(object_name_node, file_path) if object_name_node else None
                        method_name = self._get_node_text(method_name_node, file_path) if method_name_node else None

                        if object_name and method_name:
                            # 检查方法名是否在已定义的符号中
                            if method_name in self.defined_symbols:
                                # 使用 LSP 查找方法定义位置
                                definition = self.lsp_client.find_definition(file_path, func_name_node.start_point[0], func_name_node.start_point[1])
                                if definition:
                                    callee_fullname = self._get_fullname_from_definition(definition)
                                    # 如果定义的位置也是在项目内，记录调用关系
                                    if callee_fullname and callee_fullname in self.defined_symbols:
                                        self.calls.append((current_fullname, callee_fullname))
                                        self.logger.info(f"Recorded call: {current_fullname} -> {callee_fullname}")
                            else:
                                # 记录静态方法或成员函数调用信息
                                self.logger.info(f"Detected method call: {object_name}.{method_name} in {current_fullname}")
                        else:
                            # 记录提取失败的情况，便于调试
                            self.logger.error(f"Failed to extract method call details in {current_fullname}: object_name={object_name}, method_name={method_name}")

            else:
                # 递归处理其他子节点
                self._extract_calls(child, file_path, current_fullname)

    def _get_node_text(self, node, file_path):
        if node is None:
            return ""
        start_byte = node.start_byte
        end_byte = node.end_byte
        with open(file_path, "r") as file:
            file_content = file.read()
        return file_content[start_byte:end_byte]

    def _get_fullname_from_definition(self, definition):
        if not isinstance(definition, list) or len(definition) == 0:
            self.logger.error(f"Unexpected definition format or empty list: {definition}")
            return None

        # 取列表中的第一个元素
        definition = definition[0]

        if not isinstance(definition, dict):
            self.logger.error(f"Unexpected definition format: {definition}")
            return None

        # 根据LSP返回的定义位置，计算被调用函数的全名
        def_file_path = os.path.abspath(definition['uri'].replace('file://', ''))
        line = definition['range']['start']['line']
        
        # 解析被调用函数所在模块
        module_name = self._get_module_name(def_file_path)

        # 根据行号反向推断函数的全名
        func_fullname = f"{module_name}"
        return func_fullname

--- End of call_parser.py ---

--- Start of import_parser.py ---
import os
import tree_sitter_python as tspython
from tree_sitter import Language, Parser
import logging

class ImportParser:
    def __init__(self, project_path, repo_name):
        self.project_path = project_path
        self.repo_name = repo_name
        self.parser = self._init_parser()
        self.imports = []  # 存储import关系 (importer, imported_module)

        # 配置日志记录
        self.logger = logging.getLogger('import_parser')
        self.logger.setLevel(logging.INFO)  # 设置为DEBUG模式以输出详细信息
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)

    def _init_parser(self):
        PY_LANGUAGE=Language(tspython.language())
        parser = Parser(PY_LANGUAGE)
        return parser

    def parse(self):
        py_files = self._get_py_files()
        self.logger.debug(f"Found {len(py_files)} Python files to parse.")
        for file in py_files:
            self.logger.debug(f"Parsing file: {file}")
            self._parse_file(file)

    def _get_py_files(self):
        py_files = []
        for root, _, files in os.walk(self.project_path):
            for file in files:
                if file.endswith(".py"):
                    py_files.append(os.path.join(root, file))
        return py_files

    def _parse_file(self, file_path):
        with open(file_path, "r") as file:
            file_content = file.read()

        tree = self.parser.parse(bytes(file_content, "utf8"))

        # 构建模块名称
        module_name = self._get_module_name(file_path)
        self.logger.debug(f"Module name for file {file_path}: {module_name}")

        # 递归分析import关系
        self._extract_imports(tree.root_node, file_path, module_name)

    def _get_module_name(self, file_path):
        relative_path = os.path.relpath(file_path, self.project_path)
        module_name = os.path.splitext(relative_path)[0].replace(os.path.sep, '.')
        return f"{self.repo_name}.{module_name}"

    def _extract_imports(self, node, file_path, current_fullname):
        for child in node.children:
            if child.type == 'import_statement':
                self.logger.debug(f"Found import statement in {current_fullname}")
                # 处理import关系，记录import的模块
                for name_node in child.named_children:
                    if name_node.type == 'dotted_name' or name_node.type == 'identifier':
                        import_name = self._get_node_text(name_node, file_path)
                        self.imports.append((current_fullname, import_name))
                        self.logger.debug(f"Recorded import: {current_fullname} imports {import_name}")

            elif child.type == 'import_from_statement':
                self.logger.debug(f"Found from-import statement in {current_fullname}")
                # 处理from ... import ...形式的导入
                module_name_node = child.child_by_field_name('module')
                module_name = self._get_node_text(module_name_node, file_path) if module_name_node else None

                if module_name:
                    # 记录从模块导入的关系
                    self.imports.append((current_fullname, module_name))
                    self.logger.debug(f"Recorded from-import: {current_fullname} imports from {module_name}")
                    
                    # 处理具体导入的元素
                    for import_child in child.named_children:
                        if import_child.type == 'dotted_name' or import_child.type == 'identifier':
                            import_element = self._get_node_text(import_child, file_path)
                            full_import_path = f"{module_name}.{import_element}"
                            self.imports.append((current_fullname, full_import_path))
                            self.logger.debug(f"Recorded from-import element: {current_fullname} imports {full_import_path}")

            else:
                # 递归处理其他子节点
                self._extract_imports(child, file_path, current_fullname)

    def _get_node_text(self, node, file_path):
        if node is None:
            return ""
        start_byte = node.start_byte
        end_byte = node.end_byte
        with open(file_path, "r") as file:
            file_content = file.read()
        return file_content[start_byte:end_byte]


--- End of import_parser.py ---

