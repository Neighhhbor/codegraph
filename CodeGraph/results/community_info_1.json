{
    "0": {
        "nodes": [
            {
                "id": 155,
                "attributes": {
                    "id": 155.0,
                    "label": "hl7.tests.backports.unittest.case._Outcome",
                    "type": "class",
                    "code": "class _Outcome(object): def __init__(self, result=None): self.expecting_failure = False self.result = result self.result_supports_subtests = hasattr(result, &#34;addSubTest&#34;) self.success = True self.skipped = [] self.expectedFailure = None self.errors = []  @contextlib.contextmanager def testPartExecutor(self, test_case, isTest=False): old_success = self.success self.success = True try: yield except KeyboardInterrupt: raise except SkipTest as e: self.success = False self.skipped.append((test_case, str(e))) except _ShouldStop: pass except Exception: exc_info = sys.exc_info() if self.expecting_failure: self.expectedFailure = exc_info else: self.success = False self.errors.append((test_case, exc_info)) # explicitly break a reference cycle: # exc_info -> frame -> exc_info exc_info = None else: if self.result_supports_subtests and self.success: self.errors.append((test_case, None)) finally: self.success = self.success and old_success",
                    "signature": "class _Outcome(object): def __init__(self, result=None): self.expecting_failure = False self.result = result self.result_supports_subtests = hasattr(result, &#34;addSubTest&#34;) self.success = True self.skipped = [] self.expectedFailure = None self.errors = []  @contextlib.contextmanager def testPartExecutor(self, test_case, isTest=False): old_success = self.success self.success = True try: yield except KeyboardInterrupt: raise except SkipTest as e: self.success = False self.skipped.append((test_case, str(e))) except _ShouldStop: pass except Exception: exc_info = sys.exc_info() if self.expecting_failure: self.expectedFailure = exc_info else: self.success = False self.errors.append((test_case, exc_info)) # explicitly break a reference cycle: # exc_info -> frame -> exc_info exc_info = None else: if self.result_supports_subtests and self.success: self.errors.append((test_case, None)) finally: self.success = self.success and old_success"
                }
            },
            {
                "id": 156,
                "attributes": {
                    "id": 156.0,
                    "label": "hl7.tests.backports.unittest.case._Outcome.__init__",
                    "type": "function",
                    "code": "def __init__(self, result=None): self.expecting_failure = False self.result = result self.result_supports_subtests = hasattr(result, &#34;addSubTest&#34;) self.success = True self.skipped = [] self.expectedFailure = None self.errors = []",
                    "signature": "def __init__(self, result=None): self.expecting_failure = False self.result = result self.result_supports_subtests = hasattr(result, &#34;addSubTest&#34;) self.success = True self.skipped = [] self.expectedFailure = None self.errors = []"
                }
            },
            {
                "id": 157,
                "attributes": {
                    "id": 157.0,
                    "label": "hl7.tests.backports.unittest.case._Outcome.testPartExecutor",
                    "type": "function",
                    "code": "def testPartExecutor(self, test_case, isTest=False): old_success = self.success self.success = True try: yield except KeyboardInterrupt: raise except SkipTest as e: self.success = False self.skipped.append((test_case, str(e))) except _ShouldStop: pass except Exception: exc_info = sys.exc_info() if self.expecting_failure: self.expectedFailure = exc_info else: self.success = False self.errors.append((test_case, exc_info)) # explicitly break a reference cycle: # exc_info -> frame -> exc_info exc_info = None else: if self.result_supports_subtests and self.success: self.errors.append((test_case, None)) finally: self.success = self.success and old_success",
                    "signature": "def testPartExecutor(self, test_case, isTest=False): old_success = self.success self.success = True try: yield except KeyboardInterrupt: raise except SkipTest as e: self.success = False self.skipped.append((test_case, str(e))) except _ShouldStop: pass except Exception: exc_info = sys.exc_info() if self.expecting_failure: self.expectedFailure = exc_info else: self.success = False self.errors.append((test_case, exc_info)) # explicitly break a reference cycle: # exc_info -> frame -> exc_info exc_info = None else: if self.result_supports_subtests and self.success: self.errors.append((test_case, None)) finally: self.success = self.success and old_success"
                }
            },
            {
                "id": 188,
                "attributes": {
                    "id": 188.0,
                    "label": "hl7.tests.backports.unittest.case._OrderedChainMap",
                    "type": "class",
                    "code": "class _OrderedChainMap(collections.ChainMap): def __iter__(self): seen = set() for mapping in self.maps: for k in mapping: if k not in seen: seen.add(k) yield k",
                    "signature": "class _OrderedChainMap(collections.ChainMap): def __iter__(self): seen = set() for mapping in self.maps: for k in mapping: if k not in seen: seen.add(k) yield k"
                }
            },
            {
                "id": 189,
                "attributes": {
                    "id": 189.0,
                    "label": "hl7.tests.backports.unittest.case._OrderedChainMap.__iter__",
                    "type": "function",
                    "code": "def __iter__(self): seen = set() for mapping in self.maps: for k in mapping: if k not in seen: seen.add(k) yield k",
                    "signature": "def __iter__(self): seen = set() for mapping in self.maps: for k in mapping: if k not in seen: seen.add(k) yield k"
                }
            },
            {
                "id": 190,
                "attributes": {
                    "id": 190.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase",
                    "type": "class",
                    "code": "class TestCase(object): &#34;&#34;&#34;A class whose instances are single test cases.  By default, the test code itself should be placed in a method named 'runTest'.  If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute.  Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively.  If it is necessary to override the __init__ method, the base class __init__ method must always be called. It is important that subclasses should not change the signature of their __init__ method, since instances of the classes are instantiated automatically by parts of the framework in order to be run.  When subclassing TestCase, you can set these attributes: * failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'. * longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in *addition* to any explicit message passed. * maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. &#34;&#34;&#34;  failureException = AssertionError  longMessage = True  maxDiff = 80 * 8  # If a string is longer than _diffThreshold, use normal comparison instead # of difflib.  See #11763. _diffThreshold = 2**16  # Attribute used by TestSuite for classSetUp  _classSetupFailed = False  _class_cleanups = []  def __init__(self, methodName=&#34;runTest&#34;): &#34;&#34;&#34;Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name. &#34;&#34;&#34; self._testMethodName = methodName self._outcome = None self._testMethodDoc = &#34;No test&#34; try: testMethod = getattr(self, methodName) except AttributeError: if methodName != &#34;runTest&#34;: # we allow instantiation with no explicit method name # but not an *incorrect* or missing method name raise ValueError( &#34;no such test method in %s: %s&#34; % (self.__class__, methodName) ) else: self._testMethodDoc = testMethod.__doc__ self._cleanups = [] self._subtest = None  # Map types to custom assertEqual functions that will compare # instances of said type in more detail to generate a more useful # error message. self._type_equality_funcs = {} self.addTypeEqualityFunc(dict, &#34;assertDictEqual&#34;) self.addTypeEqualityFunc(list, &#34;assertListEqual&#34;) self.addTypeEqualityFunc(tuple, &#34;assertTupleEqual&#34;) self.addTypeEqualityFunc(set, &#34;assertSetEqual&#34;) self.addTypeEqualityFunc(frozenset, &#34;assertSetEqual&#34;) self.addTypeEqualityFunc(str, &#34;assertMultiLineEqual&#34;)  def addTypeEqualityFunc(self, typeobj, function): &#34;&#34;&#34;Add a type specific assertEqual style function to compare a type.  This method is for use by TestCase subclasses that need to register their own type equality functions to provide nicer error messages.  Args: typeobj: The data type to call this function on when both values are of the same type in assertEqual(). function: The callable taking two arguments and an optional msg= argument that raises self.failureException with a useful error message when the two arguments are not equal. &#34;&#34;&#34; self._type_equality_funcs[typeobj] = function  def addCleanup(*args, **kwargs): &#34;&#34;&#34;Add a function, with arguments, to be called when the test is completed. Functions added are called on a LIFO basis and are called after tearDown on test failure or success.  Cleanup items are called even if setUp fails (unlike tearDown).&#34;&#34;&#34; if len(args) >= 2: self, function, *args = args elif not args: raise TypeError( &#34;descriptor 'addCleanup' of 'TestCase' object &#34; &#34;needs an argument&#34; ) elif &#34;function&#34; in kwargs: function = kwargs.pop(&#34;function&#34;) self, *args = args import warnings  warnings.warn( &#34;Passing 'function' as keyword argument is deprecated&#34;, DeprecationWarning, stacklevel=2, ) else: raise TypeError( &#34;addCleanup expected at least 1 positional &#34; &#34;argument, got %d&#34; % (len(args) - 1) ) args = tuple(args)  self._cleanups.append((function, args, kwargs))  addCleanup.__text_signature__ = &#34;($self, function, /, *args, **kwargs)&#34;  @classmethod def addClassCleanup(cls, function, *args, **kwargs): &#34;&#34;&#34;Same as addCleanup, except the cleanup items are called even if setUpClass fails (unlike tearDownClass).&#34;&#34;&#34; cls._class_cleanups.append((function, args, kwargs))  def setUp(self): &#34;Hook method for setting up the test fixture before exercising it.&#34; pass  def tearDown(self): &#34;Hook method for deconstructing the test fixture after testing it.&#34; pass  @classmethod def setUpClass(cls): &#34;Hook method for setting up class fixture before running tests in the class.&#34;  @classmethod def tearDownClass(cls): &#34;Hook method for deconstructing the class fixture after running all tests in the class.&#34;  def countTestCases(self): return 1  def defaultTestResult(self): return result.TestResult()  def shortDescription(self): &#34;&#34;&#34;Returns a one-line description of the test, or None if no description has been provided.  The default implementation of this method returns the first line of the specified test method's docstring. &#34;&#34;&#34; doc = self._testMethodDoc return doc.strip().split(&#34;\\n&#34;)[0].strip() if doc else None  def id(self): return &#34;%s.%s&#34; % (strclass(self.__class__), self._testMethodName)  def __eq__(self, other): if type(self) is not type(other): return NotImplemented  return self._testMethodName == other._testMethodName  def __hash__(self): return hash((type(self), self._testMethodName))  def __str__(self): return &#34;%s (%s)&#34; % (self._testMethodName, strclass(self.__class__))  def __repr__(self): return &#34;<%s testMethod=%s>&#34; % (strclass(self.__class__), self._testMethodName)  def _addSkip(self, result, test_case, reason): addSkip = getattr(result, &#34;addSkip&#34;, None) if addSkip is not None: addSkip(test_case, reason) else: warnings.warn( &#34;TestResult has no addSkip method, skips not reported&#34;, RuntimeWarning, 2, ) result.addSuccess(test_case)  @contextlib.contextmanager def subTest(self, msg=_subtest_msg_sentinel, **params): &#34;&#34;&#34;Return a context manager that will return the enclosed block of code in a subtest identified by the optional message and keyword parameters.  A failure in the subtest marks the test case as failed but resumes execution at the end of the enclosed block, allowing further test code to be executed. &#34;&#34;&#34; if self._outcome is None or not self._outcome.result_supports_subtests: yield return parent = self._subtest if parent is None: params_map = _OrderedChainMap(params) else: params_map = parent.params.new_child(params) self._subtest = _SubTest(self, msg, params_map) try: with self._outcome.testPartExecutor(self._subtest, isTest=True): yield if not self._outcome.success: result = self._outcome.result if result is not None and result.failfast: raise _ShouldStop elif self._outcome.expectedFailure: # If the test is expecting a failure, we really want to # stop now and register the expected failure. raise _ShouldStop finally: self._subtest = parent  def _feedErrorsToResult(self, result, errors): for test, exc_info in errors: if isinstance(test, _SubTest): result.addSubTest(test.test_case, test, exc_info) elif exc_info is not None: if issubclass(exc_info[0], self.failureException): result.addFailure(test, exc_info) else: result.addError(test, exc_info)  def _addExpectedFailure(self, result, exc_info): try: addExpectedFailure = result.addExpectedFailure except AttributeError: warnings.warn( &#34;TestResult has no addExpectedFailure method, reporting as passes&#34;, RuntimeWarning, ) result.addSuccess(self) else: addExpectedFailure(self, exc_info)  def _addUnexpectedSuccess(self, result): try: addUnexpectedSuccess = result.addUnexpectedSuccess except AttributeError: warnings.warn( &#34;TestResult has no addUnexpectedSuccess method, reporting as failure&#34;, RuntimeWarning, ) # We need to pass an actual exception and traceback to addFailure, # otherwise the legacy result can choke. try: raise _UnexpectedSuccess from None except _UnexpectedSuccess: result.addFailure(self, sys.exc_info()) else: addUnexpectedSuccess(self)  def _callSetUp(self): self.setUp()  def _callTestMethod(self, method): method()  def _callTearDown(self): self.tearDown()  def _callCleanup(self, function, *args, **kwargs): function(*args, **kwargs)  def run(self, result=None): orig_result = result if result is None: result = self.defaultTestResult() startTestRun = getattr(result, &#34;startTestRun&#34;, None) if startTestRun is not None: startTestRun()  result.startTest(self)  testMethod = getattr(self, self._testMethodName) if getattr(self.__class__, &#34;__unittest_skip__&#34;, False) or getattr( testMethod, &#34;__unittest_skip__&#34;, False ): # If the class or method was skipped. try: skip_why = getattr( self.__class__, &#34;__unittest_skip_why__&#34;, &#34;&#34; ) or getattr(testMethod, &#34;__unittest_skip_why__&#34;, &#34;&#34;) self._addSkip(result, self, skip_why) finally: result.stopTest(self) return expecting_failure_method = getattr( testMethod, &#34;__unittest_expecting_failure__&#34;, False ) expecting_failure_class = getattr(self, &#34;__unittest_expecting_failure__&#34;, False) expecting_failure = expecting_failure_class or expecting_failure_method outcome = _Outcome(result) try: self._outcome = outcome  with outcome.testPartExecutor(self): self._callSetUp() if outcome.success: outcome.expecting_failure = expecting_failure with outcome.testPartExecutor(self, isTest=True): self._callTestMethod(testMethod) outcome.expecting_failure = False with outcome.testPartExecutor(self): self._callTearDown()  self.doCleanups() for test, reason in outcome.skipped: self._addSkip(result, test, reason) self._feedErrorsToResult(result, outcome.errors) if outcome.success: if expecting_failure: if outcome.expectedFailure: self._addExpectedFailure(result, outcome.expectedFailure) else: self._addUnexpectedSuccess(result) else: result.addSuccess(self) return result finally: result.stopTest(self) if orig_result is None: stopTestRun = getattr(result, &#34;stopTestRun&#34;, None) if stopTestRun is not None: stopTestRun()  # explicitly break reference cycles: # outcome.errors -> frame -> outcome -> outcome.errors # outcome.expectedFailure -> frame -> outcome -> outcome.expectedFailure outcome.errors.clear() outcome.expectedFailure = None  # clear the outcome, no more needed self._outcome = None  def doCleanups(self): &#34;&#34;&#34;Execute all cleanup functions. Normally called for you after tearDown.&#34;&#34;&#34; outcome = self._outcome or _Outcome() while self._cleanups: function, args, kwargs = self._cleanups.pop() with outcome.testPartExecutor(self): self._callCleanup(function, *args, **kwargs)  # return this for backwards compatibility # even though we no longer use it internally return outcome.success  @classmethod def doClassCleanups(cls): &#34;&#34;&#34;Execute all class cleanup functions. Normally called for you after tearDownClass.&#34;&#34;&#34; cls.tearDown_exceptions = [] while cls._class_cleanups: function, args, kwargs = cls._class_cleanups.pop() try: function(*args, **kwargs) except Exception: cls.tearDown_exceptions.append(sys.exc_info())  def __call__(self, *args, **kwds): return self.run(*args, **kwds)  def debug(self): &#34;&#34;&#34;Run the test without collecting errors in a TestResult&#34;&#34;&#34; self.setUp() getattr(self, self._testMethodName)() self.tearDown() while self._cleanups: function, args, kwargs = self._cleanups.pop(-1) function(*args, **kwargs)  def skipTest(self, reason): &#34;&#34;&#34;Skip this test.&#34;&#34;&#34; raise SkipTest(reason)  def fail(self, msg=None): &#34;&#34;&#34;Fail immediately, with the given message.&#34;&#34;&#34; raise self.failureException(msg)  def assertFalse(self, expr, msg=None): &#34;&#34;&#34;Check that the expression is false.&#34;&#34;&#34; if expr: msg = self._formatMessage(msg, &#34;%s is not false&#34; % safe_repr(expr)) raise self.failureException(msg)  def assertTrue(self, expr, msg=None): &#34;&#34;&#34;Check that the expression is true.&#34;&#34;&#34; if not expr: msg = self._formatMessage(msg, &#34;%s is not true&#34; % safe_repr(expr)) raise self.failureException(msg)  def _formatMessage(self, msg, standardMsg): &#34;&#34;&#34;Honour the longMessage attribute when generating failure messages. If longMessage is False this means: * Use only an explicit message if it is provided * Otherwise use the standard message for the assert  If longMessage is True: * Use the standard message * If an explicit message is provided, plus ' : ' and the explicit message &#34;&#34;&#34; if not self.longMessage: return msg or standardMsg if msg is None: return standardMsg try: # don't switch to '{}' formatting in Python 2.X # it changes the way unicode input is handled return &#34;%s : %s&#34; % (standardMsg, msg) except UnicodeDecodeError: return &#34;%s : %s&#34; % (safe_repr(standardMsg), safe_repr(msg))  def assertRaises(self, expected_exception, *args, **kwargs): &#34;&#34;&#34;Fail unless an exception of class expected_exception is raised by the callable when invoked with specified positional and keyword arguments. If a different type of exception is raised, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.  If called with the callable and arguments omitted, will return a context object used like this::  with self.assertRaises(SomeException): do_something()  An optional keyword argument 'msg' can be provided when assertRaises is used as a context object.  The context manager keeps a reference to the exception as the 'exception' attribute. This allows you to inspect the exception after the assertion::  with self.assertRaises(SomeException) as cm: do_something() the_exception = cm.exception self.assertEqual(the_exception.error_code, 3) &#34;&#34;&#34; context = _AssertRaisesContext(expected_exception, self) try: return context.handle(&#34;assertRaises&#34;, args, kwargs) finally: # bpo-23890: manually break a reference cycle context = None  def assertWarns(self, expected_warning, *args, **kwargs): &#34;&#34;&#34;Fail unless a warning of class warnClass is triggered by the callable when invoked with specified positional and keyword arguments.  If a different type of warning is triggered, it will not be handled: depending on the other warning filtering rules in effect, it might be silenced, printed out, or raised as an exception.  If called with the callable and arguments omitted, will return a context object used like this::  with self.assertWarns(SomeWarning): do_something()  An optional keyword argument 'msg' can be provided when assertWarns is used as a context object.  The context manager keeps a reference to the first matching warning as the 'warning' attribute; similarly, the 'filename' and 'lineno' attributes give you information about the line of Python code from which the warning was triggered. This allows you to inspect the warning after the assertion::  with self.assertWarns(SomeWarning) as cm: do_something() the_warning = cm.warning self.assertEqual(the_warning.some_attribute, 147) &#34;&#34;&#34; context = _AssertWarnsContext(expected_warning, self) return context.handle(&#34;assertWarns&#34;, args, kwargs)  def assertLogs(self, logger=None, level=None): &#34;&#34;&#34;Fail unless a log message of level *level* or higher is emitted on *logger_name* or its children.  If omitted, *level* defaults to INFO and *logger* defaults to the root logger.  This method must be used as a context manager, and will yield a recording object with two attributes: `output` and `records`. At the end of the context manager, the `output` attribute will be a list of the matching formatted log messages and the `records` attribute will be a list of the corresponding LogRecord objects.  Example::  with self.assertLogs('foo', level='INFO') as cm: logging.getLogger('foo').info('first message') logging.getLogger('foo.bar').error('second message') self.assertEqual(cm.output, ['INFO:foo:first message', 'ERROR:foo.bar:second message']) &#34;&#34;&#34; return _AssertLogsContext(self, logger, level)  def _getAssertEqualityFunc(self, first, second): &#34;&#34;&#34;Get a detailed comparison function for the types of the two args.  Returns: A callable accepting (first, second, msg=None) that will raise a failure exception if first != second with a useful human readable error message for those types. &#34;&#34;&#34; # # NOTE(gregory.p.smith): I considered isinstance(first, type(second)) # and vice versa.  I opted for the conservative approach in case # subclasses are not intended to be compared in detail to their super # class instances using a type equality func.  This means testing # subtypes won't automagically use the detailed comparison.  Callers # should use their type specific assertSpamEqual method to compare # subclasses if the detailed comparison is desired and appropriate. # See the discussion in http://bugs.python.org/issue2578. # if type(first) is type(second): asserter = self._type_equality_funcs.get(type(first)) if asserter is not None: if isinstance(asserter, str): asserter = getattr(self, asserter) return asserter  return self._baseAssertEqual  def _baseAssertEqual(self, first, second, msg=None): &#34;&#34;&#34;The default assertEqual implementation, not type specific.&#34;&#34;&#34; if not first == second: standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(first, second) msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)  def assertEqual(self, first, second, msg=None): &#34;&#34;&#34;Fail if the two objects are unequal as determined by the '==' operator. &#34;&#34;&#34; assertion_func = self._getAssertEqualityFunc(first, second) assertion_func(first, second, msg=msg)  def assertNotEqual(self, first, second, msg=None): &#34;&#34;&#34;Fail if the two objects are equal as determined by the '!=' operator. &#34;&#34;&#34; if not first != second: msg = self._formatMessage( msg, &#34;%s == %s&#34; % (safe_repr(first), safe_repr(second)) ) raise self.failureException(msg)  def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None): &#34;&#34;&#34;Fail if the two objects are unequal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is more than the given delta.  Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit).  If the two objects compare equal then they will automatically compare almost equal. &#34;&#34;&#34; if first == second: # shortcut return if delta is not None and places is not None: raise TypeError(&#34;specify delta or places not both&#34;)  diff = abs(first - second) if delta is not None: if diff <= delta: return  standardMsg = &#34;%s != %s within %s delta (%s difference)&#34; % ( safe_repr(first), safe_repr(second), safe_repr(delta), safe_repr(diff), ) else: if places is None: places = 7  if round(diff, places) == 0: return  standardMsg = &#34;%s != %s within %r places (%s difference)&#34; % ( safe_repr(first), safe_repr(second), places, safe_repr(diff), ) msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)  def assertNotAlmostEqual(self, first, second, places=None, msg=None, delta=None): &#34;&#34;&#34;Fail if the two objects are equal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is less than the given delta.  Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit).  Objects that are equal automatically fail. &#34;&#34;&#34; if delta is not None and places is not None: raise TypeError(&#34;specify delta or places not both&#34;) diff = abs(first - second) if delta is not None: if not (first == second) and diff > delta: return standardMsg = &#34;%s == %s within %s delta (%s difference)&#34; % ( safe_repr(first), safe_repr(second), safe_repr(delta), safe_repr(diff), ) else: if places is None: places = 7 if not (first == second) and round(diff, places) != 0: return standardMsg = &#34;%s == %s within %r places&#34; % ( safe_repr(first), safe_repr(second), places, )  msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)  def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None): &#34;&#34;&#34;An equality assertion for ordered sequences (like lists and tuples).  For the purposes of this function, a valid ordered sequence type is one which can be indexed, has a length, and has an equality operator.  Args: seq1: The first sequence to compare. seq2: The second sequence to compare. seq_type: The expected datatype of the sequences, or None if no datatype should be enforced. msg: Optional message to use on failure instead of a list of differences. &#34;&#34;&#34; if seq_type is not None: seq_type_name = seq_type.__name__ if not isinstance(seq1, seq_type): raise self.failureException( &#34;First sequence is not a %s: %s&#34; % (seq_type_name, safe_repr(seq1)) ) if not isinstance(seq2, seq_type): raise self.failureException( &#34;Second sequence is not a %s: %s&#34; % (seq_type_name, safe_repr(seq2)) ) else: seq_type_name = &#34;sequence&#34;  differing = None try: len1 = len(seq1) except (TypeError, NotImplementedError): differing = &#34;First %s has no length.    Non-sequence?&#34; % (seq_type_name)  if differing is None: try: len2 = len(seq2) except (TypeError, NotImplementedError): differing = &#34;Second %s has no length.    Non-sequence?&#34; % ( seq_type_name )  if differing is None: if seq1 == seq2: return  differing = &#34;%ss differ: %s != %s\\n&#34; % ( (seq_type_name.capitalize(),) + _common_shorten_repr(seq1, seq2) )  for i in range(min(len1, len2)): try: item1 = seq1[i] except (TypeError, IndexError, NotImplementedError): differing += &#34;\\nUnable to index element %d of first %s\\n&#34; % ( i, seq_type_name, ) break  try: item2 = seq2[i] except (TypeError, IndexError, NotImplementedError): differing += &#34;\\nUnable to index element %d of second %s\\n&#34; % ( i, seq_type_name, ) break  if item1 != item2: differing += &#34;\\nFirst differing element %d:\\n%s\\n%s\\n&#34; % ( (i,) + _common_shorten_repr(item1, item2) ) break else: if len1 == len2 and seq_type is None and type(seq1) != type(seq2): # The sequences are the same, but have differing types. return  if len1 > len2: differing += &#34;\\nFirst %s contains %d additional &#34; &#34;elements.\\n&#34; % ( seq_type_name, len1 - len2, ) try: differing += &#34;First extra element %d:\\n%s\\n&#34; % ( len2, safe_repr(seq1[len2]), ) except (TypeError, IndexError, NotImplementedError): differing += &#34;Unable to index element %d &#34; &#34;of first %s\\n&#34; % ( len2, seq_type_name, ) elif len1 < len2: differing += &#34;\\nSecond %s contains %d additional &#34; &#34;elements.\\n&#34; % ( seq_type_name, len2 - len1, ) try: differing += &#34;First extra element %d:\\n%s\\n&#34; % ( len1, safe_repr(seq2[len1]), ) except (TypeError, IndexError, NotImplementedError): differing += &#34;Unable to index element %d &#34; &#34;of second %s\\n&#34; % ( len1, seq_type_name, ) standardMsg = differing diffMsg = &#34;\\n&#34; + &#34;\\n&#34;.join( difflib.ndiff( pprint.pformat(seq1).splitlines(), pprint.pformat(seq2).splitlines() ) )  standardMsg = self._truncateMessage(standardMsg, diffMsg) msg = self._formatMessage(msg, standardMsg) self.fail(msg)  def _truncateMessage(self, message, diff): max_diff = self.maxDiff if max_diff is None or len(diff) <= max_diff: return message + diff return message + (DIFF_OMITTED % len(diff))  def assertListEqual(self, list1, list2, msg=None): &#34;&#34;&#34;A list-specific equality assertion.  Args: list1: The first list to compare. list2: The second list to compare. msg: Optional message to use on failure instead of a list of differences.  &#34;&#34;&#34; self.assertSequenceEqual(list1, list2, msg, seq_type=list)  def assertTupleEqual(self, tuple1, tuple2, msg=None): &#34;&#34;&#34;A tuple-specific equality assertion.  Args: tuple1: The first tuple to compare. tuple2: The second tuple to compare. msg: Optional message to use on failure instead of a list of differences. &#34;&#34;&#34; self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)  def assertSetEqual(self, set1, set2, msg=None): &#34;&#34;&#34;A set-specific equality assertion.  Args: set1: The first set to compare. set2: The second set to compare. msg: Optional message to use on failure instead of a list of differences.  assertSetEqual uses ducktyping to support different types of sets, and is optimized for sets specifically (parameters must support a difference method). &#34;&#34;&#34; try: difference1 = set1.difference(set2) except TypeError as e: self.fail(&#34;invalid type when attempting set difference: %s&#34; % e) except AttributeError as e: self.fail(&#34;first argument does not support set difference: %s&#34; % e)  try: difference2 = set2.difference(set1) except TypeError as e: self.fail(&#34;invalid type when attempting set difference: %s&#34; % e) except AttributeError as e: self.fail(&#34;second argument does not support set difference: %s&#34; % e)  if not (difference1 or difference2): return  lines = [] if difference1: lines.append(&#34;Items in the first set but not the second:&#34;) for item in difference1: lines.append(repr(item)) if difference2: lines.append(&#34;Items in the second set but not the first:&#34;) for item in difference2: lines.append(repr(item))  standardMsg = &#34;\\n&#34;.join(lines) self.fail(self._formatMessage(msg, standardMsg))  def assertIn(self, member, container, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a in b), but with a nicer default message.&#34;&#34;&#34; if member not in container: standardMsg = &#34;%s not found in %s&#34; % ( safe_repr(member), safe_repr(container), ) self.fail(self._formatMessage(msg, standardMsg))  def assertNotIn(self, member, container, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a not in b), but with a nicer default message.&#34;&#34;&#34; if member in container: standardMsg = &#34;%s unexpectedly found in %s&#34; % ( safe_repr(member), safe_repr(container), ) self.fail(self._formatMessage(msg, standardMsg))  def assertIs(self, expr1, expr2, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a is b), but with a nicer default message.&#34;&#34;&#34; if expr1 is not expr2: standardMsg = &#34;%s is not %s&#34; % (safe_repr(expr1), safe_repr(expr2)) self.fail(self._formatMessage(msg, standardMsg))  def assertIsNot(self, expr1, expr2, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a is not b), but with a nicer default message.&#34;&#34;&#34; if expr1 is expr2: standardMsg = &#34;unexpectedly identical: %s&#34; % (safe_repr(expr1),) self.fail(self._formatMessage(msg, standardMsg))  def assertDictEqual(self, d1, d2, msg=None): self.assertIsInstance(d1, dict, &#34;First argument is not a dictionary&#34;) self.assertIsInstance(d2, dict, &#34;Second argument is not a dictionary&#34;)  if d1 != d2: standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(d1, d2) diff = &#34;\\n&#34; + &#34;\\n&#34;.join( difflib.ndiff( pprint.pformat(d1).splitlines(), pprint.pformat(d2).splitlines() ) ) standardMsg = self._truncateMessage(standardMsg, diff) self.fail(self._formatMessage(msg, standardMsg))  def assertDictContainsSubset(self, subset, dictionary, msg=None): &#34;&#34;&#34;Checks whether dictionary is a superset of subset.&#34;&#34;&#34; warnings.warn(&#34;assertDictContainsSubset is deprecated&#34;, DeprecationWarning) missing = [] mismatched = [] for key, value in subset.items(): if key not in dictionary: missing.append(key) elif value != dictionary[key]: mismatched.append( &#34;%s, expected: %s, actual: %s&#34; % (safe_repr(key), safe_repr(value), safe_repr(dictionary[key])) )  if not (missing or mismatched): return  standardMsg = &#34;&#34; if missing: standardMsg = &#34;Missing: %s&#34; % &#34;,&#34;.join(safe_repr(m) for m in missing) if mismatched: if standardMsg: standardMsg += &#34;; &#34; standardMsg += &#34;Mismatched values: %s&#34; % &#34;,&#34;.join(mismatched)  self.fail(self._formatMessage(msg, standardMsg))  def assertCountEqual(self, first, second, msg=None): &#34;&#34;&#34;Asserts that two iterables have the same elements, the same number of times, without regard to order.  self.assertEqual(Counter(list(first)), Counter(list(second)))  Example: - [0, 1, 1] and [1, 0, 1] compare equal. - [0, 0, 1] and [0, 1] compare unequal.  &#34;&#34;&#34; first_seq, second_seq = list(first), list(second) try: first = collections.Counter(first_seq) second = collections.Counter(second_seq) except TypeError: # Handle case with unhashable elements differences = _count_diff_all_purpose(first_seq, second_seq) else: if first == second: return differences = _count_diff_hashable(first_seq, second_seq)  if differences: standardMsg = &#34;Element counts were not equal:\\n&#34; lines = [&#34;First has %d, Second has %d:  %r&#34; % diff for diff in differences] diffMsg = &#34;\\n&#34;.join(lines) standardMsg = self._truncateMessage(standardMsg, diffMsg) msg = self._formatMessage(msg, standardMsg) self.fail(msg)  def assertMultiLineEqual(self, first, second, msg=None): &#34;&#34;&#34;Assert that two multi-line strings are equal.&#34;&#34;&#34; self.assertIsInstance(first, str, &#34;First argument is not a string&#34;) self.assertIsInstance(second, str, &#34;Second argument is not a string&#34;)  if first != second: # don't use difflib if the strings are too long if len(first) > self._diffThreshold or len(second) > self._diffThreshold: self._baseAssertEqual(first, second, msg) firstlines = first.splitlines(keepends=True) secondlines = second.splitlines(keepends=True) if len(firstlines) == 1 and first.strip(&#34;\\r\\n&#34;) == first: firstlines = [first + &#34;\\n&#34;] secondlines = [second + &#34;\\n&#34;] standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(first, second) diff = &#34;\\n&#34; + &#34;&#34;.join(difflib.ndiff(firstlines, secondlines)) standardMsg = self._truncateMessage(standardMsg, diff) self.fail(self._formatMessage(msg, standardMsg))  def assertLess(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a < b), but with a nicer default message.&#34;&#34;&#34; if not a < b: standardMsg = &#34;%s not less than %s&#34; % (safe_repr(a), safe_repr(b)) self.fail(self._formatMessage(msg, standardMsg))  def assertLessEqual(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a <= b), but with a nicer default message.&#34;&#34;&#34; if not a <= b: standardMsg = &#34;%s not less than or equal to %s&#34; % ( safe_repr(a), safe_repr(b), ) self.fail(self._formatMessage(msg, standardMsg))  def assertGreater(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a > b), but with a nicer default message.&#34;&#34;&#34; if not a > b: standardMsg = &#34;%s not greater than %s&#34; % (safe_repr(a), safe_repr(b)) self.fail(self._formatMessage(msg, standardMsg))  def assertGreaterEqual(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a >= b), but with a nicer default message.&#34;&#34;&#34; if not a >= b: standardMsg = &#34;%s not greater than or equal to %s&#34; % ( safe_repr(a), safe_repr(b), ) self.fail(self._formatMessage(msg, standardMsg))  def assertIsNone(self, obj, msg=None): &#34;&#34;&#34;Same as self.assertTrue(obj is None), with a nicer default message.&#34;&#34;&#34; if obj is not None: standardMsg = &#34;%s is not None&#34; % (safe_repr(obj),) self.fail(self._formatMessage(msg, standardMsg))  def assertIsNotNone(self, obj, msg=None): &#34;&#34;&#34;Included for symmetry with assertIsNone.&#34;&#34;&#34; if obj is None: standardMsg = &#34;unexpectedly None&#34; self.fail(self._formatMessage(msg, standardMsg))  def assertIsInstance(self, obj, cls, msg=None): &#34;&#34;&#34;Same as self.assertTrue(isinstance(obj, cls)), with a nicer default message.&#34;&#34;&#34; if not isinstance(obj, cls): standardMsg = &#34;%s is not an instance of %r&#34; % (safe_repr(obj), cls) self.fail(self._formatMessage(msg, standardMsg))  def assertNotIsInstance(self, obj, cls, msg=None): &#34;&#34;&#34;Included for symmetry with assertIsInstance.&#34;&#34;&#34; if isinstance(obj, cls): standardMsg = &#34;%s is an instance of %r&#34; % (safe_repr(obj), cls) self.fail(self._formatMessage(msg, standardMsg))  def assertRaisesRegex(self, expected_exception, expected_regex, *args, **kwargs): &#34;&#34;&#34;Asserts that the message in a raised exception matches a regex.  Args: expected_exception: Exception class expected to be raised. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertRaisesRegex is used as a context manager. &#34;&#34;&#34; context = _AssertRaisesContext(expected_exception, self, expected_regex) return context.handle(&#34;assertRaisesRegex&#34;, args, kwargs)  def assertWarnsRegex(self, expected_warning, expected_regex, *args, **kwargs): &#34;&#34;&#34;Asserts that the message in a triggered warning matches a regexp. Basic functioning is similar to assertWarns() with the addition that only warnings whose messages also match the regular expression are considered successful matches.  Args: expected_warning: Warning class expected to be triggered. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertWarnsRegex is used as a context manager. &#34;&#34;&#34; context = _AssertWarnsContext(expected_warning, self, expected_regex) return context.handle(&#34;assertWarnsRegex&#34;, args, kwargs)  def assertRegex(self, text, expected_regex, msg=None): &#34;&#34;&#34;Fail the test unless the text matches the regular expression.&#34;&#34;&#34; if isinstance(expected_regex, (str, bytes)): assert expected_regex, &#34;expected_regex must not be empty.&#34; expected_regex = re.compile(expected_regex) if not expected_regex.search(text): standardMsg = &#34;Regex didn't match: %r not found in %r&#34; % ( expected_regex.pattern, text, ) # _formatMessage ensures the longMessage option is respected msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)  def assertNotRegex(self, text, unexpected_regex, msg=None): &#34;&#34;&#34;Fail the test if the text matches the regular expression.&#34;&#34;&#34; if isinstance(unexpected_regex, (str, bytes)): unexpected_regex = re.compile(unexpected_regex) match = unexpected_regex.search(text) if match: standardMsg = &#34;Regex matched: %r matches %r in %r&#34; % ( text[match.start() : match.end()], unexpected_regex.pattern, text, ) # _formatMessage ensures the longMessage option is respected msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)  def _deprecate(original_func): def deprecated_func(*args, **kwargs): warnings.warn( &#34;Please use {0} instead.&#34;.format(original_func.__name__), DeprecationWarning, 2, ) return original_func(*args, **kwargs)  return deprecated_func  # see #9424 failUnlessEqual = assertEquals = _deprecate(assertEqual) failIfEqual = assertNotEquals = _deprecate(assertNotEqual) failUnlessAlmostEqual = assertAlmostEquals = _deprecate(assertAlmostEqual) failIfAlmostEqual = assertNotAlmostEquals = _deprecate(assertNotAlmostEqual) failUnless = assert_ = _deprecate(assertTrue) failUnlessRaises = _deprecate(assertRaises) failIf = _deprecate(assertFalse) assertRaisesRegexp = _deprecate(assertRaisesRegex) assertRegexpMatches = _deprecate(assertRegex) assertNotRegexpMatches = _deprecate(assertNotRegex)",
                    "signature": "class TestCase(object): &#34;&#34;&#34;A class whose instances are single test cases.  By default, the test code itself should be placed in a method named 'runTest'.  If the fixture may be used for many test cases, create as many test methods as are needed. When instantiating such a TestCase subclass, specify in the constructor arguments the name of the test method that the instance is to execute.  Test authors should subclass TestCase for their own tests. Construction and deconstruction of the test's environment ('fixture') can be implemented by overriding the 'setUp' and 'tearDown' methods respectively.  If it is necessary to override the __init__ method, the base class __init__ method must always be called. It is important that subclasses should not change the signature of their __init__ method, since instances of the classes are instantiated automatically by parts of the framework in order to be run.  When subclassing TestCase, you can set these attributes: * failureException: determines which exception will be raised when the instance's assertion methods fail; test methods raising this exception will be deemed to have 'failed' rather than 'errored'. * longMessage: determines whether long messages (including repr of objects used in assert methods) will be printed on failure in *addition* to any explicit message passed. * maxDiff: sets the maximum length of a diff in failure messages by assert methods using difflib. It is looked up as an instance attribute so can be configured by individual tests if required. &#34;&#34;&#34;  failureException = AssertionError  longMessage = True  maxDiff = 80 * 8  # If a string is longer than _diffThreshold, use normal comparison instead # of difflib.  See #11763. _diffThreshold = 2**16  # Attribute used by TestSuite for classSetUp  _classSetupFailed = False  _class_cleanups = []  def __init__(self, methodName=&#34;runTest&#34;): &#34;&#34;&#34;Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name. &#34;&#34;&#34; self._testMethodName = methodName self._outcome = None self._testMethodDoc = &#34;No test&#34; try: testMethod = getattr(self, methodName) except AttributeError: if methodName != &#34;runTest&#34;: # we allow instantiation with no explicit method name # but not an *incorrect* or missing method name raise ValueError( &#34;no such test method in %s: %s&#34; % (self.__class__, methodName) ) else: self._testMethodDoc = testMethod.__doc__ self._cleanups = [] self._subtest = None  # Map types to custom assertEqual functions that will compare # instances of said type in more detail to generate a more useful # error message. self._type_equality_funcs = {} self.addTypeEqualityFunc(dict, &#34;assertDictEqual&#34;) self.addTypeEqualityFunc(list, &#34;assertListEqual&#34;) self.addTypeEqualityFunc(tuple, &#34;assertTupleEqual&#34;) self.addTypeEqualityFunc(set, &#34;assertSetEqual&#34;) self.addTypeEqualityFunc(frozenset, &#34;assertSetEqual&#34;) self.addTypeEqualityFunc(str, &#34;assertMultiLineEqual&#34;)  def addTypeEqualityFunc(self, typeobj, function): &#34;&#34;&#34;Add a type specific assertEqual style function to compare a type.  This method is for use by TestCase subclasses that need to register their own type equality functions to provide nicer error messages.  Args: typeobj: The data type to call this function on when both values are of the same type in assertEqual(). function: The callable taking two arguments and an optional msg= argument that raises self.failureException with a useful error message when the two arguments are not equal. &#34;&#34;&#34; self._type_equality_funcs[typeobj] = function  def addCleanup(*args, **kwargs): &#34;&#34;&#34;Add a function, with arguments, to be called when the test is completed. Functions added are called on a LIFO basis and are called after tearDown on test failure or success.  Cleanup items are called even if setUp fails (unlike tearDown).&#34;&#34;&#34; if len(args) >= 2: self, function, *args = args elif not args: raise TypeError( &#34;descriptor 'addCleanup' of 'TestCase' object &#34; &#34;needs an argument&#34; ) elif &#34;function&#34; in kwargs: function = kwargs.pop(&#34;function&#34;) self, *args = args import warnings  warnings.warn( &#34;Passing 'function' as keyword argument is deprecated&#34;, DeprecationWarning, stacklevel=2, ) else: raise TypeError( &#34;addCleanup expected at least 1 positional &#34; &#34;argument, got %d&#34; % (len(args) - 1) ) args = tuple(args)  self._cleanups.append((function, args, kwargs))  addCleanup.__text_signature__ = &#34;($self, function, /, *args, **kwargs)&#34;  @classmethod def addClassCleanup(cls, function, *args, **kwargs): &#34;&#34;&#34;Same as addCleanup, except the cleanup items are called even if setUpClass fails (unlike tearDownClass).&#34;&#34;&#34; cls._class_cleanups.append((function, args, kwargs))  def setUp(self): &#34;Hook method for setting up the test fixture before exercising it.&#34; pass  def tearDown(self): &#34;Hook method for deconstructing the test fixture after testing it.&#34; pass  @classmethod def setUpClass(cls): &#34;Hook method for setting up class fixture before running tests in the class.&#34;  @classmethod def tearDownClass(cls): &#34;Hook method for deconstructing the class fixture after running all tests in the class.&#34;  def countTestCases(self): return 1  def defaultTestResult(self): return result.TestResult()  def shortDescription(self): &#34;&#34;&#34;Returns a one-line description of the test, or None if no description has been provided.  The default implementation of this method returns the first line of the specified test method's docstring. &#34;&#34;&#34; doc = self._testMethodDoc return doc.strip().split(&#34;\\n&#34;)[0].strip() if doc else None  def id(self): return &#34;%s.%s&#34; % (strclass(self.__class__), self._testMethodName)  def __eq__(self, other): if type(self) is not type(other): return NotImplemented  return self._testMethodName == other._testMethodName  def __hash__(self): return hash((type(self), self._testMethodName))  def __str__(self): return &#34;%s (%s)&#34; % (self._testMethodName, strclass(self.__class__))  def __repr__(self): return &#34;<%s testMethod=%s>&#34; % (strclass(self.__class__), self._testMethodName)  def _addSkip(self, result, test_case, reason): addSkip = getattr(result, &#34;addSkip&#34;, None) if addSkip is not None: addSkip(test_case, reason) else: warnings.warn( &#34;TestResult has no addSkip method, skips not reported&#34;, RuntimeWarning, 2, ) result.addSuccess(test_case)  @contextlib.contextmanager def subTest(self, msg=_subtest_msg_sentinel, **params): &#34;&#34;&#34;Return a context manager that will return the enclosed block of code in a subtest identified by the optional message and keyword parameters.  A failure in the subtest marks the test case as failed but resumes execution at the end of the enclosed block, allowing further test code to be executed. &#34;&#34;&#34; if self._outcome is None or not self._outcome.result_supports_subtests: yield return parent = self._subtest if parent is None: params_map = _OrderedChainMap(params) else: params_map = parent.params.new_child(params) self._subtest = _SubTest(self, msg, params_map) try: with self._outcome.testPartExecutor(self._subtest, isTest=True): yield if not self._outcome.success: result = self._outcome.result if result is not None and result.failfast: raise _ShouldStop elif self._outcome.expectedFailure: # If the test is expecting a failure, we really want to # stop now and register the expected failure. raise _ShouldStop finally: self._subtest = parent  def _feedErrorsToResult(self, result, errors): for test, exc_info in errors: if isinstance(test, _SubTest): result.addSubTest(test.test_case, test, exc_info) elif exc_info is not None: if issubclass(exc_info[0], self.failureException): result.addFailure(test, exc_info) else: result.addError(test, exc_info)  def _addExpectedFailure(self, result, exc_info): try: addExpectedFailure = result.addExpectedFailure except AttributeError: warnings.warn( &#34;TestResult has no addExpectedFailure method, reporting as passes&#34;, RuntimeWarning, ) result.addSuccess(self) else: addExpectedFailure(self, exc_info)  def _addUnexpectedSuccess(self, result): try: addUnexpectedSuccess = result.addUnexpectedSuccess except AttributeError: warnings.warn( &#34;TestResult has no addUnexpectedSuccess method, reporting as failure&#34;, RuntimeWarning, ) # We need to pass an actual exception and traceback to addFailure, # otherwise the legacy result can choke. try: raise _UnexpectedSuccess from None except _UnexpectedSuccess: result.addFailure(self, sys.exc_info()) else: addUnexpectedSuccess(self)  def _callSetUp(self): self.setUp()  def _callTestMethod(self, method): method()  def _callTearDown(self): self.tearDown()  def _callCleanup(self, function, *args, **kwargs): function(*args, **kwargs)  def run(self, result=None): orig_result = result if result is None: result = self.defaultTestResult() startTestRun = getattr(result, &#34;startTestRun&#34;, None) if startTestRun is not None: startTestRun()  result.startTest(self)  testMethod = getattr(self, self._testMethodName) if getattr(self.__class__, &#34;__unittest_skip__&#34;, False) or getattr( testMethod, &#34;__unittest_skip__&#34;, False ): # If the class or method was skipped. try: skip_why = getattr( self.__class__, &#34;__unittest_skip_why__&#34;, &#34;&#34; ) or getattr(testMethod, &#34;__unittest_skip_why__&#34;, &#34;&#34;) self._addSkip(result, self, skip_why) finally: result.stopTest(self) return expecting_failure_method = getattr( testMethod, &#34;__unittest_expecting_failure__&#34;, False ) expecting_failure_class = getattr(self, &#34;__unittest_expecting_failure__&#34;, False) expecting_failure = expecting_failure_class or expecting_failure_method outcome = _Outcome(result) try: self._outcome = outcome  with outcome.testPartExecutor(self): self._callSetUp() if outcome.success: outcome.expecting_failure = expecting_failure with outcome.testPartExecutor(self, isTest=True): self._callTestMethod(testMethod) outcome.expecting_failure = False with outcome.testPartExecutor(self): self._callTearDown()  self.doCleanups() for test, reason in outcome.skipped: self._addSkip(result, test, reason) self._feedErrorsToResult(result, outcome.errors) if outcome.success: if expecting_failure: if outcome.expectedFailure: self._addExpectedFailure(result, outcome.expectedFailure) else: self._addUnexpectedSuccess(result) else: result.addSuccess(self) return result finally: result.stopTest(self) if orig_result is None: stopTestRun = getattr(result, &#34;stopTestRun&#34;, None) if stopTestRun is not None: stopTestRun()  # explicitly break reference cycles: # outcome.errors -> frame -> outcome -> outcome.errors # outcome.expectedFailure -> frame -> outcome -> outcome.expectedFailure outcome.errors.clear() outcome.expectedFailure = None  # clear the outcome, no more needed self._outcome = None  def doCleanups(self): &#34;&#34;&#34;Execute all cleanup functions. Normally called for you after tearDown.&#34;&#34;&#34; outcome = self._outcome or _Outcome() while self._cleanups: function, args, kwargs = self._cleanups.pop() with outcome.testPartExecutor(self): self._callCleanup(function, *args, **kwargs)  # return this for backwards compatibility # even though we no longer use it internally return outcome.success  @classmethod def doClassCleanups(cls): &#34;&#34;&#34;Execute all class cleanup functions. Normally called for you after tearDownClass.&#34;&#34;&#34; cls.tearDown_exceptions = [] while cls._class_cleanups: function, args, kwargs = cls._class_cleanups.pop() try: function(*args, **kwargs) except Exception: cls.tearDown_exceptions.append(sys.exc_info())  def __call__(self, *args, **kwds): return self.run(*args, **kwds)  def debug(self): &#34;&#34;&#34;Run the test without collecting errors in a TestResult&#34;&#34;&#34; self.setUp() getattr(self, self._testMethodName)() self.tearDown() while self._cleanups: function, args, kwargs = self._cleanups.pop(-1) function(*args, **kwargs)  def skipTest(self, reason): &#34;&#34;&#34;Skip this test.&#34;&#34;&#34; raise SkipTest(reason)  def fail(self, msg=None): &#34;&#34;&#34;Fail immediately, with the given message.&#34;&#34;&#34; raise self.failureException(msg)  def assertFalse(self, expr, msg=None): &#34;&#34;&#34;Check that the expression is false.&#34;&#34;&#34; if expr: msg = self._formatMessage(msg, &#34;%s is not false&#34; % safe_repr(expr)) raise self.failureException(msg)  def assertTrue(self, expr, msg=None): &#34;&#34;&#34;Check that the expression is true.&#34;&#34;&#34; if not expr: msg = self._formatMessage(msg, &#34;%s is not true&#34; % safe_repr(expr)) raise self.failureException(msg)  def _formatMessage(self, msg, standardMsg): &#34;&#34;&#34;Honour the longMessage attribute when generating failure messages. If longMessage is False this means: * Use only an explicit message if it is provided * Otherwise use the standard message for the assert  If longMessage is True: * Use the standard message * If an explicit message is provided, plus ' : ' and the explicit message &#34;&#34;&#34; if not self.longMessage: return msg or standardMsg if msg is None: return standardMsg try: # don't switch to '{}' formatting in Python 2.X # it changes the way unicode input is handled return &#34;%s : %s&#34; % (standardMsg, msg) except UnicodeDecodeError: return &#34;%s : %s&#34; % (safe_repr(standardMsg), safe_repr(msg))  def assertRaises(self, expected_exception, *args, **kwargs): &#34;&#34;&#34;Fail unless an exception of class expected_exception is raised by the callable when invoked with specified positional and keyword arguments. If a different type of exception is raised, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.  If called with the callable and arguments omitted, will return a context object used like this::  with self.assertRaises(SomeException): do_something()  An optional keyword argument 'msg' can be provided when assertRaises is used as a context object.  The context manager keeps a reference to the exception as the 'exception' attribute. This allows you to inspect the exception after the assertion::  with self.assertRaises(SomeException) as cm: do_something() the_exception = cm.exception self.assertEqual(the_exception.error_code, 3) &#34;&#34;&#34; context = _AssertRaisesContext(expected_exception, self) try: return context.handle(&#34;assertRaises&#34;, args, kwargs) finally: # bpo-23890: manually break a reference cycle context = None  def assertWarns(self, expected_warning, *args, **kwargs): &#34;&#34;&#34;Fail unless a warning of class warnClass is triggered by the callable when invoked with specified positional and keyword arguments.  If a different type of warning is triggered, it will not be handled: depending on the other warning filtering rules in effect, it might be silenced, printed out, or raised as an exception.  If called with the callable and arguments omitted, will return a context object used like this::  with self.assertWarns(SomeWarning): do_something()  An optional keyword argument 'msg' can be provided when assertWarns is used as a context object.  The context manager keeps a reference to the first matching warning as the 'warning' attribute; similarly, the 'filename' and 'lineno' attributes give you information about the line of Python code from which the warning was triggered. This allows you to inspect the warning after the assertion::  with self.assertWarns(SomeWarning) as cm: do_something() the_warning = cm.warning self.assertEqual(the_warning.some_attribute, 147) &#34;&#34;&#34; context = _AssertWarnsContext(expected_warning, self) return context.handle(&#34;assertWarns&#34;, args, kwargs)  def assertLogs(self, logger=None, level=None): &#34;&#34;&#34;Fail unless a log message of level *level* or higher is emitted on *logger_name* or its children.  If omitted, *level* defaults to INFO and *logger* defaults to the root logger.  This method must be used as a context manager, and will yield a recording object with two attributes: `output` and `records`. At the end of the context manager, the `output` attribute will be a list of the matching formatted log messages and the `records` attribute will be a list of the corresponding LogRecord objects.  Example::  with self.assertLogs('foo', level='INFO') as cm: logging.getLogger('foo').info('first message') logging.getLogger('foo.bar').error('second message') self.assertEqual(cm.output, ['INFO:foo:first message', 'ERROR:foo.bar:second message']) &#34;&#34;&#34; return _AssertLogsContext(self, logger, level)  def _getAssertEqualityFunc(self, first, second): &#34;&#34;&#34;Get a detailed comparison function for the types of the two args.  Returns: A callable accepting (first, second, msg=None) that will raise a failure exception if first != second with a useful human readable error message for those types. &#34;&#34;&#34; # # NOTE(gregory.p.smith): I considered isinstance(first, type(second)) # and vice versa.  I opted for the conservative approach in case # subclasses are not intended to be compared in detail to their super # class instances using a type equality func.  This means testing # subtypes won't automagically use the detailed comparison.  Callers # should use their type specific assertSpamEqual method to compare # subclasses if the detailed comparison is desired and appropriate. # See the discussion in http://bugs.python.org/issue2578. # if type(first) is type(second): asserter = self._type_equality_funcs.get(type(first)) if asserter is not None: if isinstance(asserter, str): asserter = getattr(self, asserter) return asserter  return self._baseAssertEqual  def _baseAssertEqual(self, first, second, msg=None): &#34;&#34;&#34;The default assertEqual implementation, not type specific.&#34;&#34;&#34; if not first == second: standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(first, second) msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)  def assertEqual(self, first, second, msg=None): &#34;&#34;&#34;Fail if the two objects are unequal as determined by the '==' operator. &#34;&#34;&#34; assertion_func = self._getAssertEqualityFunc(first, second) assertion_func(first, second, msg=msg)  def assertNotEqual(self, first, second, msg=None): &#34;&#34;&#34;Fail if the two objects are equal as determined by the '!=' operator. &#34;&#34;&#34; if not first != second: msg = self._formatMessage( msg, &#34;%s == %s&#34; % (safe_repr(first), safe_repr(second)) ) raise self.failureException(msg)  def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None): &#34;&#34;&#34;Fail if the two objects are unequal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is more than the given delta.  Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit).  If the two objects compare equal then they will automatically compare almost equal. &#34;&#34;&#34; if first == second: # shortcut return if delta is not None and places is not None: raise TypeError(&#34;specify delta or places not both&#34;)  diff = abs(first - second) if delta is not None: if diff <= delta: return  standardMsg = &#34;%s != %s within %s delta (%s difference)&#34; % ( safe_repr(first), safe_repr(second), safe_repr(delta), safe_repr(diff), ) else: if places is None: places = 7  if round(diff, places) == 0: return  standardMsg = &#34;%s != %s within %r places (%s difference)&#34; % ( safe_repr(first), safe_repr(second), places, safe_repr(diff), ) msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)  def assertNotAlmostEqual(self, first, second, places=None, msg=None, delta=None): &#34;&#34;&#34;Fail if the two objects are equal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is less than the given delta.  Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit).  Objects that are equal automatically fail. &#34;&#34;&#34; if delta is not None and places is not None: raise TypeError(&#34;specify delta or places not both&#34;) diff = abs(first - second) if delta is not None: if not (first == second) and diff > delta: return standardMsg = &#34;%s == %s within %s delta (%s difference)&#34; % ( safe_repr(first), safe_repr(second), safe_repr(delta), safe_repr(diff), ) else: if places is None: places = 7 if not (first == second) and round(diff, places) != 0: return standardMsg = &#34;%s == %s within %r places&#34; % ( safe_repr(first), safe_repr(second), places, )  msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)  def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None): &#34;&#34;&#34;An equality assertion for ordered sequences (like lists and tuples).  For the purposes of this function, a valid ordered sequence type is one which can be indexed, has a length, and has an equality operator.  Args: seq1: The first sequence to compare. seq2: The second sequence to compare. seq_type: The expected datatype of the sequences, or None if no datatype should be enforced. msg: Optional message to use on failure instead of a list of differences. &#34;&#34;&#34; if seq_type is not None: seq_type_name = seq_type.__name__ if not isinstance(seq1, seq_type): raise self.failureException( &#34;First sequence is not a %s: %s&#34; % (seq_type_name, safe_repr(seq1)) ) if not isinstance(seq2, seq_type): raise self.failureException( &#34;Second sequence is not a %s: %s&#34; % (seq_type_name, safe_repr(seq2)) ) else: seq_type_name = &#34;sequence&#34;  differing = None try: len1 = len(seq1) except (TypeError, NotImplementedError): differing = &#34;First %s has no length.    Non-sequence?&#34; % (seq_type_name)  if differing is None: try: len2 = len(seq2) except (TypeError, NotImplementedError): differing = &#34;Second %s has no length.    Non-sequence?&#34; % ( seq_type_name )  if differing is None: if seq1 == seq2: return  differing = &#34;%ss differ: %s != %s\\n&#34; % ( (seq_type_name.capitalize(),) + _common_shorten_repr(seq1, seq2) )  for i in range(min(len1, len2)): try: item1 = seq1[i] except (TypeError, IndexError, NotImplementedError): differing += &#34;\\nUnable to index element %d of first %s\\n&#34; % ( i, seq_type_name, ) break  try: item2 = seq2[i] except (TypeError, IndexError, NotImplementedError): differing += &#34;\\nUnable to index element %d of second %s\\n&#34; % ( i, seq_type_name, ) break  if item1 != item2: differing += &#34;\\nFirst differing element %d:\\n%s\\n%s\\n&#34; % ( (i,) + _common_shorten_repr(item1, item2) ) break else: if len1 == len2 and seq_type is None and type(seq1) != type(seq2): # The sequences are the same, but have differing types. return  if len1 > len2: differing += &#34;\\nFirst %s contains %d additional &#34; &#34;elements.\\n&#34; % ( seq_type_name, len1 - len2, ) try: differing += &#34;First extra element %d:\\n%s\\n&#34; % ( len2, safe_repr(seq1[len2]), ) except (TypeError, IndexError, NotImplementedError): differing += &#34;Unable to index element %d &#34; &#34;of first %s\\n&#34; % ( len2, seq_type_name, ) elif len1 < len2: differing += &#34;\\nSecond %s contains %d additional &#34; &#34;elements.\\n&#34; % ( seq_type_name, len2 - len1, ) try: differing += &#34;First extra element %d:\\n%s\\n&#34; % ( len1, safe_repr(seq2[len1]), ) except (TypeError, IndexError, NotImplementedError): differing += &#34;Unable to index element %d &#34; &#34;of second %s\\n&#34; % ( len1, seq_type_name, ) standardMsg = differing diffMsg = &#34;\\n&#34; + &#34;\\n&#34;.join( difflib.ndiff( pprint.pformat(seq1).splitlines(), pprint.pformat(seq2).splitlines() ) )  standardMsg = self._truncateMessage(standardMsg, diffMsg) msg = self._formatMessage(msg, standardMsg) self.fail(msg)  def _truncateMessage(self, message, diff): max_diff = self.maxDiff if max_diff is None or len(diff) <= max_diff: return message + diff return message + (DIFF_OMITTED % len(diff))  def assertListEqual(self, list1, list2, msg=None): &#34;&#34;&#34;A list-specific equality assertion.  Args: list1: The first list to compare. list2: The second list to compare. msg: Optional message to use on failure instead of a list of differences.  &#34;&#34;&#34; self.assertSequenceEqual(list1, list2, msg, seq_type=list)  def assertTupleEqual(self, tuple1, tuple2, msg=None): &#34;&#34;&#34;A tuple-specific equality assertion.  Args: tuple1: The first tuple to compare. tuple2: The second tuple to compare. msg: Optional message to use on failure instead of a list of differences. &#34;&#34;&#34; self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)  def assertSetEqual(self, set1, set2, msg=None): &#34;&#34;&#34;A set-specific equality assertion.  Args: set1: The first set to compare. set2: The second set to compare. msg: Optional message to use on failure instead of a list of differences.  assertSetEqual uses ducktyping to support different types of sets, and is optimized for sets specifically (parameters must support a difference method). &#34;&#34;&#34; try: difference1 = set1.difference(set2) except TypeError as e: self.fail(&#34;invalid type when attempting set difference: %s&#34; % e) except AttributeError as e: self.fail(&#34;first argument does not support set difference: %s&#34; % e)  try: difference2 = set2.difference(set1) except TypeError as e: self.fail(&#34;invalid type when attempting set difference: %s&#34; % e) except AttributeError as e: self.fail(&#34;second argument does not support set difference: %s&#34; % e)  if not (difference1 or difference2): return  lines = [] if difference1: lines.append(&#34;Items in the first set but not the second:&#34;) for item in difference1: lines.append(repr(item)) if difference2: lines.append(&#34;Items in the second set but not the first:&#34;) for item in difference2: lines.append(repr(item))  standardMsg = &#34;\\n&#34;.join(lines) self.fail(self._formatMessage(msg, standardMsg))  def assertIn(self, member, container, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a in b), but with a nicer default message.&#34;&#34;&#34; if member not in container: standardMsg = &#34;%s not found in %s&#34; % ( safe_repr(member), safe_repr(container), ) self.fail(self._formatMessage(msg, standardMsg))  def assertNotIn(self, member, container, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a not in b), but with a nicer default message.&#34;&#34;&#34; if member in container: standardMsg = &#34;%s unexpectedly found in %s&#34; % ( safe_repr(member), safe_repr(container), ) self.fail(self._formatMessage(msg, standardMsg))  def assertIs(self, expr1, expr2, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a is b), but with a nicer default message.&#34;&#34;&#34; if expr1 is not expr2: standardMsg = &#34;%s is not %s&#34; % (safe_repr(expr1), safe_repr(expr2)) self.fail(self._formatMessage(msg, standardMsg))  def assertIsNot(self, expr1, expr2, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a is not b), but with a nicer default message.&#34;&#34;&#34; if expr1 is expr2: standardMsg = &#34;unexpectedly identical: %s&#34; % (safe_repr(expr1),) self.fail(self._formatMessage(msg, standardMsg))  def assertDictEqual(self, d1, d2, msg=None): self.assertIsInstance(d1, dict, &#34;First argument is not a dictionary&#34;) self.assertIsInstance(d2, dict, &#34;Second argument is not a dictionary&#34;)  if d1 != d2: standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(d1, d2) diff = &#34;\\n&#34; + &#34;\\n&#34;.join( difflib.ndiff( pprint.pformat(d1).splitlines(), pprint.pformat(d2).splitlines() ) ) standardMsg = self._truncateMessage(standardMsg, diff) self.fail(self._formatMessage(msg, standardMsg))  def assertDictContainsSubset(self, subset, dictionary, msg=None): &#34;&#34;&#34;Checks whether dictionary is a superset of subset.&#34;&#34;&#34; warnings.warn(&#34;assertDictContainsSubset is deprecated&#34;, DeprecationWarning) missing = [] mismatched = [] for key, value in subset.items(): if key not in dictionary: missing.append(key) elif value != dictionary[key]: mismatched.append( &#34;%s, expected: %s, actual: %s&#34; % (safe_repr(key), safe_repr(value), safe_repr(dictionary[key])) )  if not (missing or mismatched): return  standardMsg = &#34;&#34; if missing: standardMsg = &#34;Missing: %s&#34; % &#34;,&#34;.join(safe_repr(m) for m in missing) if mismatched: if standardMsg: standardMsg += &#34;; &#34; standardMsg += &#34;Mismatched values: %s&#34; % &#34;,&#34;.join(mismatched)  self.fail(self._formatMessage(msg, standardMsg))  def assertCountEqual(self, first, second, msg=None): &#34;&#34;&#34;Asserts that two iterables have the same elements, the same number of times, without regard to order.  self.assertEqual(Counter(list(first)), Counter(list(second)))  Example: - [0, 1, 1] and [1, 0, 1] compare equal. - [0, 0, 1] and [0, 1] compare unequal.  &#34;&#34;&#34; first_seq, second_seq = list(first), list(second) try: first = collections.Counter(first_seq) second = collections.Counter(second_seq) except TypeError: # Handle case with unhashable elements differences = _count_diff_all_purpose(first_seq, second_seq) else: if first == second: return differences = _count_diff_hashable(first_seq, second_seq)  if differences: standardMsg = &#34;Element counts were not equal:\\n&#34; lines = [&#34;First has %d, Second has %d:  %r&#34; % diff for diff in differences] diffMsg = &#34;\\n&#34;.join(lines) standardMsg = self._truncateMessage(standardMsg, diffMsg) msg = self._formatMessage(msg, standardMsg) self.fail(msg)  def assertMultiLineEqual(self, first, second, msg=None): &#34;&#34;&#34;Assert that two multi-line strings are equal.&#34;&#34;&#34; self.assertIsInstance(first, str, &#34;First argument is not a string&#34;) self.assertIsInstance(second, str, &#34;Second argument is not a string&#34;)  if first != second: # don't use difflib if the strings are too long if len(first) > self._diffThreshold or len(second) > self._diffThreshold: self._baseAssertEqual(first, second, msg) firstlines = first.splitlines(keepends=True) secondlines = second.splitlines(keepends=True) if len(firstlines) == 1 and first.strip(&#34;\\r\\n&#34;) == first: firstlines = [first + &#34;\\n&#34;] secondlines = [second + &#34;\\n&#34;] standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(first, second) diff = &#34;\\n&#34; + &#34;&#34;.join(difflib.ndiff(firstlines, secondlines)) standardMsg = self._truncateMessage(standardMsg, diff) self.fail(self._formatMessage(msg, standardMsg))  def assertLess(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a < b), but with a nicer default message.&#34;&#34;&#34; if not a < b: standardMsg = &#34;%s not less than %s&#34; % (safe_repr(a), safe_repr(b)) self.fail(self._formatMessage(msg, standardMsg))  def assertLessEqual(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a <= b), but with a nicer default message.&#34;&#34;&#34; if not a <= b: standardMsg = &#34;%s not less than or equal to %s&#34; % ( safe_repr(a), safe_repr(b), ) self.fail(self._formatMessage(msg, standardMsg))  def assertGreater(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a > b), but with a nicer default message.&#34;&#34;&#34; if not a > b: standardMsg = &#34;%s not greater than %s&#34; % (safe_repr(a), safe_repr(b)) self.fail(self._formatMessage(msg, standardMsg))  def assertGreaterEqual(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a >= b), but with a nicer default message.&#34;&#34;&#34; if not a >= b: standardMsg = &#34;%s not greater than or equal to %s&#34; % ( safe_repr(a), safe_repr(b), ) self.fail(self._formatMessage(msg, standardMsg))  def assertIsNone(self, obj, msg=None): &#34;&#34;&#34;Same as self.assertTrue(obj is None), with a nicer default message.&#34;&#34;&#34; if obj is not None: standardMsg = &#34;%s is not None&#34; % (safe_repr(obj),) self.fail(self._formatMessage(msg, standardMsg))  def assertIsNotNone(self, obj, msg=None): &#34;&#34;&#34;Included for symmetry with assertIsNone.&#34;&#34;&#34; if obj is None: standardMsg = &#34;unexpectedly None&#34; self.fail(self._formatMessage(msg, standardMsg))  def assertIsInstance(self, obj, cls, msg=None): &#34;&#34;&#34;Same as self.assertTrue(isinstance(obj, cls)), with a nicer default message.&#34;&#34;&#34; if not isinstance(obj, cls): standardMsg = &#34;%s is not an instance of %r&#34; % (safe_repr(obj), cls) self.fail(self._formatMessage(msg, standardMsg))  def assertNotIsInstance(self, obj, cls, msg=None): &#34;&#34;&#34;Included for symmetry with assertIsInstance.&#34;&#34;&#34; if isinstance(obj, cls): standardMsg = &#34;%s is an instance of %r&#34; % (safe_repr(obj), cls) self.fail(self._formatMessage(msg, standardMsg))  def assertRaisesRegex(self, expected_exception, expected_regex, *args, **kwargs): &#34;&#34;&#34;Asserts that the message in a raised exception matches a regex.  Args: expected_exception: Exception class expected to be raised. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertRaisesRegex is used as a context manager. &#34;&#34;&#34; context = _AssertRaisesContext(expected_exception, self, expected_regex) return context.handle(&#34;assertRaisesRegex&#34;, args, kwargs)  def assertWarnsRegex(self, expected_warning, expected_regex, *args, **kwargs): &#34;&#34;&#34;Asserts that the message in a triggered warning matches a regexp. Basic functioning is similar to assertWarns() with the addition that only warnings whose messages also match the regular expression are considered successful matches.  Args: expected_warning: Warning class expected to be triggered. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertWarnsRegex is used as a context manager. &#34;&#34;&#34; context = _AssertWarnsContext(expected_warning, self, expected_regex) return context.handle(&#34;assertWarnsRegex&#34;, args, kwargs)  def assertRegex(self, text, expected_regex, msg=None): &#34;&#34;&#34;Fail the test unless the text matches the regular expression.&#34;&#34;&#34; if isinstance(expected_regex, (str, bytes)): assert expected_regex, &#34;expected_regex must not be empty.&#34; expected_regex = re.compile(expected_regex) if not expected_regex.search(text): standardMsg = &#34;Regex didn't match: %r not found in %r&#34; % ( expected_regex.pattern, text, ) # _formatMessage ensures the longMessage option is respected msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)  def assertNotRegex(self, text, unexpected_regex, msg=None): &#34;&#34;&#34;Fail the test if the text matches the regular expression.&#34;&#34;&#34; if isinstance(unexpected_regex, (str, bytes)): unexpected_regex = re.compile(unexpected_regex) match = unexpected_regex.search(text) if match: standardMsg = &#34;Regex matched: %r matches %r in %r&#34; % ( text[match.start() : match.end()], unexpected_regex.pattern, text, ) # _formatMessage ensures the longMessage option is respected msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)  def _deprecate(original_func): def deprecated_func(*args, **kwargs): warnings.warn( &#34;Please use {0} instead.&#34;.format(original_func.__name__), DeprecationWarning, 2, ) return original_func(*args, **kwargs)  return deprecated_func  # see #9424 failUnlessEqual = assertEquals = _deprecate(assertEqual) failIfEqual = assertNotEquals = _deprecate(assertNotEqual) failUnlessAlmostEqual = assertAlmostEquals = _deprecate(assertAlmostEqual) failIfAlmostEqual = assertNotAlmostEquals = _deprecate(assertNotAlmostEqual) failUnless = assert_ = _deprecate(assertTrue) failUnlessRaises = _deprecate(assertRaises) failIf = _deprecate(assertFalse) assertRaisesRegexp = _deprecate(assertRaisesRegex) assertRegexpMatches = _deprecate(assertRegex) assertNotRegexpMatches = _deprecate(assertNotRegex)"
                }
            },
            {
                "id": 194,
                "attributes": {
                    "id": 194.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.addClassCleanup",
                    "type": "function",
                    "code": "def addClassCleanup(cls, function, *args, **kwargs): &#34;&#34;&#34;Same as addCleanup, except the cleanup items are called even if setUpClass fails (unlike tearDownClass).&#34;&#34;&#34; cls._class_cleanups.append((function, args, kwargs))",
                    "signature": "def addClassCleanup(cls, function, *args, **kwargs): &#34;&#34;&#34;Same as addCleanup, except the cleanup items are called even if setUpClass fails (unlike tearDownClass).&#34;&#34;&#34; cls._class_cleanups.append((function, args, kwargs))"
                }
            },
            {
                "id": 195,
                "attributes": {
                    "id": 195.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.setUp",
                    "type": "function",
                    "code": "def setUp(self): &#34;Hook method for setting up the test fixture before exercising it.&#34; pass",
                    "signature": "def setUp(self): &#34;Hook method for setting up the test fixture before exercising it.&#34; pass"
                }
            },
            {
                "id": 196,
                "attributes": {
                    "id": 196.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.tearDown",
                    "type": "function",
                    "code": "def tearDown(self): &#34;Hook method for deconstructing the test fixture after testing it.&#34; pass",
                    "signature": "def tearDown(self): &#34;Hook method for deconstructing the test fixture after testing it.&#34; pass"
                }
            },
            {
                "id": 197,
                "attributes": {
                    "id": 197.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.setUpClass",
                    "type": "function",
                    "code": "def setUpClass(cls): &#34;Hook method for setting up class fixture before running tests in the class.&#34;",
                    "signature": "def setUpClass(cls): &#34;Hook method for setting up class fixture before running tests in the class.&#34;"
                }
            },
            {
                "id": 198,
                "attributes": {
                    "id": 198.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.tearDownClass",
                    "type": "function",
                    "code": "def tearDownClass(cls): &#34;Hook method for deconstructing the class fixture after running all tests in the class.&#34;",
                    "signature": "def tearDownClass(cls): &#34;Hook method for deconstructing the class fixture after running all tests in the class.&#34;"
                }
            },
            {
                "id": 199,
                "attributes": {
                    "id": 199.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.countTestCases",
                    "type": "function",
                    "code": "def countTestCases(self): return 1",
                    "signature": "def countTestCases(self): return 1"
                }
            },
            {
                "id": 200,
                "attributes": {
                    "id": 200.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.defaultTestResult",
                    "type": "function",
                    "code": "def defaultTestResult(self): return result.TestResult()",
                    "signature": "def defaultTestResult(self): return result.TestResult()"
                }
            },
            {
                "id": 203,
                "attributes": {
                    "id": 203.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.__eq__",
                    "type": "function",
                    "code": "def __eq__(self, other): if type(self) is not type(other): return NotImplemented  return self._testMethodName == other._testMethodName",
                    "signature": "def __eq__(self, other): if type(self) is not type(other): return NotImplemented  return self._testMethodName == other._testMethodName"
                }
            },
            {
                "id": 204,
                "attributes": {
                    "id": 204.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.__hash__",
                    "type": "function",
                    "code": "def __hash__(self): return hash((type(self), self._testMethodName))",
                    "signature": "def __hash__(self): return hash((type(self), self._testMethodName))"
                }
            },
            {
                "id": 205,
                "attributes": {
                    "id": 205.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.__str__",
                    "type": "function",
                    "code": "def __str__(self): return &#34;%s (%s)&#34; % (self._testMethodName, strclass(self.__class__))",
                    "signature": "def __str__(self): return &#34;%s (%s)&#34; % (self._testMethodName, strclass(self.__class__))"
                }
            },
            {
                "id": 206,
                "attributes": {
                    "id": 206.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.__repr__",
                    "type": "function",
                    "code": "def __repr__(self): return &#34;<%s testMethod=%s>&#34; % (strclass(self.__class__), self._testMethodName)",
                    "signature": "def __repr__(self): return &#34;<%s testMethod=%s>&#34; % (strclass(self.__class__), self._testMethodName)"
                }
            },
            {
                "id": 207,
                "attributes": {
                    "id": 207.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._addSkip",
                    "type": "function",
                    "code": "def _addSkip(self, result, test_case, reason): addSkip = getattr(result, &#34;addSkip&#34;, None) if addSkip is not None: addSkip(test_case, reason) else: warnings.warn( &#34;TestResult has no addSkip method, skips not reported&#34;, RuntimeWarning, 2, ) result.addSuccess(test_case)",
                    "signature": "def _addSkip(self, result, test_case, reason): addSkip = getattr(result, &#34;addSkip&#34;, None) if addSkip is not None: addSkip(test_case, reason) else: warnings.warn( &#34;TestResult has no addSkip method, skips not reported&#34;, RuntimeWarning, 2, ) result.addSuccess(test_case)"
                }
            },
            {
                "id": 208,
                "attributes": {
                    "id": 208.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.subTest",
                    "type": "function",
                    "code": "def subTest(self, msg=_subtest_msg_sentinel, **params): &#34;&#34;&#34;Return a context manager that will return the enclosed block of code in a subtest identified by the optional message and keyword parameters.  A failure in the subtest marks the test case as failed but resumes execution at the end of the enclosed block, allowing further test code to be executed. &#34;&#34;&#34; if self._outcome is None or not self._outcome.result_supports_subtests: yield return parent = self._subtest if parent is None: params_map = _OrderedChainMap(params) else: params_map = parent.params.new_child(params) self._subtest = _SubTest(self, msg, params_map) try: with self._outcome.testPartExecutor(self._subtest, isTest=True): yield if not self._outcome.success: result = self._outcome.result if result is not None and result.failfast: raise _ShouldStop elif self._outcome.expectedFailure: # If the test is expecting a failure, we really want to # stop now and register the expected failure. raise _ShouldStop finally: self._subtest = parent",
                    "signature": "def subTest(self, msg=_subtest_msg_sentinel, **params): &#34;&#34;&#34;Return a context manager that will return the enclosed block of code in a subtest identified by the optional message and keyword parameters.  A failure in the subtest marks the test case as failed but resumes execution at the end of the enclosed block, allowing further test code to be executed. &#34;&#34;&#34; if self._outcome is None or not self._outcome.result_supports_subtests: yield return parent = self._subtest if parent is None: params_map = _OrderedChainMap(params) else: params_map = parent.params.new_child(params) self._subtest = _SubTest(self, msg, params_map) try: with self._outcome.testPartExecutor(self._subtest, isTest=True): yield if not self._outcome.success: result = self._outcome.result if result is not None and result.failfast: raise _ShouldStop elif self._outcome.expectedFailure: # If the test is expecting a failure, we really want to # stop now and register the expected failure. raise _ShouldStop finally: self._subtest = parent"
                }
            },
            {
                "id": 209,
                "attributes": {
                    "id": 209.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._feedErrorsToResult",
                    "type": "function",
                    "code": "def _feedErrorsToResult(self, result, errors): for test, exc_info in errors: if isinstance(test, _SubTest): result.addSubTest(test.test_case, test, exc_info) elif exc_info is not None: if issubclass(exc_info[0], self.failureException): result.addFailure(test, exc_info) else: result.addError(test, exc_info)",
                    "signature": "def _feedErrorsToResult(self, result, errors): for test, exc_info in errors: if isinstance(test, _SubTest): result.addSubTest(test.test_case, test, exc_info) elif exc_info is not None: if issubclass(exc_info[0], self.failureException): result.addFailure(test, exc_info) else: result.addError(test, exc_info)"
                }
            },
            {
                "id": 210,
                "attributes": {
                    "id": 210.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._addExpectedFailure",
                    "type": "function",
                    "code": "def _addExpectedFailure(self, result, exc_info): try: addExpectedFailure = result.addExpectedFailure except AttributeError: warnings.warn( &#34;TestResult has no addExpectedFailure method, reporting as passes&#34;, RuntimeWarning, ) result.addSuccess(self) else: addExpectedFailure(self, exc_info)",
                    "signature": "def _addExpectedFailure(self, result, exc_info): try: addExpectedFailure = result.addExpectedFailure except AttributeError: warnings.warn( &#34;TestResult has no addExpectedFailure method, reporting as passes&#34;, RuntimeWarning, ) result.addSuccess(self) else: addExpectedFailure(self, exc_info)"
                }
            },
            {
                "id": 211,
                "attributes": {
                    "id": 211.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._addUnexpectedSuccess",
                    "type": "function",
                    "code": "def _addUnexpectedSuccess(self, result): try: addUnexpectedSuccess = result.addUnexpectedSuccess except AttributeError: warnings.warn( &#34;TestResult has no addUnexpectedSuccess method, reporting as failure&#34;, RuntimeWarning, ) # We need to pass an actual exception and traceback to addFailure, # otherwise the legacy result can choke. try: raise _UnexpectedSuccess from None except _UnexpectedSuccess: result.addFailure(self, sys.exc_info()) else: addUnexpectedSuccess(self)",
                    "signature": "def _addUnexpectedSuccess(self, result): try: addUnexpectedSuccess = result.addUnexpectedSuccess except AttributeError: warnings.warn( &#34;TestResult has no addUnexpectedSuccess method, reporting as failure&#34;, RuntimeWarning, ) # We need to pass an actual exception and traceback to addFailure, # otherwise the legacy result can choke. try: raise _UnexpectedSuccess from None except _UnexpectedSuccess: result.addFailure(self, sys.exc_info()) else: addUnexpectedSuccess(self)"
                }
            },
            {
                "id": 212,
                "attributes": {
                    "id": 212.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._callSetUp",
                    "type": "function",
                    "code": "def _callSetUp(self): self.setUp()",
                    "signature": "def _callSetUp(self): self.setUp()"
                }
            },
            {
                "id": 213,
                "attributes": {
                    "id": 213.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._callTestMethod",
                    "type": "function",
                    "code": "def _callTestMethod(self, method): method()",
                    "signature": "def _callTestMethod(self, method): method()"
                }
            },
            {
                "id": 214,
                "attributes": {
                    "id": 214.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._callTearDown",
                    "type": "function",
                    "code": "def _callTearDown(self): self.tearDown()",
                    "signature": "def _callTearDown(self): self.tearDown()"
                }
            },
            {
                "id": 215,
                "attributes": {
                    "id": 215.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._callCleanup",
                    "type": "function",
                    "code": "def _callCleanup(self, function, *args, **kwargs): function(*args, **kwargs)",
                    "signature": "def _callCleanup(self, function, *args, **kwargs): function(*args, **kwargs)"
                }
            },
            {
                "id": 216,
                "attributes": {
                    "id": 216.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.run",
                    "type": "function",
                    "code": "def run(self, result=None): orig_result = result if result is None: result = self.defaultTestResult() startTestRun = getattr(result, &#34;startTestRun&#34;, None) if startTestRun is not None: startTestRun()  result.startTest(self)  testMethod = getattr(self, self._testMethodName) if getattr(self.__class__, &#34;__unittest_skip__&#34;, False) or getattr( testMethod, &#34;__unittest_skip__&#34;, False ): # If the class or method was skipped. try: skip_why = getattr( self.__class__, &#34;__unittest_skip_why__&#34;, &#34;&#34; ) or getattr(testMethod, &#34;__unittest_skip_why__&#34;, &#34;&#34;) self._addSkip(result, self, skip_why) finally: result.stopTest(self) return expecting_failure_method = getattr( testMethod, &#34;__unittest_expecting_failure__&#34;, False ) expecting_failure_class = getattr(self, &#34;__unittest_expecting_failure__&#34;, False) expecting_failure = expecting_failure_class or expecting_failure_method outcome = _Outcome(result) try: self._outcome = outcome  with outcome.testPartExecutor(self): self._callSetUp() if outcome.success: outcome.expecting_failure = expecting_failure with outcome.testPartExecutor(self, isTest=True): self._callTestMethod(testMethod) outcome.expecting_failure = False with outcome.testPartExecutor(self): self._callTearDown()  self.doCleanups() for test, reason in outcome.skipped: self._addSkip(result, test, reason) self._feedErrorsToResult(result, outcome.errors) if outcome.success: if expecting_failure: if outcome.expectedFailure: self._addExpectedFailure(result, outcome.expectedFailure) else: self._addUnexpectedSuccess(result) else: result.addSuccess(self) return result finally: result.stopTest(self) if orig_result is None: stopTestRun = getattr(result, &#34;stopTestRun&#34;, None) if stopTestRun is not None: stopTestRun()  # explicitly break reference cycles: # outcome.errors -> frame -> outcome -> outcome.errors # outcome.expectedFailure -> frame -> outcome -> outcome.expectedFailure outcome.errors.clear() outcome.expectedFailure = None  # clear the outcome, no more needed self._outcome = None",
                    "signature": "def run(self, result=None): orig_result = result if result is None: result = self.defaultTestResult() startTestRun = getattr(result, &#34;startTestRun&#34;, None) if startTestRun is not None: startTestRun()  result.startTest(self)  testMethod = getattr(self, self._testMethodName) if getattr(self.__class__, &#34;__unittest_skip__&#34;, False) or getattr( testMethod, &#34;__unittest_skip__&#34;, False ): # If the class or method was skipped. try: skip_why = getattr( self.__class__, &#34;__unittest_skip_why__&#34;, &#34;&#34; ) or getattr(testMethod, &#34;__unittest_skip_why__&#34;, &#34;&#34;) self._addSkip(result, self, skip_why) finally: result.stopTest(self) return expecting_failure_method = getattr( testMethod, &#34;__unittest_expecting_failure__&#34;, False ) expecting_failure_class = getattr(self, &#34;__unittest_expecting_failure__&#34;, False) expecting_failure = expecting_failure_class or expecting_failure_method outcome = _Outcome(result) try: self._outcome = outcome  with outcome.testPartExecutor(self): self._callSetUp() if outcome.success: outcome.expecting_failure = expecting_failure with outcome.testPartExecutor(self, isTest=True): self._callTestMethod(testMethod) outcome.expecting_failure = False with outcome.testPartExecutor(self): self._callTearDown()  self.doCleanups() for test, reason in outcome.skipped: self._addSkip(result, test, reason) self._feedErrorsToResult(result, outcome.errors) if outcome.success: if expecting_failure: if outcome.expectedFailure: self._addExpectedFailure(result, outcome.expectedFailure) else: self._addUnexpectedSuccess(result) else: result.addSuccess(self) return result finally: result.stopTest(self) if orig_result is None: stopTestRun = getattr(result, &#34;stopTestRun&#34;, None) if stopTestRun is not None: stopTestRun()  # explicitly break reference cycles: # outcome.errors -> frame -> outcome -> outcome.errors # outcome.expectedFailure -> frame -> outcome -> outcome.expectedFailure outcome.errors.clear() outcome.expectedFailure = None  # clear the outcome, no more needed self._outcome = None"
                }
            },
            {
                "id": 217,
                "attributes": {
                    "id": 217.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.doCleanups",
                    "type": "function",
                    "code": "def doCleanups(self): &#34;&#34;&#34;Execute all cleanup functions. Normally called for you after tearDown.&#34;&#34;&#34; outcome = self._outcome or _Outcome() while self._cleanups: function, args, kwargs = self._cleanups.pop() with outcome.testPartExecutor(self): self._callCleanup(function, *args, **kwargs)  # return this for backwards compatibility # even though we no longer use it internally return outcome.success",
                    "signature": "def doCleanups(self): &#34;&#34;&#34;Execute all cleanup functions. Normally called for you after tearDown.&#34;&#34;&#34; outcome = self._outcome or _Outcome() while self._cleanups: function, args, kwargs = self._cleanups.pop() with outcome.testPartExecutor(self): self._callCleanup(function, *args, **kwargs)  # return this for backwards compatibility # even though we no longer use it internally return outcome.success"
                }
            },
            {
                "id": 218,
                "attributes": {
                    "id": 218.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.doClassCleanups",
                    "type": "function",
                    "code": "def doClassCleanups(cls): &#34;&#34;&#34;Execute all class cleanup functions. Normally called for you after tearDownClass.&#34;&#34;&#34; cls.tearDown_exceptions = [] while cls._class_cleanups: function, args, kwargs = cls._class_cleanups.pop() try: function(*args, **kwargs) except Exception: cls.tearDown_exceptions.append(sys.exc_info())",
                    "signature": "def doClassCleanups(cls): &#34;&#34;&#34;Execute all class cleanup functions. Normally called for you after tearDownClass.&#34;&#34;&#34; cls.tearDown_exceptions = [] while cls._class_cleanups: function, args, kwargs = cls._class_cleanups.pop() try: function(*args, **kwargs) except Exception: cls.tearDown_exceptions.append(sys.exc_info())"
                }
            },
            {
                "id": 219,
                "attributes": {
                    "id": 219.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.__call__",
                    "type": "function",
                    "code": "def __call__(self, *args, **kwds): return self.run(*args, **kwds)",
                    "signature": "def __call__(self, *args, **kwds): return self.run(*args, **kwds)"
                }
            },
            {
                "id": 220,
                "attributes": {
                    "id": 220.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.debug",
                    "type": "function",
                    "code": "def debug(self): &#34;&#34;&#34;Run the test without collecting errors in a TestResult&#34;&#34;&#34; self.setUp() getattr(self, self._testMethodName)() self.tearDown() while self._cleanups: function, args, kwargs = self._cleanups.pop(-1) function(*args, **kwargs)",
                    "signature": "def debug(self): &#34;&#34;&#34;Run the test without collecting errors in a TestResult&#34;&#34;&#34; self.setUp() getattr(self, self._testMethodName)() self.tearDown() while self._cleanups: function, args, kwargs = self._cleanups.pop(-1) function(*args, **kwargs)"
                }
            },
            {
                "id": 222,
                "attributes": {
                    "id": 222.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.fail",
                    "type": "function",
                    "code": "def fail(self, msg=None): &#34;&#34;&#34;Fail immediately, with the given message.&#34;&#34;&#34; raise self.failureException(msg)",
                    "signature": "def fail(self, msg=None): &#34;&#34;&#34;Fail immediately, with the given message.&#34;&#34;&#34; raise self.failureException(msg)"
                }
            },
            {
                "id": 225,
                "attributes": {
                    "id": 225.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._formatMessage",
                    "type": "function",
                    "code": "def _formatMessage(self, msg, standardMsg): &#34;&#34;&#34;Honour the longMessage attribute when generating failure messages. If longMessage is False this means: * Use only an explicit message if it is provided * Otherwise use the standard message for the assert  If longMessage is True: * Use the standard message * If an explicit message is provided, plus ' : ' and the explicit message &#34;&#34;&#34; if not self.longMessage: return msg or standardMsg if msg is None: return standardMsg try: # don't switch to '{}' formatting in Python 2.X # it changes the way unicode input is handled return &#34;%s : %s&#34; % (standardMsg, msg) except UnicodeDecodeError: return &#34;%s : %s&#34; % (safe_repr(standardMsg), safe_repr(msg))",
                    "signature": "def _formatMessage(self, msg, standardMsg): &#34;&#34;&#34;Honour the longMessage attribute when generating failure messages. If longMessage is False this means: * Use only an explicit message if it is provided * Otherwise use the standard message for the assert  If longMessage is True: * Use the standard message * If an explicit message is provided, plus ' : ' and the explicit message &#34;&#34;&#34; if not self.longMessage: return msg or standardMsg if msg is None: return standardMsg try: # don't switch to '{}' formatting in Python 2.X # it changes the way unicode input is handled return &#34;%s : %s&#34; % (standardMsg, msg) except UnicodeDecodeError: return &#34;%s : %s&#34; % (safe_repr(standardMsg), safe_repr(msg))"
                }
            },
            {
                "id": 229,
                "attributes": {
                    "id": 229.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._getAssertEqualityFunc",
                    "type": "function",
                    "code": "def _getAssertEqualityFunc(self, first, second): &#34;&#34;&#34;Get a detailed comparison function for the types of the two args.  Returns: A callable accepting (first, second, msg=None) that will raise a failure exception if first != second with a useful human readable error message for those types. &#34;&#34;&#34; # # NOTE(gregory.p.smith): I considered isinstance(first, type(second)) # and vice versa.  I opted for the conservative approach in case # subclasses are not intended to be compared in detail to their super # class instances using a type equality func.  This means testing # subtypes won't automagically use the detailed comparison.  Callers # should use their type specific assertSpamEqual method to compare # subclasses if the detailed comparison is desired and appropriate. # See the discussion in http://bugs.python.org/issue2578. # if type(first) is type(second): asserter = self._type_equality_funcs.get(type(first)) if asserter is not None: if isinstance(asserter, str): asserter = getattr(self, asserter) return asserter  return self._baseAssertEqual",
                    "signature": "def _getAssertEqualityFunc(self, first, second): &#34;&#34;&#34;Get a detailed comparison function for the types of the two args.  Returns: A callable accepting (first, second, msg=None) that will raise a failure exception if first != second with a useful human readable error message for those types. &#34;&#34;&#34; # # NOTE(gregory.p.smith): I considered isinstance(first, type(second)) # and vice versa.  I opted for the conservative approach in case # subclasses are not intended to be compared in detail to their super # class instances using a type equality func.  This means testing # subtypes won't automagically use the detailed comparison.  Callers # should use their type specific assertSpamEqual method to compare # subclasses if the detailed comparison is desired and appropriate. # See the discussion in http://bugs.python.org/issue2578. # if type(first) is type(second): asserter = self._type_equality_funcs.get(type(first)) if asserter is not None: if isinstance(asserter, str): asserter = getattr(self, asserter) return asserter  return self._baseAssertEqual"
                }
            },
            {
                "id": 230,
                "attributes": {
                    "id": 230.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._baseAssertEqual",
                    "type": "function",
                    "code": "def _baseAssertEqual(self, first, second, msg=None): &#34;&#34;&#34;The default assertEqual implementation, not type specific.&#34;&#34;&#34; if not first == second: standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(first, second) msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)",
                    "signature": "def _baseAssertEqual(self, first, second, msg=None): &#34;&#34;&#34;The default assertEqual implementation, not type specific.&#34;&#34;&#34; if not first == second: standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(first, second) msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)"
                }
            },
            {
                "id": 232,
                "attributes": {
                    "id": 232.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertNotEqual",
                    "type": "function",
                    "code": "def assertNotEqual(self, first, second, msg=None): &#34;&#34;&#34;Fail if the two objects are equal as determined by the '!=' operator. &#34;&#34;&#34; if not first != second: msg = self._formatMessage( msg, &#34;%s == %s&#34; % (safe_repr(first), safe_repr(second)) ) raise self.failureException(msg)",
                    "signature": "def assertNotEqual(self, first, second, msg=None): &#34;&#34;&#34;Fail if the two objects are equal as determined by the '!=' operator. &#34;&#34;&#34; if not first != second: msg = self._formatMessage( msg, &#34;%s == %s&#34; % (safe_repr(first), safe_repr(second)) ) raise self.failureException(msg)"
                }
            },
            {
                "id": 233,
                "attributes": {
                    "id": 233.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertAlmostEqual",
                    "type": "function",
                    "code": "def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None): &#34;&#34;&#34;Fail if the two objects are unequal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is more than the given delta.  Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit).  If the two objects compare equal then they will automatically compare almost equal. &#34;&#34;&#34; if first == second: # shortcut return if delta is not None and places is not None: raise TypeError(&#34;specify delta or places not both&#34;)  diff = abs(first - second) if delta is not None: if diff <= delta: return  standardMsg = &#34;%s != %s within %s delta (%s difference)&#34; % ( safe_repr(first), safe_repr(second), safe_repr(delta), safe_repr(diff), ) else: if places is None: places = 7  if round(diff, places) == 0: return  standardMsg = &#34;%s != %s within %r places (%s difference)&#34; % ( safe_repr(first), safe_repr(second), places, safe_repr(diff), ) msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)",
                    "signature": "def assertAlmostEqual(self, first, second, places=None, msg=None, delta=None): &#34;&#34;&#34;Fail if the two objects are unequal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is more than the given delta.  Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit).  If the two objects compare equal then they will automatically compare almost equal. &#34;&#34;&#34; if first == second: # shortcut return if delta is not None and places is not None: raise TypeError(&#34;specify delta or places not both&#34;)  diff = abs(first - second) if delta is not None: if diff <= delta: return  standardMsg = &#34;%s != %s within %s delta (%s difference)&#34; % ( safe_repr(first), safe_repr(second), safe_repr(delta), safe_repr(diff), ) else: if places is None: places = 7  if round(diff, places) == 0: return  standardMsg = &#34;%s != %s within %r places (%s difference)&#34; % ( safe_repr(first), safe_repr(second), places, safe_repr(diff), ) msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)"
                }
            },
            {
                "id": 234,
                "attributes": {
                    "id": 234.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertNotAlmostEqual",
                    "type": "function",
                    "code": "def assertNotAlmostEqual(self, first, second, places=None, msg=None, delta=None): &#34;&#34;&#34;Fail if the two objects are equal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is less than the given delta.  Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit).  Objects that are equal automatically fail. &#34;&#34;&#34; if delta is not None and places is not None: raise TypeError(&#34;specify delta or places not both&#34;) diff = abs(first - second) if delta is not None: if not (first == second) and diff > delta: return standardMsg = &#34;%s == %s within %s delta (%s difference)&#34; % ( safe_repr(first), safe_repr(second), safe_repr(delta), safe_repr(diff), ) else: if places is None: places = 7 if not (first == second) and round(diff, places) != 0: return standardMsg = &#34;%s == %s within %r places&#34; % ( safe_repr(first), safe_repr(second), places, )  msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)",
                    "signature": "def assertNotAlmostEqual(self, first, second, places=None, msg=None, delta=None): &#34;&#34;&#34;Fail if the two objects are equal as determined by their difference rounded to the given number of decimal places (default 7) and comparing to zero, or by comparing that the difference between the two objects is less than the given delta.  Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit).  Objects that are equal automatically fail. &#34;&#34;&#34; if delta is not None and places is not None: raise TypeError(&#34;specify delta or places not both&#34;) diff = abs(first - second) if delta is not None: if not (first == second) and diff > delta: return standardMsg = &#34;%s == %s within %s delta (%s difference)&#34; % ( safe_repr(first), safe_repr(second), safe_repr(delta), safe_repr(diff), ) else: if places is None: places = 7 if not (first == second) and round(diff, places) != 0: return standardMsg = &#34;%s == %s within %r places&#34; % ( safe_repr(first), safe_repr(second), places, )  msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)"
                }
            },
            {
                "id": 235,
                "attributes": {
                    "id": 235.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertSequenceEqual",
                    "type": "function",
                    "code": "def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None): &#34;&#34;&#34;An equality assertion for ordered sequences (like lists and tuples).  For the purposes of this function, a valid ordered sequence type is one which can be indexed, has a length, and has an equality operator.  Args: seq1: The first sequence to compare. seq2: The second sequence to compare. seq_type: The expected datatype of the sequences, or None if no datatype should be enforced. msg: Optional message to use on failure instead of a list of differences. &#34;&#34;&#34; if seq_type is not None: seq_type_name = seq_type.__name__ if not isinstance(seq1, seq_type): raise self.failureException( &#34;First sequence is not a %s: %s&#34; % (seq_type_name, safe_repr(seq1)) ) if not isinstance(seq2, seq_type): raise self.failureException( &#34;Second sequence is not a %s: %s&#34; % (seq_type_name, safe_repr(seq2)) ) else: seq_type_name = &#34;sequence&#34;  differing = None try: len1 = len(seq1) except (TypeError, NotImplementedError): differing = &#34;First %s has no length.    Non-sequence?&#34; % (seq_type_name)  if differing is None: try: len2 = len(seq2) except (TypeError, NotImplementedError): differing = &#34;Second %s has no length.    Non-sequence?&#34; % ( seq_type_name )  if differing is None: if seq1 == seq2: return  differing = &#34;%ss differ: %s != %s\\n&#34; % ( (seq_type_name.capitalize(),) + _common_shorten_repr(seq1, seq2) )  for i in range(min(len1, len2)): try: item1 = seq1[i] except (TypeError, IndexError, NotImplementedError): differing += &#34;\\nUnable to index element %d of first %s\\n&#34; % ( i, seq_type_name, ) break  try: item2 = seq2[i] except (TypeError, IndexError, NotImplementedError): differing += &#34;\\nUnable to index element %d of second %s\\n&#34; % ( i, seq_type_name, ) break  if item1 != item2: differing += &#34;\\nFirst differing element %d:\\n%s\\n%s\\n&#34; % ( (i,) + _common_shorten_repr(item1, item2) ) break else: if len1 == len2 and seq_type is None and type(seq1) != type(seq2): # The sequences are the same, but have differing types. return  if len1 > len2: differing += &#34;\\nFirst %s contains %d additional &#34; &#34;elements.\\n&#34; % ( seq_type_name, len1 - len2, ) try: differing += &#34;First extra element %d:\\n%s\\n&#34; % ( len2, safe_repr(seq1[len2]), ) except (TypeError, IndexError, NotImplementedError): differing += &#34;Unable to index element %d &#34; &#34;of first %s\\n&#34; % ( len2, seq_type_name, ) elif len1 < len2: differing += &#34;\\nSecond %s contains %d additional &#34; &#34;elements.\\n&#34; % ( seq_type_name, len2 - len1, ) try: differing += &#34;First extra element %d:\\n%s\\n&#34; % ( len1, safe_repr(seq2[len1]), ) except (TypeError, IndexError, NotImplementedError): differing += &#34;Unable to index element %d &#34; &#34;of second %s\\n&#34; % ( len1, seq_type_name, ) standardMsg = differing diffMsg = &#34;\\n&#34; + &#34;\\n&#34;.join( difflib.ndiff( pprint.pformat(seq1).splitlines(), pprint.pformat(seq2).splitlines() ) )  standardMsg = self._truncateMessage(standardMsg, diffMsg) msg = self._formatMessage(msg, standardMsg) self.fail(msg)",
                    "signature": "def assertSequenceEqual(self, seq1, seq2, msg=None, seq_type=None): &#34;&#34;&#34;An equality assertion for ordered sequences (like lists and tuples).  For the purposes of this function, a valid ordered sequence type is one which can be indexed, has a length, and has an equality operator.  Args: seq1: The first sequence to compare. seq2: The second sequence to compare. seq_type: The expected datatype of the sequences, or None if no datatype should be enforced. msg: Optional message to use on failure instead of a list of differences. &#34;&#34;&#34; if seq_type is not None: seq_type_name = seq_type.__name__ if not isinstance(seq1, seq_type): raise self.failureException( &#34;First sequence is not a %s: %s&#34; % (seq_type_name, safe_repr(seq1)) ) if not isinstance(seq2, seq_type): raise self.failureException( &#34;Second sequence is not a %s: %s&#34; % (seq_type_name, safe_repr(seq2)) ) else: seq_type_name = &#34;sequence&#34;  differing = None try: len1 = len(seq1) except (TypeError, NotImplementedError): differing = &#34;First %s has no length.    Non-sequence?&#34; % (seq_type_name)  if differing is None: try: len2 = len(seq2) except (TypeError, NotImplementedError): differing = &#34;Second %s has no length.    Non-sequence?&#34; % ( seq_type_name )  if differing is None: if seq1 == seq2: return  differing = &#34;%ss differ: %s != %s\\n&#34; % ( (seq_type_name.capitalize(),) + _common_shorten_repr(seq1, seq2) )  for i in range(min(len1, len2)): try: item1 = seq1[i] except (TypeError, IndexError, NotImplementedError): differing += &#34;\\nUnable to index element %d of first %s\\n&#34; % ( i, seq_type_name, ) break  try: item2 = seq2[i] except (TypeError, IndexError, NotImplementedError): differing += &#34;\\nUnable to index element %d of second %s\\n&#34; % ( i, seq_type_name, ) break  if item1 != item2: differing += &#34;\\nFirst differing element %d:\\n%s\\n%s\\n&#34; % ( (i,) + _common_shorten_repr(item1, item2) ) break else: if len1 == len2 and seq_type is None and type(seq1) != type(seq2): # The sequences are the same, but have differing types. return  if len1 > len2: differing += &#34;\\nFirst %s contains %d additional &#34; &#34;elements.\\n&#34; % ( seq_type_name, len1 - len2, ) try: differing += &#34;First extra element %d:\\n%s\\n&#34; % ( len2, safe_repr(seq1[len2]), ) except (TypeError, IndexError, NotImplementedError): differing += &#34;Unable to index element %d &#34; &#34;of first %s\\n&#34; % ( len2, seq_type_name, ) elif len1 < len2: differing += &#34;\\nSecond %s contains %d additional &#34; &#34;elements.\\n&#34; % ( seq_type_name, len2 - len1, ) try: differing += &#34;First extra element %d:\\n%s\\n&#34; % ( len1, safe_repr(seq2[len1]), ) except (TypeError, IndexError, NotImplementedError): differing += &#34;Unable to index element %d &#34; &#34;of second %s\\n&#34; % ( len1, seq_type_name, ) standardMsg = differing diffMsg = &#34;\\n&#34; + &#34;\\n&#34;.join( difflib.ndiff( pprint.pformat(seq1).splitlines(), pprint.pformat(seq2).splitlines() ) )  standardMsg = self._truncateMessage(standardMsg, diffMsg) msg = self._formatMessage(msg, standardMsg) self.fail(msg)"
                }
            },
            {
                "id": 236,
                "attributes": {
                    "id": 236.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._truncateMessage",
                    "type": "function",
                    "code": "def _truncateMessage(self, message, diff): max_diff = self.maxDiff if max_diff is None or len(diff) <= max_diff: return message + diff return message + (DIFF_OMITTED % len(diff))",
                    "signature": "def _truncateMessage(self, message, diff): max_diff = self.maxDiff if max_diff is None or len(diff) <= max_diff: return message + diff return message + (DIFF_OMITTED % len(diff))"
                }
            },
            {
                "id": 237,
                "attributes": {
                    "id": 237.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertListEqual",
                    "type": "function",
                    "code": "def assertListEqual(self, list1, list2, msg=None): &#34;&#34;&#34;A list-specific equality assertion.  Args: list1: The first list to compare. list2: The second list to compare. msg: Optional message to use on failure instead of a list of differences.  &#34;&#34;&#34; self.assertSequenceEqual(list1, list2, msg, seq_type=list)",
                    "signature": "def assertListEqual(self, list1, list2, msg=None): &#34;&#34;&#34;A list-specific equality assertion.  Args: list1: The first list to compare. list2: The second list to compare. msg: Optional message to use on failure instead of a list of differences.  &#34;&#34;&#34; self.assertSequenceEqual(list1, list2, msg, seq_type=list)"
                }
            },
            {
                "id": 238,
                "attributes": {
                    "id": 238.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertTupleEqual",
                    "type": "function",
                    "code": "def assertTupleEqual(self, tuple1, tuple2, msg=None): &#34;&#34;&#34;A tuple-specific equality assertion.  Args: tuple1: The first tuple to compare. tuple2: The second tuple to compare. msg: Optional message to use on failure instead of a list of differences. &#34;&#34;&#34; self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)",
                    "signature": "def assertTupleEqual(self, tuple1, tuple2, msg=None): &#34;&#34;&#34;A tuple-specific equality assertion.  Args: tuple1: The first tuple to compare. tuple2: The second tuple to compare. msg: Optional message to use on failure instead of a list of differences. &#34;&#34;&#34; self.assertSequenceEqual(tuple1, tuple2, msg, seq_type=tuple)"
                }
            },
            {
                "id": 239,
                "attributes": {
                    "id": 239.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertSetEqual",
                    "type": "function",
                    "code": "def assertSetEqual(self, set1, set2, msg=None): &#34;&#34;&#34;A set-specific equality assertion.  Args: set1: The first set to compare. set2: The second set to compare. msg: Optional message to use on failure instead of a list of differences.  assertSetEqual uses ducktyping to support different types of sets, and is optimized for sets specifically (parameters must support a difference method). &#34;&#34;&#34; try: difference1 = set1.difference(set2) except TypeError as e: self.fail(&#34;invalid type when attempting set difference: %s&#34; % e) except AttributeError as e: self.fail(&#34;first argument does not support set difference: %s&#34; % e)  try: difference2 = set2.difference(set1) except TypeError as e: self.fail(&#34;invalid type when attempting set difference: %s&#34; % e) except AttributeError as e: self.fail(&#34;second argument does not support set difference: %s&#34; % e)  if not (difference1 or difference2): return  lines = [] if difference1: lines.append(&#34;Items in the first set but not the second:&#34;) for item in difference1: lines.append(repr(item)) if difference2: lines.append(&#34;Items in the second set but not the first:&#34;) for item in difference2: lines.append(repr(item))  standardMsg = &#34;\\n&#34;.join(lines) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertSetEqual(self, set1, set2, msg=None): &#34;&#34;&#34;A set-specific equality assertion.  Args: set1: The first set to compare. set2: The second set to compare. msg: Optional message to use on failure instead of a list of differences.  assertSetEqual uses ducktyping to support different types of sets, and is optimized for sets specifically (parameters must support a difference method). &#34;&#34;&#34; try: difference1 = set1.difference(set2) except TypeError as e: self.fail(&#34;invalid type when attempting set difference: %s&#34; % e) except AttributeError as e: self.fail(&#34;first argument does not support set difference: %s&#34; % e)  try: difference2 = set2.difference(set1) except TypeError as e: self.fail(&#34;invalid type when attempting set difference: %s&#34; % e) except AttributeError as e: self.fail(&#34;second argument does not support set difference: %s&#34; % e)  if not (difference1 or difference2): return  lines = [] if difference1: lines.append(&#34;Items in the first set but not the second:&#34;) for item in difference1: lines.append(repr(item)) if difference2: lines.append(&#34;Items in the second set but not the first:&#34;) for item in difference2: lines.append(repr(item))  standardMsg = &#34;\\n&#34;.join(lines) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 241,
                "attributes": {
                    "id": 241.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertNotIn",
                    "type": "function",
                    "code": "def assertNotIn(self, member, container, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a not in b), but with a nicer default message.&#34;&#34;&#34; if member in container: standardMsg = &#34;%s unexpectedly found in %s&#34; % ( safe_repr(member), safe_repr(container), ) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertNotIn(self, member, container, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a not in b), but with a nicer default message.&#34;&#34;&#34; if member in container: standardMsg = &#34;%s unexpectedly found in %s&#34; % ( safe_repr(member), safe_repr(container), ) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 242,
                "attributes": {
                    "id": 242.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertIs",
                    "type": "function",
                    "code": "def assertIs(self, expr1, expr2, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a is b), but with a nicer default message.&#34;&#34;&#34; if expr1 is not expr2: standardMsg = &#34;%s is not %s&#34; % (safe_repr(expr1), safe_repr(expr2)) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertIs(self, expr1, expr2, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a is b), but with a nicer default message.&#34;&#34;&#34; if expr1 is not expr2: standardMsg = &#34;%s is not %s&#34; % (safe_repr(expr1), safe_repr(expr2)) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 243,
                "attributes": {
                    "id": 243.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertIsNot",
                    "type": "function",
                    "code": "def assertIsNot(self, expr1, expr2, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a is not b), but with a nicer default message.&#34;&#34;&#34; if expr1 is expr2: standardMsg = &#34;unexpectedly identical: %s&#34; % (safe_repr(expr1),) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertIsNot(self, expr1, expr2, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a is not b), but with a nicer default message.&#34;&#34;&#34; if expr1 is expr2: standardMsg = &#34;unexpectedly identical: %s&#34; % (safe_repr(expr1),) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 244,
                "attributes": {
                    "id": 244.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertDictEqual",
                    "type": "function",
                    "code": "def assertDictEqual(self, d1, d2, msg=None): self.assertIsInstance(d1, dict, &#34;First argument is not a dictionary&#34;) self.assertIsInstance(d2, dict, &#34;Second argument is not a dictionary&#34;)  if d1 != d2: standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(d1, d2) diff = &#34;\\n&#34; + &#34;\\n&#34;.join( difflib.ndiff( pprint.pformat(d1).splitlines(), pprint.pformat(d2).splitlines() ) ) standardMsg = self._truncateMessage(standardMsg, diff) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertDictEqual(self, d1, d2, msg=None): self.assertIsInstance(d1, dict, &#34;First argument is not a dictionary&#34;) self.assertIsInstance(d2, dict, &#34;Second argument is not a dictionary&#34;)  if d1 != d2: standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(d1, d2) diff = &#34;\\n&#34; + &#34;\\n&#34;.join( difflib.ndiff( pprint.pformat(d1).splitlines(), pprint.pformat(d2).splitlines() ) ) standardMsg = self._truncateMessage(standardMsg, diff) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 245,
                "attributes": {
                    "id": 245.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertDictContainsSubset",
                    "type": "function",
                    "code": "def assertDictContainsSubset(self, subset, dictionary, msg=None): &#34;&#34;&#34;Checks whether dictionary is a superset of subset.&#34;&#34;&#34; warnings.warn(&#34;assertDictContainsSubset is deprecated&#34;, DeprecationWarning) missing = [] mismatched = [] for key, value in subset.items(): if key not in dictionary: missing.append(key) elif value != dictionary[key]: mismatched.append( &#34;%s, expected: %s, actual: %s&#34; % (safe_repr(key), safe_repr(value), safe_repr(dictionary[key])) )  if not (missing or mismatched): return  standardMsg = &#34;&#34; if missing: standardMsg = &#34;Missing: %s&#34; % &#34;,&#34;.join(safe_repr(m) for m in missing) if mismatched: if standardMsg: standardMsg += &#34;; &#34; standardMsg += &#34;Mismatched values: %s&#34; % &#34;,&#34;.join(mismatched)  self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertDictContainsSubset(self, subset, dictionary, msg=None): &#34;&#34;&#34;Checks whether dictionary is a superset of subset.&#34;&#34;&#34; warnings.warn(&#34;assertDictContainsSubset is deprecated&#34;, DeprecationWarning) missing = [] mismatched = [] for key, value in subset.items(): if key not in dictionary: missing.append(key) elif value != dictionary[key]: mismatched.append( &#34;%s, expected: %s, actual: %s&#34; % (safe_repr(key), safe_repr(value), safe_repr(dictionary[key])) )  if not (missing or mismatched): return  standardMsg = &#34;&#34; if missing: standardMsg = &#34;Missing: %s&#34; % &#34;,&#34;.join(safe_repr(m) for m in missing) if mismatched: if standardMsg: standardMsg += &#34;; &#34; standardMsg += &#34;Mismatched values: %s&#34; % &#34;,&#34;.join(mismatched)  self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 246,
                "attributes": {
                    "id": 246.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertCountEqual",
                    "type": "function",
                    "code": "def assertCountEqual(self, first, second, msg=None): &#34;&#34;&#34;Asserts that two iterables have the same elements, the same number of times, without regard to order.  self.assertEqual(Counter(list(first)), Counter(list(second)))  Example: - [0, 1, 1] and [1, 0, 1] compare equal. - [0, 0, 1] and [0, 1] compare unequal.  &#34;&#34;&#34; first_seq, second_seq = list(first), list(second) try: first = collections.Counter(first_seq) second = collections.Counter(second_seq) except TypeError: # Handle case with unhashable elements differences = _count_diff_all_purpose(first_seq, second_seq) else: if first == second: return differences = _count_diff_hashable(first_seq, second_seq)  if differences: standardMsg = &#34;Element counts were not equal:\\n&#34; lines = [&#34;First has %d, Second has %d:  %r&#34; % diff for diff in differences] diffMsg = &#34;\\n&#34;.join(lines) standardMsg = self._truncateMessage(standardMsg, diffMsg) msg = self._formatMessage(msg, standardMsg) self.fail(msg)",
                    "signature": "def assertCountEqual(self, first, second, msg=None): &#34;&#34;&#34;Asserts that two iterables have the same elements, the same number of times, without regard to order.  self.assertEqual(Counter(list(first)), Counter(list(second)))  Example: - [0, 1, 1] and [1, 0, 1] compare equal. - [0, 0, 1] and [0, 1] compare unequal.  &#34;&#34;&#34; first_seq, second_seq = list(first), list(second) try: first = collections.Counter(first_seq) second = collections.Counter(second_seq) except TypeError: # Handle case with unhashable elements differences = _count_diff_all_purpose(first_seq, second_seq) else: if first == second: return differences = _count_diff_hashable(first_seq, second_seq)  if differences: standardMsg = &#34;Element counts were not equal:\\n&#34; lines = [&#34;First has %d, Second has %d:  %r&#34; % diff for diff in differences] diffMsg = &#34;\\n&#34;.join(lines) standardMsg = self._truncateMessage(standardMsg, diffMsg) msg = self._formatMessage(msg, standardMsg) self.fail(msg)"
                }
            },
            {
                "id": 247,
                "attributes": {
                    "id": 247.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertMultiLineEqual",
                    "type": "function",
                    "code": "def assertMultiLineEqual(self, first, second, msg=None): &#34;&#34;&#34;Assert that two multi-line strings are equal.&#34;&#34;&#34; self.assertIsInstance(first, str, &#34;First argument is not a string&#34;) self.assertIsInstance(second, str, &#34;Second argument is not a string&#34;)  if first != second: # don't use difflib if the strings are too long if len(first) > self._diffThreshold or len(second) > self._diffThreshold: self._baseAssertEqual(first, second, msg) firstlines = first.splitlines(keepends=True) secondlines = second.splitlines(keepends=True) if len(firstlines) == 1 and first.strip(&#34;\\r\\n&#34;) == first: firstlines = [first + &#34;\\n&#34;] secondlines = [second + &#34;\\n&#34;] standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(first, second) diff = &#34;\\n&#34; + &#34;&#34;.join(difflib.ndiff(firstlines, secondlines)) standardMsg = self._truncateMessage(standardMsg, diff) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertMultiLineEqual(self, first, second, msg=None): &#34;&#34;&#34;Assert that two multi-line strings are equal.&#34;&#34;&#34; self.assertIsInstance(first, str, &#34;First argument is not a string&#34;) self.assertIsInstance(second, str, &#34;Second argument is not a string&#34;)  if first != second: # don't use difflib if the strings are too long if len(first) > self._diffThreshold or len(second) > self._diffThreshold: self._baseAssertEqual(first, second, msg) firstlines = first.splitlines(keepends=True) secondlines = second.splitlines(keepends=True) if len(firstlines) == 1 and first.strip(&#34;\\r\\n&#34;) == first: firstlines = [first + &#34;\\n&#34;] secondlines = [second + &#34;\\n&#34;] standardMsg = &#34;%s != %s&#34; % _common_shorten_repr(first, second) diff = &#34;\\n&#34; + &#34;&#34;.join(difflib.ndiff(firstlines, secondlines)) standardMsg = self._truncateMessage(standardMsg, diff) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 248,
                "attributes": {
                    "id": 248.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertLess",
                    "type": "function",
                    "code": "def assertLess(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a < b), but with a nicer default message.&#34;&#34;&#34; if not a < b: standardMsg = &#34;%s not less than %s&#34; % (safe_repr(a), safe_repr(b)) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertLess(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a < b), but with a nicer default message.&#34;&#34;&#34; if not a < b: standardMsg = &#34;%s not less than %s&#34; % (safe_repr(a), safe_repr(b)) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 249,
                "attributes": {
                    "id": 249.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertLessEqual",
                    "type": "function",
                    "code": "def assertLessEqual(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a <= b), but with a nicer default message.&#34;&#34;&#34; if not a <= b: standardMsg = &#34;%s not less than or equal to %s&#34; % ( safe_repr(a), safe_repr(b), ) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertLessEqual(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a <= b), but with a nicer default message.&#34;&#34;&#34; if not a <= b: standardMsg = &#34;%s not less than or equal to %s&#34; % ( safe_repr(a), safe_repr(b), ) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 250,
                "attributes": {
                    "id": 250.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertGreater",
                    "type": "function",
                    "code": "def assertGreater(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a > b), but with a nicer default message.&#34;&#34;&#34; if not a > b: standardMsg = &#34;%s not greater than %s&#34; % (safe_repr(a), safe_repr(b)) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertGreater(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a > b), but with a nicer default message.&#34;&#34;&#34; if not a > b: standardMsg = &#34;%s not greater than %s&#34; % (safe_repr(a), safe_repr(b)) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 251,
                "attributes": {
                    "id": 251.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertGreaterEqual",
                    "type": "function",
                    "code": "def assertGreaterEqual(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a >= b), but with a nicer default message.&#34;&#34;&#34; if not a >= b: standardMsg = &#34;%s not greater than or equal to %s&#34; % ( safe_repr(a), safe_repr(b), ) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertGreaterEqual(self, a, b, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a >= b), but with a nicer default message.&#34;&#34;&#34; if not a >= b: standardMsg = &#34;%s not greater than or equal to %s&#34; % ( safe_repr(a), safe_repr(b), ) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 252,
                "attributes": {
                    "id": 252.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertIsNone",
                    "type": "function",
                    "code": "def assertIsNone(self, obj, msg=None): &#34;&#34;&#34;Same as self.assertTrue(obj is None), with a nicer default message.&#34;&#34;&#34; if obj is not None: standardMsg = &#34;%s is not None&#34; % (safe_repr(obj),) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertIsNone(self, obj, msg=None): &#34;&#34;&#34;Same as self.assertTrue(obj is None), with a nicer default message.&#34;&#34;&#34; if obj is not None: standardMsg = &#34;%s is not None&#34; % (safe_repr(obj),) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 253,
                "attributes": {
                    "id": 253.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertIsNotNone",
                    "type": "function",
                    "code": "def assertIsNotNone(self, obj, msg=None): &#34;&#34;&#34;Included for symmetry with assertIsNone.&#34;&#34;&#34; if obj is None: standardMsg = &#34;unexpectedly None&#34; self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertIsNotNone(self, obj, msg=None): &#34;&#34;&#34;Included for symmetry with assertIsNone.&#34;&#34;&#34; if obj is None: standardMsg = &#34;unexpectedly None&#34; self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 255,
                "attributes": {
                    "id": 255.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertNotIsInstance",
                    "type": "function",
                    "code": "def assertNotIsInstance(self, obj, cls, msg=None): &#34;&#34;&#34;Included for symmetry with assertIsInstance.&#34;&#34;&#34; if isinstance(obj, cls): standardMsg = &#34;%s is an instance of %r&#34; % (safe_repr(obj), cls) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertNotIsInstance(self, obj, cls, msg=None): &#34;&#34;&#34;Included for symmetry with assertIsInstance.&#34;&#34;&#34; if isinstance(obj, cls): standardMsg = &#34;%s is an instance of %r&#34; % (safe_repr(obj), cls) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 258,
                "attributes": {
                    "id": 258.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertRegex",
                    "type": "function",
                    "code": "def assertRegex(self, text, expected_regex, msg=None): &#34;&#34;&#34;Fail the test unless the text matches the regular expression.&#34;&#34;&#34; if isinstance(expected_regex, (str, bytes)): assert expected_regex, &#34;expected_regex must not be empty.&#34; expected_regex = re.compile(expected_regex) if not expected_regex.search(text): standardMsg = &#34;Regex didn't match: %r not found in %r&#34; % ( expected_regex.pattern, text, ) # _formatMessage ensures the longMessage option is respected msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)",
                    "signature": "def assertRegex(self, text, expected_regex, msg=None): &#34;&#34;&#34;Fail the test unless the text matches the regular expression.&#34;&#34;&#34; if isinstance(expected_regex, (str, bytes)): assert expected_regex, &#34;expected_regex must not be empty.&#34; expected_regex = re.compile(expected_regex) if not expected_regex.search(text): standardMsg = &#34;Regex didn't match: %r not found in %r&#34; % ( expected_regex.pattern, text, ) # _formatMessage ensures the longMessage option is respected msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)"
                }
            },
            {
                "id": 259,
                "attributes": {
                    "id": 259.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertNotRegex",
                    "type": "function",
                    "code": "def assertNotRegex(self, text, unexpected_regex, msg=None): &#34;&#34;&#34;Fail the test if the text matches the regular expression.&#34;&#34;&#34; if isinstance(unexpected_regex, (str, bytes)): unexpected_regex = re.compile(unexpected_regex) match = unexpected_regex.search(text) if match: standardMsg = &#34;Regex matched: %r matches %r in %r&#34; % ( text[match.start() : match.end()], unexpected_regex.pattern, text, ) # _formatMessage ensures the longMessage option is respected msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)",
                    "signature": "def assertNotRegex(self, text, unexpected_regex, msg=None): &#34;&#34;&#34;Fail the test if the text matches the regular expression.&#34;&#34;&#34; if isinstance(unexpected_regex, (str, bytes)): unexpected_regex = re.compile(unexpected_regex) match = unexpected_regex.search(text) if match: standardMsg = &#34;Regex matched: %r matches %r in %r&#34; % ( text[match.start() : match.end()], unexpected_regex.pattern, text, ) # _formatMessage ensures the longMessage option is respected msg = self._formatMessage(msg, standardMsg) raise self.failureException(msg)"
                }
            },
            {
                "id": 260,
                "attributes": {
                    "id": 260.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._deprecate",
                    "type": "function",
                    "code": "def _deprecate(original_func): def deprecated_func(*args, **kwargs): warnings.warn( &#34;Please use {0} instead.&#34;.format(original_func.__name__), DeprecationWarning, 2, ) return original_func(*args, **kwargs)  return deprecated_func",
                    "signature": "def _deprecate(original_func): def deprecated_func(*args, **kwargs): warnings.warn( &#34;Please use {0} instead.&#34;.format(original_func.__name__), DeprecationWarning, 2, ) return original_func(*args, **kwargs)  return deprecated_func"
                }
            },
            {
                "id": 261,
                "attributes": {
                    "id": 261.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase._deprecate.deprecated_func",
                    "type": "function",
                    "code": "def deprecated_func(*args, **kwargs): warnings.warn( &#34;Please use {0} instead.&#34;.format(original_func.__name__), DeprecationWarning, 2, ) return original_func(*args, **kwargs)",
                    "signature": "def deprecated_func(*args, **kwargs): warnings.warn( &#34;Please use {0} instead.&#34;.format(original_func.__name__), DeprecationWarning, 2, ) return original_func(*args, **kwargs)"
                }
            }
        ]
    },
    "1": {
        "nodes": [
            {
                "id": 45,
                "attributes": {
                    "id": 45.0,
                    "label": "hl7.hl7.exceptions.ParseException",
                    "type": "class",
                    "code": "class ParseException(HL7Exception): pass",
                    "signature": "class ParseException(HL7Exception): pass"
                }
            },
            {
                "id": 48,
                "attributes": {
                    "id": 48.0,
                    "label": "hl7.hl7.parser.parse",
                    "type": "function",
                    "code": "def parse(lines, encoding=&#34;utf-8&#34;, factory=Factory): &#34;&#34;&#34;Returns a instance of the :py:class:`hl7.Message` that allows indexed access to the data elements.  A custom :py:class:`hl7.Factory` subclass can be passed in to be used when constructing the message and it's components.  .. note::  HL7 usually contains only ASCII, but can use other character sets (HL7 Standards Document, Section 1.7.1), however as of v2.8, UTF-8 is the preferred character set [#]_.  python-hl7 works on Python unicode strings. :py:func:`hl7.parse` will accept unicode string or will attempt to convert bytestrings into unicode strings using the optional ``encoding`` parameter. ``encoding`` defaults to UTF-8, so no work is needed for bytestrings in UTF-8, but for other character sets like 'cp1252' or 'latin1', ``encoding`` must be set appropriately.  >>> h = hl7.parse(message)  To decode a non-UTF-8 byte string::  hl7.parse(message, encoding='latin1')  :rtype: :py:class:`hl7.Message`  .. [#] http://wiki.hl7.org/index.php?title=Character_Set_used_in_v2_messages  &#34;&#34;&#34; # Ensure we are working with unicode data, decode the bytestring # if needed if isinstance(lines, bytes): lines = lines.decode(encoding) # Strip out unnecessary whitespace strmsg = lines.strip() # The method for parsing the message plan = create_parse_plan(strmsg, factory) # Start splitting the methods based upon the ParsePlan return _split(strmsg, plan)",
                    "signature": "def parse(lines, encoding=&#34;utf-8&#34;, factory=Factory): &#34;&#34;&#34;Returns a instance of the :py:class:`hl7.Message` that allows indexed access to the data elements.  A custom :py:class:`hl7.Factory` subclass can be passed in to be used when constructing the message and it's components.  .. note::  HL7 usually contains only ASCII, but can use other character sets (HL7 Standards Document, Section 1.7.1), however as of v2.8, UTF-8 is the preferred character set [#]_.  python-hl7 works on Python unicode strings. :py:func:`hl7.parse` will accept unicode string or will attempt to convert bytestrings into unicode strings using the optional ``encoding`` parameter. ``encoding`` defaults to UTF-8, so no work is needed for bytestrings in UTF-8, but for other character sets like 'cp1252' or 'latin1', ``encoding`` must be set appropriately.  >>> h = hl7.parse(message)  To decode a non-UTF-8 byte string::  hl7.parse(message, encoding='latin1')  :rtype: :py:class:`hl7.Message`  .. [#] http://wiki.hl7.org/index.php?title=Character_Set_used_in_v2_messages  &#34;&#34;&#34; # Ensure we are working with unicode data, decode the bytestring # if needed if isinstance(lines, bytes): lines = lines.decode(encoding) # Strip out unnecessary whitespace strmsg = lines.strip() # The method for parsing the message plan = create_parse_plan(strmsg, factory) # Start splitting the methods based upon the ParsePlan return _split(strmsg, plan)"
                }
            },
            {
                "id": 50,
                "attributes": {
                    "id": 50.0,
                    "label": "hl7.hl7.parser.parse_batch",
                    "type": "function",
                    "code": "def parse_batch(lines, encoding=&#34;utf-8&#34;, factory=Factory): &#34;&#34;&#34;Returns a instance of a :py:class:`hl7.Batch` that allows indexed access to the messages.  A custom :py:class:`hl7.Factory` subclass can be passed in to be used when constructing the batch and it's components.  .. note::  HL7 usually contains only ASCII, but can use other character sets (HL7 Standards Document, Section 1.7.1), however as of v2.8, UTF-8 is the preferred character set [#]_.  python-hl7 works on Python unicode strings. :py:func:`hl7.parse_batch` will accept unicode string or will attempt to convert bytestrings into unicode strings using the optional ``encoding`` parameter. ``encoding`` defaults to UTF-8, so no work is needed for bytestrings in UTF-8, but for other character sets like 'cp1252' or 'latin1', ``encoding`` must be set appropriately.  >>> h = hl7.parse_batch(message)  To decode a non-UTF-8 byte string::  hl7.parse_batch(message, encoding='latin1')  :rtype: :py:class:`hl7.Batch`  .. [#] http://wiki.hl7.org/index.php?title=Character_Set_used_in_v2_messages  &#34;&#34;&#34; # Ensure we are working with unicode data, decode the bytestring # if needed if isinstance(lines, bytes): lines = lines.decode(encoding) batch = None messages = [] # Split the batch into lines, retaining the ends for line in lines.strip(_HL7_WHITESPACE).splitlines(keepends=True): # strip out all whitespace MINUS the '\\r' line = line.strip(_HL7_WHITESPACE) if line[:3] == &#34;BHS&#34;: if batch: raise ParseException(&#34;Batch cannot have more than one BHS segment&#34;) batch = line elif line[:3] == &#34;BTS&#34;: if not batch or &#34;\\rBTS&#34; in batch: continue batch += line elif line[:3] == &#34;MSH&#34;: messages.append(line) else: if not messages: raise ParseException( &#34;Segment received before message header {}&#34;.format(line) ) messages[-1] += line return _create_batch(batch, messages, encoding, factory)",
                    "signature": "def parse_batch(lines, encoding=&#34;utf-8&#34;, factory=Factory): &#34;&#34;&#34;Returns a instance of a :py:class:`hl7.Batch` that allows indexed access to the messages.  A custom :py:class:`hl7.Factory` subclass can be passed in to be used when constructing the batch and it's components.  .. note::  HL7 usually contains only ASCII, but can use other character sets (HL7 Standards Document, Section 1.7.1), however as of v2.8, UTF-8 is the preferred character set [#]_.  python-hl7 works on Python unicode strings. :py:func:`hl7.parse_batch` will accept unicode string or will attempt to convert bytestrings into unicode strings using the optional ``encoding`` parameter. ``encoding`` defaults to UTF-8, so no work is needed for bytestrings in UTF-8, but for other character sets like 'cp1252' or 'latin1', ``encoding`` must be set appropriately.  >>> h = hl7.parse_batch(message)  To decode a non-UTF-8 byte string::  hl7.parse_batch(message, encoding='latin1')  :rtype: :py:class:`hl7.Batch`  .. [#] http://wiki.hl7.org/index.php?title=Character_Set_used_in_v2_messages  &#34;&#34;&#34; # Ensure we are working with unicode data, decode the bytestring # if needed if isinstance(lines, bytes): lines = lines.decode(encoding) batch = None messages = [] # Split the batch into lines, retaining the ends for line in lines.strip(_HL7_WHITESPACE).splitlines(keepends=True): # strip out all whitespace MINUS the '\\r' line = line.strip(_HL7_WHITESPACE) if line[:3] == &#34;BHS&#34;: if batch: raise ParseException(&#34;Batch cannot have more than one BHS segment&#34;) batch = line elif line[:3] == &#34;BTS&#34;: if not batch or &#34;\\rBTS&#34; in batch: continue batch += line elif line[:3] == &#34;MSH&#34;: messages.append(line) else: if not messages: raise ParseException( &#34;Segment received before message header {}&#34;.format(line) ) messages[-1] += line return _create_batch(batch, messages, encoding, factory)"
                }
            },
            {
                "id": 52,
                "attributes": {
                    "id": 52.0,
                    "label": "hl7.hl7.parser.parse_file",
                    "type": "function",
                    "code": "def parse_file(lines, encoding=&#34;utf-8&#34;, factory=Factory):  # noqa: C901 &#34;&#34;&#34;Returns a instance of the :py:class:`hl7.File` that allows indexed access to the batches.  A custom :py:class:`hl7.Factory` subclass can be passed in to be used when constructing the file and it's components.  .. note::  HL7 usually contains only ASCII, but can use other character sets (HL7 Standards Document, Section 1.7.1), however as of v2.8, UTF-8 is the preferred character set [#]_.  python-hl7 works on Python unicode strings. :py:func:`hl7.parse_file` will accept unicode string or will attempt to convert bytestrings into unicode strings using the optional ``encoding`` parameter. ``encoding`` defaults to UTF-8, so no work is needed for bytestrings in UTF-8, but for other character sets like 'cp1252' or 'latin1', ``encoding`` must be set appropriately.  >>> h = hl7.parse_file(message)  To decode a non-UTF-8 byte string::  hl7.parse_file(message, encoding='latin1')  :rtype: :py:class:`hl7.File`  .. [#] http://wiki.hl7.org/index.php?title=Character_Set_used_in_v2_messages  &#34;&#34;&#34; # Ensure we are working with unicode data, decode the bytestring # if needed if isinstance(lines, bytes): lines = lines.decode(encoding) file = None batches = [] messages = [] in_batch = False # Split the file into lines, retaining the ends for line in lines.strip(_HL7_WHITESPACE).splitlines(keepends=True): # strip out all whitespace MINUS the '\\r' line = line.strip(_HL7_WHITESPACE) if line[:3] == &#34;FHS&#34;: if file: raise ParseException(&#34;File cannot have more than one FHS segment&#34;) file = line elif line[:3] == &#34;FTS&#34;: if not file or &#34;\\rFTS&#34; in file: continue file += line elif line[:3] == &#34;BHS&#34;: if in_batch: raise ParseException(&#34;Batch cannot have more than one BHS segment&#34;) batches.append([line, []]) in_batch = True elif line[:3] == &#34;BTS&#34;: if not in_batch: continue batches[-1][0] += line in_batch = False elif line[:3] == &#34;MSH&#34;: if in_batch: batches[-1][1].append(line) else:  # Messages outside of a batch go into the &#34;default&#34; batch messages.append(line) else: if in_batch: if not batches[-1][1]: raise ParseException( &#34;Segment received before message header {}&#34;.format(line) ) batches[-1][1][-1] += line else: if not messages: raise ParseException( &#34;Segment received before message header {}&#34;.format(line) ) messages[-1] += line if messages:  # add the default batch, if we have one batches.append([None, messages]) return _create_file(file, batches, encoding, factory)",
                    "signature": "def parse_file(lines, encoding=&#34;utf-8&#34;, factory=Factory):  # noqa: C901 &#34;&#34;&#34;Returns a instance of the :py:class:`hl7.File` that allows indexed access to the batches.  A custom :py:class:`hl7.Factory` subclass can be passed in to be used when constructing the file and it's components.  .. note::  HL7 usually contains only ASCII, but can use other character sets (HL7 Standards Document, Section 1.7.1), however as of v2.8, UTF-8 is the preferred character set [#]_.  python-hl7 works on Python unicode strings. :py:func:`hl7.parse_file` will accept unicode string or will attempt to convert bytestrings into unicode strings using the optional ``encoding`` parameter. ``encoding`` defaults to UTF-8, so no work is needed for bytestrings in UTF-8, but for other character sets like 'cp1252' or 'latin1', ``encoding`` must be set appropriately.  >>> h = hl7.parse_file(message)  To decode a non-UTF-8 byte string::  hl7.parse_file(message, encoding='latin1')  :rtype: :py:class:`hl7.File`  .. [#] http://wiki.hl7.org/index.php?title=Character_Set_used_in_v2_messages  &#34;&#34;&#34; # Ensure we are working with unicode data, decode the bytestring # if needed if isinstance(lines, bytes): lines = lines.decode(encoding) file = None batches = [] messages = [] in_batch = False # Split the file into lines, retaining the ends for line in lines.strip(_HL7_WHITESPACE).splitlines(keepends=True): # strip out all whitespace MINUS the '\\r' line = line.strip(_HL7_WHITESPACE) if line[:3] == &#34;FHS&#34;: if file: raise ParseException(&#34;File cannot have more than one FHS segment&#34;) file = line elif line[:3] == &#34;FTS&#34;: if not file or &#34;\\rFTS&#34; in file: continue file += line elif line[:3] == &#34;BHS&#34;: if in_batch: raise ParseException(&#34;Batch cannot have more than one BHS segment&#34;) batches.append([line, []]) in_batch = True elif line[:3] == &#34;BTS&#34;: if not in_batch: continue batches[-1][0] += line in_batch = False elif line[:3] == &#34;MSH&#34;: if in_batch: batches[-1][1].append(line) else:  # Messages outside of a batch go into the &#34;default&#34; batch messages.append(line) else: if in_batch: if not batches[-1][1]: raise ParseException( &#34;Segment received before message header {}&#34;.format(line) ) batches[-1][1][-1] += line else: if not messages: raise ParseException( &#34;Segment received before message header {}&#34;.format(line) ) messages[-1] += line if messages:  # add the default batch, if we have one batches.append([None, messages]) return _create_file(file, batches, encoding, factory)"
                }
            },
            {
                "id": 226,
                "attributes": {
                    "id": 226.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertRaises",
                    "type": "function",
                    "code": "def assertRaises(self, expected_exception, *args, **kwargs): &#34;&#34;&#34;Fail unless an exception of class expected_exception is raised by the callable when invoked with specified positional and keyword arguments. If a different type of exception is raised, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.  If called with the callable and arguments omitted, will return a context object used like this::  with self.assertRaises(SomeException): do_something()  An optional keyword argument 'msg' can be provided when assertRaises is used as a context object.  The context manager keeps a reference to the exception as the 'exception' attribute. This allows you to inspect the exception after the assertion::  with self.assertRaises(SomeException) as cm: do_something() the_exception = cm.exception self.assertEqual(the_exception.error_code, 3) &#34;&#34;&#34; context = _AssertRaisesContext(expected_exception, self) try: return context.handle(&#34;assertRaises&#34;, args, kwargs) finally: # bpo-23890: manually break a reference cycle context = None",
                    "signature": "def assertRaises(self, expected_exception, *args, **kwargs): &#34;&#34;&#34;Fail unless an exception of class expected_exception is raised by the callable when invoked with specified positional and keyword arguments. If a different type of exception is raised, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.  If called with the callable and arguments omitted, will return a context object used like this::  with self.assertRaises(SomeException): do_something()  An optional keyword argument 'msg' can be provided when assertRaises is used as a context object.  The context manager keeps a reference to the exception as the 'exception' attribute. This allows you to inspect the exception after the assertion::  with self.assertRaises(SomeException) as cm: do_something() the_exception = cm.exception self.assertEqual(the_exception.error_code, 3) &#34;&#34;&#34; context = _AssertRaisesContext(expected_exception, self) try: return context.handle(&#34;assertRaises&#34;, args, kwargs) finally: # bpo-23890: manually break a reference cycle context = None"
                }
            },
            {
                "id": 231,
                "attributes": {
                    "id": 231.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertEqual",
                    "type": "function",
                    "code": "def assertEqual(self, first, second, msg=None): &#34;&#34;&#34;Fail if the two objects are unequal as determined by the '==' operator. &#34;&#34;&#34; assertion_func = self._getAssertEqualityFunc(first, second) assertion_func(first, second, msg=msg)",
                    "signature": "def assertEqual(self, first, second, msg=None): &#34;&#34;&#34;Fail if the two objects are unequal as determined by the '==' operator. &#34;&#34;&#34; assertion_func = self._getAssertEqualityFunc(first, second) assertion_func(first, second, msg=msg)"
                }
            },
            {
                "id": 240,
                "attributes": {
                    "id": 240.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertIn",
                    "type": "function",
                    "code": "def assertIn(self, member, container, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a in b), but with a nicer default message.&#34;&#34;&#34; if member not in container: standardMsg = &#34;%s not found in %s&#34; % ( safe_repr(member), safe_repr(container), ) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertIn(self, member, container, msg=None): &#34;&#34;&#34;Just like self.assertTrue(a in b), but with a nicer default message.&#34;&#34;&#34; if member not in container: standardMsg = &#34;%s not found in %s&#34; % ( safe_repr(member), safe_repr(container), ) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 254,
                "attributes": {
                    "id": 254.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertIsInstance",
                    "type": "function",
                    "code": "def assertIsInstance(self, obj, cls, msg=None): &#34;&#34;&#34;Same as self.assertTrue(isinstance(obj, cls)), with a nicer default message.&#34;&#34;&#34; if not isinstance(obj, cls): standardMsg = &#34;%s is not an instance of %r&#34; % (safe_repr(obj), cls) self.fail(self._formatMessage(msg, standardMsg))",
                    "signature": "def assertIsInstance(self, obj, cls, msg=None): &#34;&#34;&#34;Same as self.assertTrue(isinstance(obj, cls)), with a nicer default message.&#34;&#34;&#34; if not isinstance(obj, cls): standardMsg = &#34;%s is not an instance of %r&#34; % (safe_repr(obj), cls) self.fail(self._formatMessage(msg, standardMsg))"
                }
            },
            {
                "id": 349,
                "attributes": {
                    "id": 349.0,
                    "label": "hl7.tests.test_mllp.HL7StreamReaderTest.test_readblock",
                    "type": "function",
                    "code": "async def test_readblock(self): message = r&#34;MSH|^~\\&#38;|LABADT|DH|EPICADT|DH|201301011228||ACK^A01^ACK|HL7ACK00001|P|2.3\\r&#34; message += &#34;MSA|AA|HL7MSG00001\\r&#34; self.reader.feed_data( START_BLOCK + message.encode() + END_BLOCK + CARRIAGE_RETURN ) hl7_message = await self.reader.readmessage() self.assertEqual(str(hl7_message), str(hl7.parse(message)))",
                    "signature": "async def test_readblock(self): message = r&#34;MSH|^~\\&#38;|LABADT|DH|EPICADT|DH|201301011228||ACK^A01^ACK|HL7ACK00001|P|2.3\\r&#34; message += &#34;MSA|AA|HL7MSG00001\\r&#34; self.reader.feed_data( START_BLOCK + message.encode() + END_BLOCK + CARRIAGE_RETURN ) hl7_message = await self.reader.readmessage() self.assertEqual(str(hl7_message), str(hl7.parse(message)))"
                }
            },
            {
                "id": 351,
                "attributes": {
                    "id": 351.0,
                    "label": "hl7.tests.test_parse.ParseTest",
                    "type": "class",
                    "code": "class ParseTest(TestCase): def test_parse(self): msg = hl7.parse(sample_hl7) self.assertEqual(len(msg), 5) self.assertIsInstance(msg[0][0][0], str) self.assertEqual(msg[0][0][0], &#34;MSH&#34;) self.assertEqual(msg[3][0][0], &#34;OBX&#34;) self.assertEqual( msg[3][3], [[[&#34;1554-5&#34;], [&#34;GLUCOSE&#34;], [&#34;POST 12H CFST:MCNC:PT:SER/PLAS:QN&#34;]]], ) # Make sure MSH-1 and MSH-2 are valid self.assertEqual(msg[0][1][0], &#34;|&#34;) self.assertIsInstance(msg[0][1], hl7.Field) self.assertEqual(msg[0][2][0], r&#34;^~\\&#38;&#34;) self.assertIsInstance(msg[0][2], hl7.Field) # MSH-9 is the message type self.assertEqual(msg[0][9], [[[&#34;ORU&#34;], [&#34;R01&#34;]]]) # Do it twice to make sure text coercion is idempotent self.assertEqual(str(msg), sample_hl7) self.assertEqual(str(msg), sample_hl7)  def test_parse_batch(self): batch = hl7.parse_batch(sample_batch) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;) self.assertEqual(batch.trailer[1][0], &#34;1&#34;)  def test_parse_batch1(self): batch = hl7.parse_batch(sample_batch1) self.assertEqual(len(batch), 2) self.assertIsInstance(batch[0], hl7.Message) self.assertEqual(batch[0][0][10][0], &#34;12334456778890&#34;) self.assertIsInstance(batch[1], hl7.Message) self.assertEqual(batch[1][0][10][0], &#34;12334456778891&#34;) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;) self.assertEqual(batch.trailer[1][0], &#34;2&#34;)  def test_parse_batch2(self): batch = hl7.parse_batch(sample_batch2) self.assertEqual(len(batch), 2) self.assertIsInstance(batch[0], hl7.Message) self.assertEqual(batch[0][0][10][0], &#34;12334456778890&#34;) self.assertIsInstance(batch[1], hl7.Message) self.assertEqual(batch[1][0][10][0], &#34;12334456778891&#34;) self.assertFalse(batch.header) self.assertFalse(batch.trailer)  def test_parse_batch3(self): batch = hl7.parse_batch(sample_batch3) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;)  def test_parse_batch4(self): batch = hl7.parse_batch(sample_batch4) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsNone(batch.header) self.assertIsNone(batch.trailer)  def test_parse_bad_batch(self): with self.assertRaises(ParseException) as cm: hl7.parse_batch(sample_bad_batch) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])  def test_parse_bad_batch1(self): with self.assertRaises(ParseException) as cm: hl7.parse_batch(sample_bad_batch1) self.assertIn( &#34;Batch cannot have more than one BHS segment&#34;, cm.exception.args[0] )  def test_parse_file(self): file = hl7.parse_file(sample_file) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)  def test_parse_file1(self): file = hl7.parse_file(sample_file1) self.assertEqual(len(file), 2) self.assertIsInstance(file[0], hl7.Batch) self.assertEqual(file[0].trailer[1][0], &#34;2&#34;) self.assertIsInstance(file[1], hl7.Batch) self.assertEqual(file[1].trailer[1][0], &#34;1&#34;) self.assertNotEqual(file[0], file[1]) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;2&#34;)  def test_parse_file2(self): file = hl7.parse_file(sample_file2) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)  def test_parse_file3(self): file = hl7.parse_file(sample_file3) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;)  def test_parse_file4(self): file = hl7.parse_file(sample_file4) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsNone(file.header) self.assertIsNone(file.trailer)  def test_parse_file5(self): file = hl7.parse_file(sample_file5) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)  def test_parse_file6(self): file = hl7.parse_file(sample_file6) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)  def test_parse_bad_file(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])  def test_parse_bad_file1(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file1) self.assertIn( &#34;Batch cannot have more than one BHS segment&#34;, cm.exception.args[0] )  def test_parse_bad_file2(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file2) self.assertIn( &#34;File cannot have more than one FHS segment&#34;, cm.exception.args[0] )  def test_parse_bad_file3(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file3) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])  def test_parse_hl7(self): obj = hl7.parse_hl7(sample_hl7) self.assertIsInstance(obj, hl7.Message) obj = hl7.parse_hl7(sample_batch) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_batch1) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_batch2) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_file) self.assertIsInstance(obj, hl7.File) obj = hl7.parse_hl7(sample_file1) self.assertIsInstance(obj, hl7.File) obj = hl7.parse_hl7(sample_file2) self.assertIsInstance(obj, hl7.File)  def test_bytestring_converted_to_unicode(self): msg = hl7.parse(str(sample_hl7)) self.assertEqual(len(msg), 5) self.assertIsInstance(msg[0][0][0], str) self.assertEqual(msg[0][0][0], &#34;MSH&#34;)  def test_non_ascii_bytestring(self): # \\x96 - valid cp1252, not valid utf8 # it is the responsibility of the caller to convert to unicode msg = hl7.parse(b&#34;MSH|^~\\\\&#38;|GHH LAB|ELAB\\x963&#34;, encoding=&#34;cp1252&#34;) self.assertEqual(msg[0][4][0], &#34;ELAB\\u20133&#34;)  def test_non_ascii_bytestring_no_encoding(self): # \\x96 - valid cp1252, not valid utf8 # it is the responsibility of the caller to convert to unicode self.assertRaises(UnicodeDecodeError, hl7.parse, b&#34;MSH|^~\\\\&#38;|GHH LAB|ELAB\\x963&#34;)  def test_parsing_classes(self): msg = hl7.parse(sample_hl7)  self.assertIsInstance(msg, hl7.Message) self.assertIsInstance(msg[3], hl7.Segment) self.assertIsInstance(msg[3][0], hl7.Field) self.assertIsInstance(msg[3][0][0], str)  def test_nonstandard_separators(self): nonstd = &#34;MSH$%~\\\\&#38;$GHH LAB\\rPID$$$555-44-4444$$EVERYWOMAN%EVE%E%%%L\\r&#34; msg = hl7.parse(nonstd)  self.assertEqual(str(msg), nonstd) self.assertEqual(len(msg), 2) self.assertEqual( msg[1][5], [[[&#34;EVERYWOMAN&#34;], [&#34;EVE&#34;], [&#34;E&#34;], [&#34;&#34;], [&#34;&#34;], [&#34;L&#34;]]] )  def test_repetition(self): msg = hl7.parse(rep_sample_hl7) self.assertEqual(msg[1][4], [[&#34;Repeat1&#34;], [&#34;Repeat2&#34;]]) self.assertIsInstance(msg[1][4], Field) self.assertIsInstance(msg[1][4][0], Repetition) self.assertIsInstance(msg[1][4][1], Repetition) self.assertEqual(str(msg[1][4][0][0]), &#34;Repeat1&#34;) self.assertIsInstance(msg[1][4][0][0], str) self.assertEqual(str(msg[1][4][1][0]), &#34;Repeat2&#34;) self.assertIsInstance(msg[1][4][1][0], str)  def test_empty_initial_repetition(self): # Switch to look like &#34;|~Repeat2| msg = hl7.parse(rep_sample_hl7.replace(&#34;Repeat1&#34;, &#34;&#34;)) self.assertEqual(msg[1][4], [[&#34;&#34;], [&#34;Repeat2&#34;]])  def test_subcomponent(self): msg = hl7.parse(rep_sample_hl7) self.assertEqual( msg[1][3], [[[&#34;Component1&#34;], [&#34;Sub-Component1&#34;, &#34;Sub-Component2&#34;], [&#34;Component3&#34;]]], )  def test_elementnumbering(self): # Make sure that the numbering of repetitions. components and # sub-components is indexed from 1 when invoked as callable # (for compatibility with HL7 spec numbering) # and not 0-based (default for Python list) msg = hl7.parse(rep_sample_hl7) f = msg(2)(3)(1)(2)(2) self.assertIs(f, msg[&#34;PID.3.1.2.2&#34;]) self.assertIs(f, msg[1][3][0][1][1]) f = msg(2)(4)(2)(1) self.assertIs(f, msg[&#34;PID.4.2.1&#34;]) self.assertIs(f, msg[1][4][1][0]) # Repetition level accessed in list-form doesn't make much sense... self.assertIs(f, msg[&#34;PID.4.2&#34;])  def test_extract(self): msg = hl7.parse(rep_sample_hl7)  # Full correct path self.assertEqual(msg[&#34;PID.3.1.2.2&#34;], &#34;Sub-Component2&#34;) self.assertEqual(msg[Accessor(&#34;PID&#34;, 1, 3, 1, 2, 2)], &#34;Sub-Component2&#34;)  # Shorter Paths self.assertEqual(msg[&#34;PID.1.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[Accessor(&#34;PID&#34;, 1, 1, 1)], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID1.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID.3.1.2&#34;], &#34;Sub-Component1&#34;)  # Longer Paths self.assertEqual(msg[&#34;PID.1.1.1.1&#34;], &#34;Field1&#34;)  # Incorrect path self.assertRaisesRegex( IndexError, &#34;PID.1.1.1.2&#34;, msg.extract_field, *Accessor.parse_key(&#34;PID.1.1.1.2&#34;) )  # Optional field, not included in message self.assertEqual(msg[&#34;MSH.20&#34;], &#34;&#34;)  # Optional sub-component, not included in message self.assertEqual(msg[&#34;PID.3.1.2.3&#34;], &#34;&#34;) self.assertEqual(msg[&#34;PID.3.1.3&#34;], &#34;Component3&#34;) self.assertEqual(msg[&#34;PID.3.1.4&#34;], &#34;&#34;)  def test_assign(self): msg = hl7.parse(rep_sample_hl7)  # Field msg[&#34;MSH.20&#34;] = &#34;FIELD 20&#34; self.assertEqual(msg[&#34;MSH.20&#34;], &#34;FIELD 20&#34;)  # Component msg[&#34;MSH.21.1.1&#34;] = &#34;COMPONENT 21.1.1&#34; self.assertEqual(msg[&#34;MSH.21.1.1&#34;], &#34;COMPONENT 21.1.1&#34;)  # Sub-Component msg[&#34;MSH.21.1.2.4&#34;] = &#34;SUBCOMPONENT 21.1.2.4&#34; self.assertEqual(msg[&#34;MSH.21.1.2.4&#34;], &#34;SUBCOMPONENT 21.1.2.4&#34;)  # Verify round-tripping (i.e. that separators are correct) msg2 = hl7.parse(str(msg)) self.assertEqual(msg2[&#34;MSH.20&#34;], &#34;FIELD 20&#34;) self.assertEqual(msg2[&#34;MSH.21.1.1&#34;], &#34;COMPONENT 21.1.1&#34;) self.assertEqual(msg2[&#34;MSH.21.1.2.4&#34;], &#34;SUBCOMPONENT 21.1.2.4&#34;)  def test_unescape(self): msg = hl7.parse(rep_sample_hl7)  # Replace Separators self.assertEqual(msg.unescape(&#34;\\\\E\\\\&#34;), &#34;\\\\&#34;) self.assertEqual(msg.unescape(&#34;\\\\F\\\\&#34;), &#34;|&#34;) self.assertEqual(msg.unescape(&#34;\\\\S\\\\&#34;), &#34;^&#34;) self.assertEqual(msg.unescape(&#34;\\\\T\\\\&#34;), &#34;&#38;&#34;) self.assertEqual(msg.unescape(&#34;\\\\R\\\\&#34;), &#34;~&#34;)  # Replace Highlighting self.assertEqual(msg.unescape(&#34;\\\\H\\\\text\\\\N\\\\&#34;), &#34;_text_&#34;)  # Application Overrides self.assertEqual(msg.unescape(&#34;\\\\H\\\\text\\\\N\\\\&#34;, {&#34;H&#34;: &#34;*&#34;, &#34;N&#34;: &#34;*&#34;}), &#34;*text*&#34;)  # Hex Codes self.assertEqual(msg.unescape(&#34;\\\\X20202020\\\\&#34;), &#34;    &#34;) self.assertEqual(msg.unescape(&#34;\\\\Xe1\\\\\\\\Xe9\\\\\\\\Xed\\\\\\\\Xf3\\\\\\\\Xfa\\\\&#34;), &#34;&#225;&#233;&#237;&#243;&#250;&#34;)  def test_escape(self): msg = hl7.parse(rep_sample_hl7)  # Escape Separators self.assertEqual(msg.escape(&#34;\\\\&#34;), &#34;\\\\E\\\\&#34;) self.assertEqual(msg.escape(&#34;|&#34;), &#34;\\\\F\\\\&#34;) self.assertEqual(msg.escape(&#34;^&#34;), &#34;\\\\S\\\\&#34;) self.assertEqual(msg.escape(&#34;&#38;&#34;), &#34;\\\\T\\\\&#34;) self.assertEqual(msg.escape(&#34;~&#34;), &#34;\\\\R\\\\&#34;)  # Escape ASCII characters self.assertEqual(msg.escape(&#34;asdf&#34;), &#34;asdf&#34;)  # Escape non-ASCII characters self.assertEqual(msg.escape(&#34;&#225;&#233;&#237;&#243;&#250;&#34;), &#34;\\\\Xe1\\\\\\\\Xe9\\\\\\\\Xed\\\\\\\\Xf3\\\\\\\\Xfa\\\\&#34;) self.assertEqual(msg.escape(&#34;&#228;sdf&#34;), &#34;\\\\Xe4\\\\sdf&#34;)  def test_file(self): # Extract message from file self.assertTrue(hl7.isfile(sample_file)) messages = hl7.split_file(sample_file) self.assertEqual(len(messages), 1)  # message can be parsed msg = hl7.parse(messages[0])  # message has expected content self.assertEqual( [s[0][0] for s in msg], [&#34;MSH&#34;, &#34;EVN&#34;, &#34;PID&#34;, &#34;PD1&#34;, &#34;NK1&#34;, &#34;PV1&#34;] )",
                    "signature": "class ParseTest(TestCase): def test_parse(self): msg = hl7.parse(sample_hl7) self.assertEqual(len(msg), 5) self.assertIsInstance(msg[0][0][0], str) self.assertEqual(msg[0][0][0], &#34;MSH&#34;) self.assertEqual(msg[3][0][0], &#34;OBX&#34;) self.assertEqual( msg[3][3], [[[&#34;1554-5&#34;], [&#34;GLUCOSE&#34;], [&#34;POST 12H CFST:MCNC:PT:SER/PLAS:QN&#34;]]], ) # Make sure MSH-1 and MSH-2 are valid self.assertEqual(msg[0][1][0], &#34;|&#34;) self.assertIsInstance(msg[0][1], hl7.Field) self.assertEqual(msg[0][2][0], r&#34;^~\\&#38;&#34;) self.assertIsInstance(msg[0][2], hl7.Field) # MSH-9 is the message type self.assertEqual(msg[0][9], [[[&#34;ORU&#34;], [&#34;R01&#34;]]]) # Do it twice to make sure text coercion is idempotent self.assertEqual(str(msg), sample_hl7) self.assertEqual(str(msg), sample_hl7)  def test_parse_batch(self): batch = hl7.parse_batch(sample_batch) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;) self.assertEqual(batch.trailer[1][0], &#34;1&#34;)  def test_parse_batch1(self): batch = hl7.parse_batch(sample_batch1) self.assertEqual(len(batch), 2) self.assertIsInstance(batch[0], hl7.Message) self.assertEqual(batch[0][0][10][0], &#34;12334456778890&#34;) self.assertIsInstance(batch[1], hl7.Message) self.assertEqual(batch[1][0][10][0], &#34;12334456778891&#34;) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;) self.assertEqual(batch.trailer[1][0], &#34;2&#34;)  def test_parse_batch2(self): batch = hl7.parse_batch(sample_batch2) self.assertEqual(len(batch), 2) self.assertIsInstance(batch[0], hl7.Message) self.assertEqual(batch[0][0][10][0], &#34;12334456778890&#34;) self.assertIsInstance(batch[1], hl7.Message) self.assertEqual(batch[1][0][10][0], &#34;12334456778891&#34;) self.assertFalse(batch.header) self.assertFalse(batch.trailer)  def test_parse_batch3(self): batch = hl7.parse_batch(sample_batch3) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;)  def test_parse_batch4(self): batch = hl7.parse_batch(sample_batch4) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsNone(batch.header) self.assertIsNone(batch.trailer)  def test_parse_bad_batch(self): with self.assertRaises(ParseException) as cm: hl7.parse_batch(sample_bad_batch) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])  def test_parse_bad_batch1(self): with self.assertRaises(ParseException) as cm: hl7.parse_batch(sample_bad_batch1) self.assertIn( &#34;Batch cannot have more than one BHS segment&#34;, cm.exception.args[0] )  def test_parse_file(self): file = hl7.parse_file(sample_file) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)  def test_parse_file1(self): file = hl7.parse_file(sample_file1) self.assertEqual(len(file), 2) self.assertIsInstance(file[0], hl7.Batch) self.assertEqual(file[0].trailer[1][0], &#34;2&#34;) self.assertIsInstance(file[1], hl7.Batch) self.assertEqual(file[1].trailer[1][0], &#34;1&#34;) self.assertNotEqual(file[0], file[1]) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;2&#34;)  def test_parse_file2(self): file = hl7.parse_file(sample_file2) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)  def test_parse_file3(self): file = hl7.parse_file(sample_file3) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;)  def test_parse_file4(self): file = hl7.parse_file(sample_file4) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsNone(file.header) self.assertIsNone(file.trailer)  def test_parse_file5(self): file = hl7.parse_file(sample_file5) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)  def test_parse_file6(self): file = hl7.parse_file(sample_file6) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)  def test_parse_bad_file(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])  def test_parse_bad_file1(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file1) self.assertIn( &#34;Batch cannot have more than one BHS segment&#34;, cm.exception.args[0] )  def test_parse_bad_file2(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file2) self.assertIn( &#34;File cannot have more than one FHS segment&#34;, cm.exception.args[0] )  def test_parse_bad_file3(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file3) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])  def test_parse_hl7(self): obj = hl7.parse_hl7(sample_hl7) self.assertIsInstance(obj, hl7.Message) obj = hl7.parse_hl7(sample_batch) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_batch1) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_batch2) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_file) self.assertIsInstance(obj, hl7.File) obj = hl7.parse_hl7(sample_file1) self.assertIsInstance(obj, hl7.File) obj = hl7.parse_hl7(sample_file2) self.assertIsInstance(obj, hl7.File)  def test_bytestring_converted_to_unicode(self): msg = hl7.parse(str(sample_hl7)) self.assertEqual(len(msg), 5) self.assertIsInstance(msg[0][0][0], str) self.assertEqual(msg[0][0][0], &#34;MSH&#34;)  def test_non_ascii_bytestring(self): # \\x96 - valid cp1252, not valid utf8 # it is the responsibility of the caller to convert to unicode msg = hl7.parse(b&#34;MSH|^~\\\\&#38;|GHH LAB|ELAB\\x963&#34;, encoding=&#34;cp1252&#34;) self.assertEqual(msg[0][4][0], &#34;ELAB\\u20133&#34;)  def test_non_ascii_bytestring_no_encoding(self): # \\x96 - valid cp1252, not valid utf8 # it is the responsibility of the caller to convert to unicode self.assertRaises(UnicodeDecodeError, hl7.parse, b&#34;MSH|^~\\\\&#38;|GHH LAB|ELAB\\x963&#34;)  def test_parsing_classes(self): msg = hl7.parse(sample_hl7)  self.assertIsInstance(msg, hl7.Message) self.assertIsInstance(msg[3], hl7.Segment) self.assertIsInstance(msg[3][0], hl7.Field) self.assertIsInstance(msg[3][0][0], str)  def test_nonstandard_separators(self): nonstd = &#34;MSH$%~\\\\&#38;$GHH LAB\\rPID$$$555-44-4444$$EVERYWOMAN%EVE%E%%%L\\r&#34; msg = hl7.parse(nonstd)  self.assertEqual(str(msg), nonstd) self.assertEqual(len(msg), 2) self.assertEqual( msg[1][5], [[[&#34;EVERYWOMAN&#34;], [&#34;EVE&#34;], [&#34;E&#34;], [&#34;&#34;], [&#34;&#34;], [&#34;L&#34;]]] )  def test_repetition(self): msg = hl7.parse(rep_sample_hl7) self.assertEqual(msg[1][4], [[&#34;Repeat1&#34;], [&#34;Repeat2&#34;]]) self.assertIsInstance(msg[1][4], Field) self.assertIsInstance(msg[1][4][0], Repetition) self.assertIsInstance(msg[1][4][1], Repetition) self.assertEqual(str(msg[1][4][0][0]), &#34;Repeat1&#34;) self.assertIsInstance(msg[1][4][0][0], str) self.assertEqual(str(msg[1][4][1][0]), &#34;Repeat2&#34;) self.assertIsInstance(msg[1][4][1][0], str)  def test_empty_initial_repetition(self): # Switch to look like &#34;|~Repeat2| msg = hl7.parse(rep_sample_hl7.replace(&#34;Repeat1&#34;, &#34;&#34;)) self.assertEqual(msg[1][4], [[&#34;&#34;], [&#34;Repeat2&#34;]])  def test_subcomponent(self): msg = hl7.parse(rep_sample_hl7) self.assertEqual( msg[1][3], [[[&#34;Component1&#34;], [&#34;Sub-Component1&#34;, &#34;Sub-Component2&#34;], [&#34;Component3&#34;]]], )  def test_elementnumbering(self): # Make sure that the numbering of repetitions. components and # sub-components is indexed from 1 when invoked as callable # (for compatibility with HL7 spec numbering) # and not 0-based (default for Python list) msg = hl7.parse(rep_sample_hl7) f = msg(2)(3)(1)(2)(2) self.assertIs(f, msg[&#34;PID.3.1.2.2&#34;]) self.assertIs(f, msg[1][3][0][1][1]) f = msg(2)(4)(2)(1) self.assertIs(f, msg[&#34;PID.4.2.1&#34;]) self.assertIs(f, msg[1][4][1][0]) # Repetition level accessed in list-form doesn't make much sense... self.assertIs(f, msg[&#34;PID.4.2&#34;])  def test_extract(self): msg = hl7.parse(rep_sample_hl7)  # Full correct path self.assertEqual(msg[&#34;PID.3.1.2.2&#34;], &#34;Sub-Component2&#34;) self.assertEqual(msg[Accessor(&#34;PID&#34;, 1, 3, 1, 2, 2)], &#34;Sub-Component2&#34;)  # Shorter Paths self.assertEqual(msg[&#34;PID.1.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[Accessor(&#34;PID&#34;, 1, 1, 1)], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID1.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID.3.1.2&#34;], &#34;Sub-Component1&#34;)  # Longer Paths self.assertEqual(msg[&#34;PID.1.1.1.1&#34;], &#34;Field1&#34;)  # Incorrect path self.assertRaisesRegex( IndexError, &#34;PID.1.1.1.2&#34;, msg.extract_field, *Accessor.parse_key(&#34;PID.1.1.1.2&#34;) )  # Optional field, not included in message self.assertEqual(msg[&#34;MSH.20&#34;], &#34;&#34;)  # Optional sub-component, not included in message self.assertEqual(msg[&#34;PID.3.1.2.3&#34;], &#34;&#34;) self.assertEqual(msg[&#34;PID.3.1.3&#34;], &#34;Component3&#34;) self.assertEqual(msg[&#34;PID.3.1.4&#34;], &#34;&#34;)  def test_assign(self): msg = hl7.parse(rep_sample_hl7)  # Field msg[&#34;MSH.20&#34;] = &#34;FIELD 20&#34; self.assertEqual(msg[&#34;MSH.20&#34;], &#34;FIELD 20&#34;)  # Component msg[&#34;MSH.21.1.1&#34;] = &#34;COMPONENT 21.1.1&#34; self.assertEqual(msg[&#34;MSH.21.1.1&#34;], &#34;COMPONENT 21.1.1&#34;)  # Sub-Component msg[&#34;MSH.21.1.2.4&#34;] = &#34;SUBCOMPONENT 21.1.2.4&#34; self.assertEqual(msg[&#34;MSH.21.1.2.4&#34;], &#34;SUBCOMPONENT 21.1.2.4&#34;)  # Verify round-tripping (i.e. that separators are correct) msg2 = hl7.parse(str(msg)) self.assertEqual(msg2[&#34;MSH.20&#34;], &#34;FIELD 20&#34;) self.assertEqual(msg2[&#34;MSH.21.1.1&#34;], &#34;COMPONENT 21.1.1&#34;) self.assertEqual(msg2[&#34;MSH.21.1.2.4&#34;], &#34;SUBCOMPONENT 21.1.2.4&#34;)  def test_unescape(self): msg = hl7.parse(rep_sample_hl7)  # Replace Separators self.assertEqual(msg.unescape(&#34;\\\\E\\\\&#34;), &#34;\\\\&#34;) self.assertEqual(msg.unescape(&#34;\\\\F\\\\&#34;), &#34;|&#34;) self.assertEqual(msg.unescape(&#34;\\\\S\\\\&#34;), &#34;^&#34;) self.assertEqual(msg.unescape(&#34;\\\\T\\\\&#34;), &#34;&#38;&#34;) self.assertEqual(msg.unescape(&#34;\\\\R\\\\&#34;), &#34;~&#34;)  # Replace Highlighting self.assertEqual(msg.unescape(&#34;\\\\H\\\\text\\\\N\\\\&#34;), &#34;_text_&#34;)  # Application Overrides self.assertEqual(msg.unescape(&#34;\\\\H\\\\text\\\\N\\\\&#34;, {&#34;H&#34;: &#34;*&#34;, &#34;N&#34;: &#34;*&#34;}), &#34;*text*&#34;)  # Hex Codes self.assertEqual(msg.unescape(&#34;\\\\X20202020\\\\&#34;), &#34;    &#34;) self.assertEqual(msg.unescape(&#34;\\\\Xe1\\\\\\\\Xe9\\\\\\\\Xed\\\\\\\\Xf3\\\\\\\\Xfa\\\\&#34;), &#34;&#225;&#233;&#237;&#243;&#250;&#34;)  def test_escape(self): msg = hl7.parse(rep_sample_hl7)  # Escape Separators self.assertEqual(msg.escape(&#34;\\\\&#34;), &#34;\\\\E\\\\&#34;) self.assertEqual(msg.escape(&#34;|&#34;), &#34;\\\\F\\\\&#34;) self.assertEqual(msg.escape(&#34;^&#34;), &#34;\\\\S\\\\&#34;) self.assertEqual(msg.escape(&#34;&#38;&#34;), &#34;\\\\T\\\\&#34;) self.assertEqual(msg.escape(&#34;~&#34;), &#34;\\\\R\\\\&#34;)  # Escape ASCII characters self.assertEqual(msg.escape(&#34;asdf&#34;), &#34;asdf&#34;)  # Escape non-ASCII characters self.assertEqual(msg.escape(&#34;&#225;&#233;&#237;&#243;&#250;&#34;), &#34;\\\\Xe1\\\\\\\\Xe9\\\\\\\\Xed\\\\\\\\Xf3\\\\\\\\Xfa\\\\&#34;) self.assertEqual(msg.escape(&#34;&#228;sdf&#34;), &#34;\\\\Xe4\\\\sdf&#34;)  def test_file(self): # Extract message from file self.assertTrue(hl7.isfile(sample_file)) messages = hl7.split_file(sample_file) self.assertEqual(len(messages), 1)  # message can be parsed msg = hl7.parse(messages[0])  # message has expected content self.assertEqual( [s[0][0] for s in msg], [&#34;MSH&#34;, &#34;EVN&#34;, &#34;PID&#34;, &#34;PD1&#34;, &#34;NK1&#34;, &#34;PV1&#34;] )"
                }
            },
            {
                "id": 352,
                "attributes": {
                    "id": 352.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse",
                    "type": "function",
                    "code": "def test_parse(self): msg = hl7.parse(sample_hl7) self.assertEqual(len(msg), 5) self.assertIsInstance(msg[0][0][0], str) self.assertEqual(msg[0][0][0], &#34;MSH&#34;) self.assertEqual(msg[3][0][0], &#34;OBX&#34;) self.assertEqual( msg[3][3], [[[&#34;1554-5&#34;], [&#34;GLUCOSE&#34;], [&#34;POST 12H CFST:MCNC:PT:SER/PLAS:QN&#34;]]], ) # Make sure MSH-1 and MSH-2 are valid self.assertEqual(msg[0][1][0], &#34;|&#34;) self.assertIsInstance(msg[0][1], hl7.Field) self.assertEqual(msg[0][2][0], r&#34;^~\\&#38;&#34;) self.assertIsInstance(msg[0][2], hl7.Field) # MSH-9 is the message type self.assertEqual(msg[0][9], [[[&#34;ORU&#34;], [&#34;R01&#34;]]]) # Do it twice to make sure text coercion is idempotent self.assertEqual(str(msg), sample_hl7) self.assertEqual(str(msg), sample_hl7)",
                    "signature": "def test_parse(self): msg = hl7.parse(sample_hl7) self.assertEqual(len(msg), 5) self.assertIsInstance(msg[0][0][0], str) self.assertEqual(msg[0][0][0], &#34;MSH&#34;) self.assertEqual(msg[3][0][0], &#34;OBX&#34;) self.assertEqual( msg[3][3], [[[&#34;1554-5&#34;], [&#34;GLUCOSE&#34;], [&#34;POST 12H CFST:MCNC:PT:SER/PLAS:QN&#34;]]], ) # Make sure MSH-1 and MSH-2 are valid self.assertEqual(msg[0][1][0], &#34;|&#34;) self.assertIsInstance(msg[0][1], hl7.Field) self.assertEqual(msg[0][2][0], r&#34;^~\\&#38;&#34;) self.assertIsInstance(msg[0][2], hl7.Field) # MSH-9 is the message type self.assertEqual(msg[0][9], [[[&#34;ORU&#34;], [&#34;R01&#34;]]]) # Do it twice to make sure text coercion is idempotent self.assertEqual(str(msg), sample_hl7) self.assertEqual(str(msg), sample_hl7)"
                }
            },
            {
                "id": 353,
                "attributes": {
                    "id": 353.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_batch",
                    "type": "function",
                    "code": "def test_parse_batch(self): batch = hl7.parse_batch(sample_batch) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;) self.assertEqual(batch.trailer[1][0], &#34;1&#34;)",
                    "signature": "def test_parse_batch(self): batch = hl7.parse_batch(sample_batch) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;) self.assertEqual(batch.trailer[1][0], &#34;1&#34;)"
                }
            },
            {
                "id": 354,
                "attributes": {
                    "id": 354.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_batch1",
                    "type": "function",
                    "code": "def test_parse_batch1(self): batch = hl7.parse_batch(sample_batch1) self.assertEqual(len(batch), 2) self.assertIsInstance(batch[0], hl7.Message) self.assertEqual(batch[0][0][10][0], &#34;12334456778890&#34;) self.assertIsInstance(batch[1], hl7.Message) self.assertEqual(batch[1][0][10][0], &#34;12334456778891&#34;) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;) self.assertEqual(batch.trailer[1][0], &#34;2&#34;)",
                    "signature": "def test_parse_batch1(self): batch = hl7.parse_batch(sample_batch1) self.assertEqual(len(batch), 2) self.assertIsInstance(batch[0], hl7.Message) self.assertEqual(batch[0][0][10][0], &#34;12334456778890&#34;) self.assertIsInstance(batch[1], hl7.Message) self.assertEqual(batch[1][0][10][0], &#34;12334456778891&#34;) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;) self.assertEqual(batch.trailer[1][0], &#34;2&#34;)"
                }
            },
            {
                "id": 355,
                "attributes": {
                    "id": 355.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_batch2",
                    "type": "function",
                    "code": "def test_parse_batch2(self): batch = hl7.parse_batch(sample_batch2) self.assertEqual(len(batch), 2) self.assertIsInstance(batch[0], hl7.Message) self.assertEqual(batch[0][0][10][0], &#34;12334456778890&#34;) self.assertIsInstance(batch[1], hl7.Message) self.assertEqual(batch[1][0][10][0], &#34;12334456778891&#34;) self.assertFalse(batch.header) self.assertFalse(batch.trailer)",
                    "signature": "def test_parse_batch2(self): batch = hl7.parse_batch(sample_batch2) self.assertEqual(len(batch), 2) self.assertIsInstance(batch[0], hl7.Message) self.assertEqual(batch[0][0][10][0], &#34;12334456778890&#34;) self.assertIsInstance(batch[1], hl7.Message) self.assertEqual(batch[1][0][10][0], &#34;12334456778891&#34;) self.assertFalse(batch.header) self.assertFalse(batch.trailer)"
                }
            },
            {
                "id": 356,
                "attributes": {
                    "id": 356.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_batch3",
                    "type": "function",
                    "code": "def test_parse_batch3(self): batch = hl7.parse_batch(sample_batch3) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;)",
                    "signature": "def test_parse_batch3(self): batch = hl7.parse_batch(sample_batch3) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsInstance(batch.header, hl7.Segment) self.assertEqual(batch.header[0][0], &#34;BHS&#34;) self.assertEqual(batch.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(batch.trailer, hl7.Segment) self.assertEqual(batch.trailer[0][0], &#34;BTS&#34;)"
                }
            },
            {
                "id": 357,
                "attributes": {
                    "id": 357.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_batch4",
                    "type": "function",
                    "code": "def test_parse_batch4(self): batch = hl7.parse_batch(sample_batch4) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsNone(batch.header) self.assertIsNone(batch.trailer)",
                    "signature": "def test_parse_batch4(self): batch = hl7.parse_batch(sample_batch4) self.assertEqual(len(batch), 1) self.assertIsInstance(batch[0], hl7.Message) self.assertIsNone(batch.header) self.assertIsNone(batch.trailer)"
                }
            },
            {
                "id": 358,
                "attributes": {
                    "id": 358.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_bad_batch",
                    "type": "function",
                    "code": "def test_parse_bad_batch(self): with self.assertRaises(ParseException) as cm: hl7.parse_batch(sample_bad_batch) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])",
                    "signature": "def test_parse_bad_batch(self): with self.assertRaises(ParseException) as cm: hl7.parse_batch(sample_bad_batch) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])"
                }
            },
            {
                "id": 359,
                "attributes": {
                    "id": 359.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_bad_batch1",
                    "type": "function",
                    "code": "def test_parse_bad_batch1(self): with self.assertRaises(ParseException) as cm: hl7.parse_batch(sample_bad_batch1) self.assertIn( &#34;Batch cannot have more than one BHS segment&#34;, cm.exception.args[0] )",
                    "signature": "def test_parse_bad_batch1(self): with self.assertRaises(ParseException) as cm: hl7.parse_batch(sample_bad_batch1) self.assertIn( &#34;Batch cannot have more than one BHS segment&#34;, cm.exception.args[0] )"
                }
            },
            {
                "id": 360,
                "attributes": {
                    "id": 360.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_file",
                    "type": "function",
                    "code": "def test_parse_file(self): file = hl7.parse_file(sample_file) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)",
                    "signature": "def test_parse_file(self): file = hl7.parse_file(sample_file) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)"
                }
            },
            {
                "id": 361,
                "attributes": {
                    "id": 361.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_file1",
                    "type": "function",
                    "code": "def test_parse_file1(self): file = hl7.parse_file(sample_file1) self.assertEqual(len(file), 2) self.assertIsInstance(file[0], hl7.Batch) self.assertEqual(file[0].trailer[1][0], &#34;2&#34;) self.assertIsInstance(file[1], hl7.Batch) self.assertEqual(file[1].trailer[1][0], &#34;1&#34;) self.assertNotEqual(file[0], file[1]) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;2&#34;)",
                    "signature": "def test_parse_file1(self): file = hl7.parse_file(sample_file1) self.assertEqual(len(file), 2) self.assertIsInstance(file[0], hl7.Batch) self.assertEqual(file[0].trailer[1][0], &#34;2&#34;) self.assertIsInstance(file[1], hl7.Batch) self.assertEqual(file[1].trailer[1][0], &#34;1&#34;) self.assertNotEqual(file[0], file[1]) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;2&#34;)"
                }
            },
            {
                "id": 362,
                "attributes": {
                    "id": 362.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_file2",
                    "type": "function",
                    "code": "def test_parse_file2(self): file = hl7.parse_file(sample_file2) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)",
                    "signature": "def test_parse_file2(self): file = hl7.parse_file(sample_file2) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)"
                }
            },
            {
                "id": 363,
                "attributes": {
                    "id": 363.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_file3",
                    "type": "function",
                    "code": "def test_parse_file3(self): file = hl7.parse_file(sample_file3) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;)",
                    "signature": "def test_parse_file3(self): file = hl7.parse_file(sample_file3) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;)"
                }
            },
            {
                "id": 364,
                "attributes": {
                    "id": 364.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_file4",
                    "type": "function",
                    "code": "def test_parse_file4(self): file = hl7.parse_file(sample_file4) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsNone(file.header) self.assertIsNone(file.trailer)",
                    "signature": "def test_parse_file4(self): file = hl7.parse_file(sample_file4) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsNone(file.header) self.assertIsNone(file.trailer)"
                }
            },
            {
                "id": 365,
                "attributes": {
                    "id": 365.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_file5",
                    "type": "function",
                    "code": "def test_parse_file5(self): file = hl7.parse_file(sample_file5) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)",
                    "signature": "def test_parse_file5(self): file = hl7.parse_file(sample_file5) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)"
                }
            },
            {
                "id": 366,
                "attributes": {
                    "id": 366.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_file6",
                    "type": "function",
                    "code": "def test_parse_file6(self): file = hl7.parse_file(sample_file6) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)",
                    "signature": "def test_parse_file6(self): file = hl7.parse_file(sample_file6) self.assertEqual(len(file), 1) self.assertIsInstance(file[0], hl7.Batch) self.assertIsInstance(file.header, hl7.Segment) self.assertEqual(file.header[0][0], &#34;FHS&#34;) self.assertEqual(file.header[4][0], &#34;ABCHS&#34;) self.assertIsInstance(file.trailer, hl7.Segment) self.assertEqual(file.trailer[0][0], &#34;FTS&#34;) self.assertEqual(file.trailer[1][0], &#34;1&#34;)"
                }
            },
            {
                "id": 367,
                "attributes": {
                    "id": 367.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_bad_file",
                    "type": "function",
                    "code": "def test_parse_bad_file(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])",
                    "signature": "def test_parse_bad_file(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])"
                }
            },
            {
                "id": 368,
                "attributes": {
                    "id": 368.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_bad_file1",
                    "type": "function",
                    "code": "def test_parse_bad_file1(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file1) self.assertIn( &#34;Batch cannot have more than one BHS segment&#34;, cm.exception.args[0] )",
                    "signature": "def test_parse_bad_file1(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file1) self.assertIn( &#34;Batch cannot have more than one BHS segment&#34;, cm.exception.args[0] )"
                }
            },
            {
                "id": 369,
                "attributes": {
                    "id": 369.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_bad_file2",
                    "type": "function",
                    "code": "def test_parse_bad_file2(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file2) self.assertIn( &#34;File cannot have more than one FHS segment&#34;, cm.exception.args[0] )",
                    "signature": "def test_parse_bad_file2(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file2) self.assertIn( &#34;File cannot have more than one FHS segment&#34;, cm.exception.args[0] )"
                }
            },
            {
                "id": 370,
                "attributes": {
                    "id": 370.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_bad_file3",
                    "type": "function",
                    "code": "def test_parse_bad_file3(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file3) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])",
                    "signature": "def test_parse_bad_file3(self): with self.assertRaises(ParseException) as cm: hl7.parse_file(sample_bad_file3) self.assertIn(&#34;Segment received before message header&#34;, cm.exception.args[0])"
                }
            },
            {
                "id": 371,
                "attributes": {
                    "id": 371.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parse_hl7",
                    "type": "function",
                    "code": "def test_parse_hl7(self): obj = hl7.parse_hl7(sample_hl7) self.assertIsInstance(obj, hl7.Message) obj = hl7.parse_hl7(sample_batch) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_batch1) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_batch2) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_file) self.assertIsInstance(obj, hl7.File) obj = hl7.parse_hl7(sample_file1) self.assertIsInstance(obj, hl7.File) obj = hl7.parse_hl7(sample_file2) self.assertIsInstance(obj, hl7.File)",
                    "signature": "def test_parse_hl7(self): obj = hl7.parse_hl7(sample_hl7) self.assertIsInstance(obj, hl7.Message) obj = hl7.parse_hl7(sample_batch) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_batch1) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_batch2) self.assertIsInstance(obj, hl7.Batch) obj = hl7.parse_hl7(sample_file) self.assertIsInstance(obj, hl7.File) obj = hl7.parse_hl7(sample_file1) self.assertIsInstance(obj, hl7.File) obj = hl7.parse_hl7(sample_file2) self.assertIsInstance(obj, hl7.File)"
                }
            },
            {
                "id": 372,
                "attributes": {
                    "id": 372.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_bytestring_converted_to_unicode",
                    "type": "function",
                    "code": "def test_bytestring_converted_to_unicode(self): msg = hl7.parse(str(sample_hl7)) self.assertEqual(len(msg), 5) self.assertIsInstance(msg[0][0][0], str) self.assertEqual(msg[0][0][0], &#34;MSH&#34;)",
                    "signature": "def test_bytestring_converted_to_unicode(self): msg = hl7.parse(str(sample_hl7)) self.assertEqual(len(msg), 5) self.assertIsInstance(msg[0][0][0], str) self.assertEqual(msg[0][0][0], &#34;MSH&#34;)"
                }
            },
            {
                "id": 373,
                "attributes": {
                    "id": 373.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_non_ascii_bytestring",
                    "type": "function",
                    "code": "def test_non_ascii_bytestring(self): # \\x96 - valid cp1252, not valid utf8 # it is the responsibility of the caller to convert to unicode msg = hl7.parse(b&#34;MSH|^~\\\\&#38;|GHH LAB|ELAB\\x963&#34;, encoding=&#34;cp1252&#34;) self.assertEqual(msg[0][4][0], &#34;ELAB\\u20133&#34;)",
                    "signature": "def test_non_ascii_bytestring(self): # \\x96 - valid cp1252, not valid utf8 # it is the responsibility of the caller to convert to unicode msg = hl7.parse(b&#34;MSH|^~\\\\&#38;|GHH LAB|ELAB\\x963&#34;, encoding=&#34;cp1252&#34;) self.assertEqual(msg[0][4][0], &#34;ELAB\\u20133&#34;)"
                }
            },
            {
                "id": 374,
                "attributes": {
                    "id": 374.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_non_ascii_bytestring_no_encoding",
                    "type": "function",
                    "code": "def test_non_ascii_bytestring_no_encoding(self): # \\x96 - valid cp1252, not valid utf8 # it is the responsibility of the caller to convert to unicode self.assertRaises(UnicodeDecodeError, hl7.parse, b&#34;MSH|^~\\\\&#38;|GHH LAB|ELAB\\x963&#34;)",
                    "signature": "def test_non_ascii_bytestring_no_encoding(self): # \\x96 - valid cp1252, not valid utf8 # it is the responsibility of the caller to convert to unicode self.assertRaises(UnicodeDecodeError, hl7.parse, b&#34;MSH|^~\\\\&#38;|GHH LAB|ELAB\\x963&#34;)"
                }
            },
            {
                "id": 375,
                "attributes": {
                    "id": 375.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_parsing_classes",
                    "type": "function",
                    "code": "def test_parsing_classes(self): msg = hl7.parse(sample_hl7)  self.assertIsInstance(msg, hl7.Message) self.assertIsInstance(msg[3], hl7.Segment) self.assertIsInstance(msg[3][0], hl7.Field) self.assertIsInstance(msg[3][0][0], str)",
                    "signature": "def test_parsing_classes(self): msg = hl7.parse(sample_hl7)  self.assertIsInstance(msg, hl7.Message) self.assertIsInstance(msg[3], hl7.Segment) self.assertIsInstance(msg[3][0], hl7.Field) self.assertIsInstance(msg[3][0][0], str)"
                }
            },
            {
                "id": 376,
                "attributes": {
                    "id": 376.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_nonstandard_separators",
                    "type": "function",
                    "code": "def test_nonstandard_separators(self): nonstd = &#34;MSH$%~\\\\&#38;$GHH LAB\\rPID$$$555-44-4444$$EVERYWOMAN%EVE%E%%%L\\r&#34; msg = hl7.parse(nonstd)  self.assertEqual(str(msg), nonstd) self.assertEqual(len(msg), 2) self.assertEqual( msg[1][5], [[[&#34;EVERYWOMAN&#34;], [&#34;EVE&#34;], [&#34;E&#34;], [&#34;&#34;], [&#34;&#34;], [&#34;L&#34;]]] )",
                    "signature": "def test_nonstandard_separators(self): nonstd = &#34;MSH$%~\\\\&#38;$GHH LAB\\rPID$$$555-44-4444$$EVERYWOMAN%EVE%E%%%L\\r&#34; msg = hl7.parse(nonstd)  self.assertEqual(str(msg), nonstd) self.assertEqual(len(msg), 2) self.assertEqual( msg[1][5], [[[&#34;EVERYWOMAN&#34;], [&#34;EVE&#34;], [&#34;E&#34;], [&#34;&#34;], [&#34;&#34;], [&#34;L&#34;]]] )"
                }
            },
            {
                "id": 377,
                "attributes": {
                    "id": 377.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_repetition",
                    "type": "function",
                    "code": "def test_repetition(self): msg = hl7.parse(rep_sample_hl7) self.assertEqual(msg[1][4], [[&#34;Repeat1&#34;], [&#34;Repeat2&#34;]]) self.assertIsInstance(msg[1][4], Field) self.assertIsInstance(msg[1][4][0], Repetition) self.assertIsInstance(msg[1][4][1], Repetition) self.assertEqual(str(msg[1][4][0][0]), &#34;Repeat1&#34;) self.assertIsInstance(msg[1][4][0][0], str) self.assertEqual(str(msg[1][4][1][0]), &#34;Repeat2&#34;) self.assertIsInstance(msg[1][4][1][0], str)",
                    "signature": "def test_repetition(self): msg = hl7.parse(rep_sample_hl7) self.assertEqual(msg[1][4], [[&#34;Repeat1&#34;], [&#34;Repeat2&#34;]]) self.assertIsInstance(msg[1][4], Field) self.assertIsInstance(msg[1][4][0], Repetition) self.assertIsInstance(msg[1][4][1], Repetition) self.assertEqual(str(msg[1][4][0][0]), &#34;Repeat1&#34;) self.assertIsInstance(msg[1][4][0][0], str) self.assertEqual(str(msg[1][4][1][0]), &#34;Repeat2&#34;) self.assertIsInstance(msg[1][4][1][0], str)"
                }
            },
            {
                "id": 378,
                "attributes": {
                    "id": 378.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_empty_initial_repetition",
                    "type": "function",
                    "code": "def test_empty_initial_repetition(self): # Switch to look like &#34;|~Repeat2| msg = hl7.parse(rep_sample_hl7.replace(&#34;Repeat1&#34;, &#34;&#34;)) self.assertEqual(msg[1][4], [[&#34;&#34;], [&#34;Repeat2&#34;]])",
                    "signature": "def test_empty_initial_repetition(self): # Switch to look like &#34;|~Repeat2| msg = hl7.parse(rep_sample_hl7.replace(&#34;Repeat1&#34;, &#34;&#34;)) self.assertEqual(msg[1][4], [[&#34;&#34;], [&#34;Repeat2&#34;]])"
                }
            },
            {
                "id": 379,
                "attributes": {
                    "id": 379.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_subcomponent",
                    "type": "function",
                    "code": "def test_subcomponent(self): msg = hl7.parse(rep_sample_hl7) self.assertEqual( msg[1][3], [[[&#34;Component1&#34;], [&#34;Sub-Component1&#34;, &#34;Sub-Component2&#34;], [&#34;Component3&#34;]]], )",
                    "signature": "def test_subcomponent(self): msg = hl7.parse(rep_sample_hl7) self.assertEqual( msg[1][3], [[[&#34;Component1&#34;], [&#34;Sub-Component1&#34;, &#34;Sub-Component2&#34;], [&#34;Component3&#34;]]], )"
                }
            },
            {
                "id": 380,
                "attributes": {
                    "id": 380.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_elementnumbering",
                    "type": "function",
                    "code": "def test_elementnumbering(self): # Make sure that the numbering of repetitions. components and # sub-components is indexed from 1 when invoked as callable # (for compatibility with HL7 spec numbering) # and not 0-based (default for Python list) msg = hl7.parse(rep_sample_hl7) f = msg(2)(3)(1)(2)(2) self.assertIs(f, msg[&#34;PID.3.1.2.2&#34;]) self.assertIs(f, msg[1][3][0][1][1]) f = msg(2)(4)(2)(1) self.assertIs(f, msg[&#34;PID.4.2.1&#34;]) self.assertIs(f, msg[1][4][1][0]) # Repetition level accessed in list-form doesn't make much sense... self.assertIs(f, msg[&#34;PID.4.2&#34;])",
                    "signature": "def test_elementnumbering(self): # Make sure that the numbering of repetitions. components and # sub-components is indexed from 1 when invoked as callable # (for compatibility with HL7 spec numbering) # and not 0-based (default for Python list) msg = hl7.parse(rep_sample_hl7) f = msg(2)(3)(1)(2)(2) self.assertIs(f, msg[&#34;PID.3.1.2.2&#34;]) self.assertIs(f, msg[1][3][0][1][1]) f = msg(2)(4)(2)(1) self.assertIs(f, msg[&#34;PID.4.2.1&#34;]) self.assertIs(f, msg[1][4][1][0]) # Repetition level accessed in list-form doesn't make much sense... self.assertIs(f, msg[&#34;PID.4.2&#34;])"
                }
            },
            {
                "id": 381,
                "attributes": {
                    "id": 381.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_extract",
                    "type": "function",
                    "code": "def test_extract(self): msg = hl7.parse(rep_sample_hl7)  # Full correct path self.assertEqual(msg[&#34;PID.3.1.2.2&#34;], &#34;Sub-Component2&#34;) self.assertEqual(msg[Accessor(&#34;PID&#34;, 1, 3, 1, 2, 2)], &#34;Sub-Component2&#34;)  # Shorter Paths self.assertEqual(msg[&#34;PID.1.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[Accessor(&#34;PID&#34;, 1, 1, 1)], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID1.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID.3.1.2&#34;], &#34;Sub-Component1&#34;)  # Longer Paths self.assertEqual(msg[&#34;PID.1.1.1.1&#34;], &#34;Field1&#34;)  # Incorrect path self.assertRaisesRegex( IndexError, &#34;PID.1.1.1.2&#34;, msg.extract_field, *Accessor.parse_key(&#34;PID.1.1.1.2&#34;) )  # Optional field, not included in message self.assertEqual(msg[&#34;MSH.20&#34;], &#34;&#34;)  # Optional sub-component, not included in message self.assertEqual(msg[&#34;PID.3.1.2.3&#34;], &#34;&#34;) self.assertEqual(msg[&#34;PID.3.1.3&#34;], &#34;Component3&#34;) self.assertEqual(msg[&#34;PID.3.1.4&#34;], &#34;&#34;)",
                    "signature": "def test_extract(self): msg = hl7.parse(rep_sample_hl7)  # Full correct path self.assertEqual(msg[&#34;PID.3.1.2.2&#34;], &#34;Sub-Component2&#34;) self.assertEqual(msg[Accessor(&#34;PID&#34;, 1, 3, 1, 2, 2)], &#34;Sub-Component2&#34;)  # Shorter Paths self.assertEqual(msg[&#34;PID.1.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[Accessor(&#34;PID&#34;, 1, 1, 1)], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID1.1&#34;], &#34;Field1&#34;) self.assertEqual(msg[&#34;PID.3.1.2&#34;], &#34;Sub-Component1&#34;)  # Longer Paths self.assertEqual(msg[&#34;PID.1.1.1.1&#34;], &#34;Field1&#34;)  # Incorrect path self.assertRaisesRegex( IndexError, &#34;PID.1.1.1.2&#34;, msg.extract_field, *Accessor.parse_key(&#34;PID.1.1.1.2&#34;) )  # Optional field, not included in message self.assertEqual(msg[&#34;MSH.20&#34;], &#34;&#34;)  # Optional sub-component, not included in message self.assertEqual(msg[&#34;PID.3.1.2.3&#34;], &#34;&#34;) self.assertEqual(msg[&#34;PID.3.1.3&#34;], &#34;Component3&#34;) self.assertEqual(msg[&#34;PID.3.1.4&#34;], &#34;&#34;)"
                }
            },
            {
                "id": 382,
                "attributes": {
                    "id": 382.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_assign",
                    "type": "function",
                    "code": "def test_assign(self): msg = hl7.parse(rep_sample_hl7)  # Field msg[&#34;MSH.20&#34;] = &#34;FIELD 20&#34; self.assertEqual(msg[&#34;MSH.20&#34;], &#34;FIELD 20&#34;)  # Component msg[&#34;MSH.21.1.1&#34;] = &#34;COMPONENT 21.1.1&#34; self.assertEqual(msg[&#34;MSH.21.1.1&#34;], &#34;COMPONENT 21.1.1&#34;)  # Sub-Component msg[&#34;MSH.21.1.2.4&#34;] = &#34;SUBCOMPONENT 21.1.2.4&#34; self.assertEqual(msg[&#34;MSH.21.1.2.4&#34;], &#34;SUBCOMPONENT 21.1.2.4&#34;)  # Verify round-tripping (i.e. that separators are correct) msg2 = hl7.parse(str(msg)) self.assertEqual(msg2[&#34;MSH.20&#34;], &#34;FIELD 20&#34;) self.assertEqual(msg2[&#34;MSH.21.1.1&#34;], &#34;COMPONENT 21.1.1&#34;) self.assertEqual(msg2[&#34;MSH.21.1.2.4&#34;], &#34;SUBCOMPONENT 21.1.2.4&#34;)",
                    "signature": "def test_assign(self): msg = hl7.parse(rep_sample_hl7)  # Field msg[&#34;MSH.20&#34;] = &#34;FIELD 20&#34; self.assertEqual(msg[&#34;MSH.20&#34;], &#34;FIELD 20&#34;)  # Component msg[&#34;MSH.21.1.1&#34;] = &#34;COMPONENT 21.1.1&#34; self.assertEqual(msg[&#34;MSH.21.1.1&#34;], &#34;COMPONENT 21.1.1&#34;)  # Sub-Component msg[&#34;MSH.21.1.2.4&#34;] = &#34;SUBCOMPONENT 21.1.2.4&#34; self.assertEqual(msg[&#34;MSH.21.1.2.4&#34;], &#34;SUBCOMPONENT 21.1.2.4&#34;)  # Verify round-tripping (i.e. that separators are correct) msg2 = hl7.parse(str(msg)) self.assertEqual(msg2[&#34;MSH.20&#34;], &#34;FIELD 20&#34;) self.assertEqual(msg2[&#34;MSH.21.1.1&#34;], &#34;COMPONENT 21.1.1&#34;) self.assertEqual(msg2[&#34;MSH.21.1.2.4&#34;], &#34;SUBCOMPONENT 21.1.2.4&#34;)"
                }
            },
            {
                "id": 383,
                "attributes": {
                    "id": 383.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_unescape",
                    "type": "function",
                    "code": "def test_unescape(self): msg = hl7.parse(rep_sample_hl7)  # Replace Separators self.assertEqual(msg.unescape(&#34;\\\\E\\\\&#34;), &#34;\\\\&#34;) self.assertEqual(msg.unescape(&#34;\\\\F\\\\&#34;), &#34;|&#34;) self.assertEqual(msg.unescape(&#34;\\\\S\\\\&#34;), &#34;^&#34;) self.assertEqual(msg.unescape(&#34;\\\\T\\\\&#34;), &#34;&#38;&#34;) self.assertEqual(msg.unescape(&#34;\\\\R\\\\&#34;), &#34;~&#34;)  # Replace Highlighting self.assertEqual(msg.unescape(&#34;\\\\H\\\\text\\\\N\\\\&#34;), &#34;_text_&#34;)  # Application Overrides self.assertEqual(msg.unescape(&#34;\\\\H\\\\text\\\\N\\\\&#34;, {&#34;H&#34;: &#34;*&#34;, &#34;N&#34;: &#34;*&#34;}), &#34;*text*&#34;)  # Hex Codes self.assertEqual(msg.unescape(&#34;\\\\X20202020\\\\&#34;), &#34;    &#34;) self.assertEqual(msg.unescape(&#34;\\\\Xe1\\\\\\\\Xe9\\\\\\\\Xed\\\\\\\\Xf3\\\\\\\\Xfa\\\\&#34;), &#34;&#225;&#233;&#237;&#243;&#250;&#34;)",
                    "signature": "def test_unescape(self): msg = hl7.parse(rep_sample_hl7)  # Replace Separators self.assertEqual(msg.unescape(&#34;\\\\E\\\\&#34;), &#34;\\\\&#34;) self.assertEqual(msg.unescape(&#34;\\\\F\\\\&#34;), &#34;|&#34;) self.assertEqual(msg.unescape(&#34;\\\\S\\\\&#34;), &#34;^&#34;) self.assertEqual(msg.unescape(&#34;\\\\T\\\\&#34;), &#34;&#38;&#34;) self.assertEqual(msg.unescape(&#34;\\\\R\\\\&#34;), &#34;~&#34;)  # Replace Highlighting self.assertEqual(msg.unescape(&#34;\\\\H\\\\text\\\\N\\\\&#34;), &#34;_text_&#34;)  # Application Overrides self.assertEqual(msg.unescape(&#34;\\\\H\\\\text\\\\N\\\\&#34;, {&#34;H&#34;: &#34;*&#34;, &#34;N&#34;: &#34;*&#34;}), &#34;*text*&#34;)  # Hex Codes self.assertEqual(msg.unescape(&#34;\\\\X20202020\\\\&#34;), &#34;    &#34;) self.assertEqual(msg.unescape(&#34;\\\\Xe1\\\\\\\\Xe9\\\\\\\\Xed\\\\\\\\Xf3\\\\\\\\Xfa\\\\&#34;), &#34;&#225;&#233;&#237;&#243;&#250;&#34;)"
                }
            },
            {
                "id": 384,
                "attributes": {
                    "id": 384.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_escape",
                    "type": "function",
                    "code": "def test_escape(self): msg = hl7.parse(rep_sample_hl7)  # Escape Separators self.assertEqual(msg.escape(&#34;\\\\&#34;), &#34;\\\\E\\\\&#34;) self.assertEqual(msg.escape(&#34;|&#34;), &#34;\\\\F\\\\&#34;) self.assertEqual(msg.escape(&#34;^&#34;), &#34;\\\\S\\\\&#34;) self.assertEqual(msg.escape(&#34;&#38;&#34;), &#34;\\\\T\\\\&#34;) self.assertEqual(msg.escape(&#34;~&#34;), &#34;\\\\R\\\\&#34;)  # Escape ASCII characters self.assertEqual(msg.escape(&#34;asdf&#34;), &#34;asdf&#34;)  # Escape non-ASCII characters self.assertEqual(msg.escape(&#34;&#225;&#233;&#237;&#243;&#250;&#34;), &#34;\\\\Xe1\\\\\\\\Xe9\\\\\\\\Xed\\\\\\\\Xf3\\\\\\\\Xfa\\\\&#34;) self.assertEqual(msg.escape(&#34;&#228;sdf&#34;), &#34;\\\\Xe4\\\\sdf&#34;)",
                    "signature": "def test_escape(self): msg = hl7.parse(rep_sample_hl7)  # Escape Separators self.assertEqual(msg.escape(&#34;\\\\&#34;), &#34;\\\\E\\\\&#34;) self.assertEqual(msg.escape(&#34;|&#34;), &#34;\\\\F\\\\&#34;) self.assertEqual(msg.escape(&#34;^&#34;), &#34;\\\\S\\\\&#34;) self.assertEqual(msg.escape(&#34;&#38;&#34;), &#34;\\\\T\\\\&#34;) self.assertEqual(msg.escape(&#34;~&#34;), &#34;\\\\R\\\\&#34;)  # Escape ASCII characters self.assertEqual(msg.escape(&#34;asdf&#34;), &#34;asdf&#34;)  # Escape non-ASCII characters self.assertEqual(msg.escape(&#34;&#225;&#233;&#237;&#243;&#250;&#34;), &#34;\\\\Xe1\\\\\\\\Xe9\\\\\\\\Xed\\\\\\\\Xf3\\\\\\\\Xfa\\\\&#34;) self.assertEqual(msg.escape(&#34;&#228;sdf&#34;), &#34;\\\\Xe4\\\\sdf&#34;)"
                }
            },
            {
                "id": 425,
                "attributes": {
                    "id": 425.0,
                    "label": "hl7.tests.test_containers.ContainerTest",
                    "type": "class",
                    "code": "class ContainerTest(TestCase): def test_unicode(self): msg = hl7.parse(sample_hl7) self.assertEqual(str(msg), sample_hl7) self.assertEqual( str(msg[3][3]), &#34;1554-5^GLUCOSE^POST 12H CFST:MCNC:PT:SER/PLAS:QN&#34; )  def test_container_unicode(self): c = hl7.Container(&#34;|&#34;) c.extend([&#34;1&#34;, &#34;b&#34;, &#34;data&#34;]) self.assertEqual(str(c), &#34;1|b|data&#34;)",
                    "signature": "class ContainerTest(TestCase): def test_unicode(self): msg = hl7.parse(sample_hl7) self.assertEqual(str(msg), sample_hl7) self.assertEqual( str(msg[3][3]), &#34;1554-5^GLUCOSE^POST 12H CFST:MCNC:PT:SER/PLAS:QN&#34; )  def test_container_unicode(self): c = hl7.Container(&#34;|&#34;) c.extend([&#34;1&#34;, &#34;b&#34;, &#34;data&#34;]) self.assertEqual(str(c), &#34;1|b|data&#34;)"
                }
            },
            {
                "id": 426,
                "attributes": {
                    "id": 426.0,
                    "label": "hl7.tests.test_containers.ContainerTest.test_unicode",
                    "type": "function",
                    "code": "def test_unicode(self): msg = hl7.parse(sample_hl7) self.assertEqual(str(msg), sample_hl7) self.assertEqual( str(msg[3][3]), &#34;1554-5^GLUCOSE^POST 12H CFST:MCNC:PT:SER/PLAS:QN&#34; )",
                    "signature": "def test_unicode(self): msg = hl7.parse(sample_hl7) self.assertEqual(str(msg), sample_hl7) self.assertEqual( str(msg[3][3]), &#34;1554-5^GLUCOSE^POST 12H CFST:MCNC:PT:SER/PLAS:QN&#34; )"
                }
            },
            {
                "id": 427,
                "attributes": {
                    "id": 427.0,
                    "label": "hl7.tests.test_containers.ContainerTest.test_container_unicode",
                    "type": "function",
                    "code": "def test_container_unicode(self): c = hl7.Container(&#34;|&#34;) c.extend([&#34;1&#34;, &#34;b&#34;, &#34;data&#34;]) self.assertEqual(str(c), &#34;1|b|data&#34;)",
                    "signature": "def test_container_unicode(self): c = hl7.Container(&#34;|&#34;) c.extend([&#34;1&#34;, &#34;b&#34;, &#34;data&#34;]) self.assertEqual(str(c), &#34;1|b|data&#34;)"
                }
            },
            {
                "id": 428,
                "attributes": {
                    "id": 428.0,
                    "label": "hl7.tests.test_containers.MessageTest",
                    "type": "class",
                    "code": "class MessageTest(TestCase): def test_segments(self): msg = hl7.parse(sample_hl7) s = msg.segments(&#34;OBX&#34;) self.assertEqual(len(s), 2) self.assertIsInstance(s[0], Segment) self.assertEqual(s[0][0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]]) self.assertEqual(s[1][0:3], [[&#34;OBX&#34;], [&#34;2&#34;], [&#34;FN&#34;]])  self.assertIsInstance(s[0][1], Field)  def test_segments_does_not_exist(self): msg = hl7.parse(sample_hl7) self.assertRaises(KeyError, msg.segments, &#34;BAD&#34;)  def test_segment(self): msg = hl7.parse(sample_hl7) s = msg.segment(&#34;OBX&#34;) self.assertEqual(s[0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]])  def test_segment_does_not_exist(self): msg = hl7.parse(sample_hl7) self.assertRaises(KeyError, msg.segment, &#34;BAD&#34;)  def test_segments_dict_key(self): msg = hl7.parse(sample_hl7) s = msg[&#34;OBX&#34;] self.assertEqual(len(s), 2) self.assertEqual(s[0][0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]]) self.assertEqual(s[1][0:3], [[&#34;OBX&#34;], [&#34;2&#34;], [&#34;FN&#34;]])  def test_MSH_1_field(self): msg = hl7.parse(sample_hl7) f = msg[&#34;MSH.1&#34;] self.assertEqual(len(f), 1) self.assertEqual(f, &#34;|&#34;)  def test_MSH_2_field(self): msg = hl7.parse(sample_hl7) f = msg[&#34;MSH.2&#34;] self.assertEqual(len(f), 4) self.assertEqual(f, &#34;^~\\\\&#38;&#34;)  def test_get_slice(self): msg = hl7.parse(sample_hl7) s = msg.segments(&#34;OBX&#34;)[0] self.assertIsInstance(s, Segment) self.assertIsInstance(s[0:3], Segment)  def test_ack(self): msg = hl7.parse(sample_hl7) ack = msg.create_ack() self.assertEqual(msg[&#34;MSH.1&#34;], ack[&#34;MSH.1&#34;]) self.assertEqual(msg[&#34;MSH.2&#34;], ack[&#34;MSH.2&#34;]) self.assertEqual(&#34;ACK&#34;, ack[&#34;MSH.9.1.1&#34;]) self.assertEqual(msg[&#34;MSH.9.1.2&#34;], ack[&#34;MSH.9.1.2&#34;]) self.assertEqual(&#34;ACK&#34;, ack[&#34;MSH.9.1.3&#34;]) self.assertNotEqual(msg[&#34;MSH.7&#34;], ack[&#34;MSH.7&#34;]) self.assertNotEqual(msg[&#34;MSH.10&#34;], ack[&#34;MSH.10&#34;]) self.assertEqual(&#34;AA&#34;, ack[&#34;MSA.1&#34;]) self.assertEqual(msg[&#34;MSH.10&#34;], ack[&#34;MSA.2&#34;]) self.assertEqual(20, len(ack[&#34;MSH.10&#34;])) self.assertEqual(msg[&#34;MSH.5&#34;], ack[&#34;MSH.3&#34;]) self.assertEqual(msg[&#34;MSH.6&#34;], ack[&#34;MSH.4&#34;]) self.assertEqual(msg[&#34;MSH.3&#34;], ack[&#34;MSH.5&#34;]) self.assertEqual(msg[&#34;MSH.4&#34;], ack[&#34;MSH.6&#34;]) ack2 = msg.create_ack( ack_code=&#34;AE&#34;, message_id=&#34;testid&#34;, application=&#34;python&#34;, facility=&#34;test&#34; ) self.assertEqual(&#34;AE&#34;, ack2[&#34;MSA.1&#34;]) self.assertEqual(&#34;testid&#34;, ack2[&#34;MSH.10&#34;]) self.assertEqual(&#34;python&#34;, ack2[&#34;MSH.3&#34;]) self.assertEqual(&#34;test&#34;, ack2[&#34;MSH.4&#34;]) self.assertNotEqual(ack[&#34;MSH.10&#34;], ack2[&#34;MSH.10&#34;])",
                    "signature": "class MessageTest(TestCase): def test_segments(self): msg = hl7.parse(sample_hl7) s = msg.segments(&#34;OBX&#34;) self.assertEqual(len(s), 2) self.assertIsInstance(s[0], Segment) self.assertEqual(s[0][0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]]) self.assertEqual(s[1][0:3], [[&#34;OBX&#34;], [&#34;2&#34;], [&#34;FN&#34;]])  self.assertIsInstance(s[0][1], Field)  def test_segments_does_not_exist(self): msg = hl7.parse(sample_hl7) self.assertRaises(KeyError, msg.segments, &#34;BAD&#34;)  def test_segment(self): msg = hl7.parse(sample_hl7) s = msg.segment(&#34;OBX&#34;) self.assertEqual(s[0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]])  def test_segment_does_not_exist(self): msg = hl7.parse(sample_hl7) self.assertRaises(KeyError, msg.segment, &#34;BAD&#34;)  def test_segments_dict_key(self): msg = hl7.parse(sample_hl7) s = msg[&#34;OBX&#34;] self.assertEqual(len(s), 2) self.assertEqual(s[0][0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]]) self.assertEqual(s[1][0:3], [[&#34;OBX&#34;], [&#34;2&#34;], [&#34;FN&#34;]])  def test_MSH_1_field(self): msg = hl7.parse(sample_hl7) f = msg[&#34;MSH.1&#34;] self.assertEqual(len(f), 1) self.assertEqual(f, &#34;|&#34;)  def test_MSH_2_field(self): msg = hl7.parse(sample_hl7) f = msg[&#34;MSH.2&#34;] self.assertEqual(len(f), 4) self.assertEqual(f, &#34;^~\\\\&#38;&#34;)  def test_get_slice(self): msg = hl7.parse(sample_hl7) s = msg.segments(&#34;OBX&#34;)[0] self.assertIsInstance(s, Segment) self.assertIsInstance(s[0:3], Segment)  def test_ack(self): msg = hl7.parse(sample_hl7) ack = msg.create_ack() self.assertEqual(msg[&#34;MSH.1&#34;], ack[&#34;MSH.1&#34;]) self.assertEqual(msg[&#34;MSH.2&#34;], ack[&#34;MSH.2&#34;]) self.assertEqual(&#34;ACK&#34;, ack[&#34;MSH.9.1.1&#34;]) self.assertEqual(msg[&#34;MSH.9.1.2&#34;], ack[&#34;MSH.9.1.2&#34;]) self.assertEqual(&#34;ACK&#34;, ack[&#34;MSH.9.1.3&#34;]) self.assertNotEqual(msg[&#34;MSH.7&#34;], ack[&#34;MSH.7&#34;]) self.assertNotEqual(msg[&#34;MSH.10&#34;], ack[&#34;MSH.10&#34;]) self.assertEqual(&#34;AA&#34;, ack[&#34;MSA.1&#34;]) self.assertEqual(msg[&#34;MSH.10&#34;], ack[&#34;MSA.2&#34;]) self.assertEqual(20, len(ack[&#34;MSH.10&#34;])) self.assertEqual(msg[&#34;MSH.5&#34;], ack[&#34;MSH.3&#34;]) self.assertEqual(msg[&#34;MSH.6&#34;], ack[&#34;MSH.4&#34;]) self.assertEqual(msg[&#34;MSH.3&#34;], ack[&#34;MSH.5&#34;]) self.assertEqual(msg[&#34;MSH.4&#34;], ack[&#34;MSH.6&#34;]) ack2 = msg.create_ack( ack_code=&#34;AE&#34;, message_id=&#34;testid&#34;, application=&#34;python&#34;, facility=&#34;test&#34; ) self.assertEqual(&#34;AE&#34;, ack2[&#34;MSA.1&#34;]) self.assertEqual(&#34;testid&#34;, ack2[&#34;MSH.10&#34;]) self.assertEqual(&#34;python&#34;, ack2[&#34;MSH.3&#34;]) self.assertEqual(&#34;test&#34;, ack2[&#34;MSH.4&#34;]) self.assertNotEqual(ack[&#34;MSH.10&#34;], ack2[&#34;MSH.10&#34;])"
                }
            },
            {
                "id": 429,
                "attributes": {
                    "id": 429.0,
                    "label": "hl7.tests.test_containers.MessageTest.test_segments",
                    "type": "function",
                    "code": "def test_segments(self): msg = hl7.parse(sample_hl7) s = msg.segments(&#34;OBX&#34;) self.assertEqual(len(s), 2) self.assertIsInstance(s[0], Segment) self.assertEqual(s[0][0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]]) self.assertEqual(s[1][0:3], [[&#34;OBX&#34;], [&#34;2&#34;], [&#34;FN&#34;]])  self.assertIsInstance(s[0][1], Field)",
                    "signature": "def test_segments(self): msg = hl7.parse(sample_hl7) s = msg.segments(&#34;OBX&#34;) self.assertEqual(len(s), 2) self.assertIsInstance(s[0], Segment) self.assertEqual(s[0][0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]]) self.assertEqual(s[1][0:3], [[&#34;OBX&#34;], [&#34;2&#34;], [&#34;FN&#34;]])  self.assertIsInstance(s[0][1], Field)"
                }
            },
            {
                "id": 430,
                "attributes": {
                    "id": 430.0,
                    "label": "hl7.tests.test_containers.MessageTest.test_segments_does_not_exist",
                    "type": "function",
                    "code": "def test_segments_does_not_exist(self): msg = hl7.parse(sample_hl7) self.assertRaises(KeyError, msg.segments, &#34;BAD&#34;)",
                    "signature": "def test_segments_does_not_exist(self): msg = hl7.parse(sample_hl7) self.assertRaises(KeyError, msg.segments, &#34;BAD&#34;)"
                }
            },
            {
                "id": 431,
                "attributes": {
                    "id": 431.0,
                    "label": "hl7.tests.test_containers.MessageTest.test_segment",
                    "type": "function",
                    "code": "def test_segment(self): msg = hl7.parse(sample_hl7) s = msg.segment(&#34;OBX&#34;) self.assertEqual(s[0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]])",
                    "signature": "def test_segment(self): msg = hl7.parse(sample_hl7) s = msg.segment(&#34;OBX&#34;) self.assertEqual(s[0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]])"
                }
            },
            {
                "id": 432,
                "attributes": {
                    "id": 432.0,
                    "label": "hl7.tests.test_containers.MessageTest.test_segment_does_not_exist",
                    "type": "function",
                    "code": "def test_segment_does_not_exist(self): msg = hl7.parse(sample_hl7) self.assertRaises(KeyError, msg.segment, &#34;BAD&#34;)",
                    "signature": "def test_segment_does_not_exist(self): msg = hl7.parse(sample_hl7) self.assertRaises(KeyError, msg.segment, &#34;BAD&#34;)"
                }
            },
            {
                "id": 433,
                "attributes": {
                    "id": 433.0,
                    "label": "hl7.tests.test_containers.MessageTest.test_segments_dict_key",
                    "type": "function",
                    "code": "def test_segments_dict_key(self): msg = hl7.parse(sample_hl7) s = msg[&#34;OBX&#34;] self.assertEqual(len(s), 2) self.assertEqual(s[0][0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]]) self.assertEqual(s[1][0:3], [[&#34;OBX&#34;], [&#34;2&#34;], [&#34;FN&#34;]])",
                    "signature": "def test_segments_dict_key(self): msg = hl7.parse(sample_hl7) s = msg[&#34;OBX&#34;] self.assertEqual(len(s), 2) self.assertEqual(s[0][0:3], [[&#34;OBX&#34;], [&#34;1&#34;], [&#34;SN&#34;]]) self.assertEqual(s[1][0:3], [[&#34;OBX&#34;], [&#34;2&#34;], [&#34;FN&#34;]])"
                }
            },
            {
                "id": 434,
                "attributes": {
                    "id": 434.0,
                    "label": "hl7.tests.test_containers.MessageTest.test_MSH_1_field",
                    "type": "function",
                    "code": "def test_MSH_1_field(self): msg = hl7.parse(sample_hl7) f = msg[&#34;MSH.1&#34;] self.assertEqual(len(f), 1) self.assertEqual(f, &#34;|&#34;)",
                    "signature": "def test_MSH_1_field(self): msg = hl7.parse(sample_hl7) f = msg[&#34;MSH.1&#34;] self.assertEqual(len(f), 1) self.assertEqual(f, &#34;|&#34;)"
                }
            },
            {
                "id": 435,
                "attributes": {
                    "id": 435.0,
                    "label": "hl7.tests.test_containers.MessageTest.test_MSH_2_field",
                    "type": "function",
                    "code": "def test_MSH_2_field(self): msg = hl7.parse(sample_hl7) f = msg[&#34;MSH.2&#34;] self.assertEqual(len(f), 4) self.assertEqual(f, &#34;^~\\\\&#38;&#34;)",
                    "signature": "def test_MSH_2_field(self): msg = hl7.parse(sample_hl7) f = msg[&#34;MSH.2&#34;] self.assertEqual(len(f), 4) self.assertEqual(f, &#34;^~\\\\&#38;&#34;)"
                }
            },
            {
                "id": 436,
                "attributes": {
                    "id": 436.0,
                    "label": "hl7.tests.test_containers.MessageTest.test_get_slice",
                    "type": "function",
                    "code": "def test_get_slice(self): msg = hl7.parse(sample_hl7) s = msg.segments(&#34;OBX&#34;)[0] self.assertIsInstance(s, Segment) self.assertIsInstance(s[0:3], Segment)",
                    "signature": "def test_get_slice(self): msg = hl7.parse(sample_hl7) s = msg.segments(&#34;OBX&#34;)[0] self.assertIsInstance(s, Segment) self.assertIsInstance(s[0:3], Segment)"
                }
            },
            {
                "id": 437,
                "attributes": {
                    "id": 437.0,
                    "label": "hl7.tests.test_containers.MessageTest.test_ack",
                    "type": "function",
                    "code": "def test_ack(self): msg = hl7.parse(sample_hl7) ack = msg.create_ack() self.assertEqual(msg[&#34;MSH.1&#34;], ack[&#34;MSH.1&#34;]) self.assertEqual(msg[&#34;MSH.2&#34;], ack[&#34;MSH.2&#34;]) self.assertEqual(&#34;ACK&#34;, ack[&#34;MSH.9.1.1&#34;]) self.assertEqual(msg[&#34;MSH.9.1.2&#34;], ack[&#34;MSH.9.1.2&#34;]) self.assertEqual(&#34;ACK&#34;, ack[&#34;MSH.9.1.3&#34;]) self.assertNotEqual(msg[&#34;MSH.7&#34;], ack[&#34;MSH.7&#34;]) self.assertNotEqual(msg[&#34;MSH.10&#34;], ack[&#34;MSH.10&#34;]) self.assertEqual(&#34;AA&#34;, ack[&#34;MSA.1&#34;]) self.assertEqual(msg[&#34;MSH.10&#34;], ack[&#34;MSA.2&#34;]) self.assertEqual(20, len(ack[&#34;MSH.10&#34;])) self.assertEqual(msg[&#34;MSH.5&#34;], ack[&#34;MSH.3&#34;]) self.assertEqual(msg[&#34;MSH.6&#34;], ack[&#34;MSH.4&#34;]) self.assertEqual(msg[&#34;MSH.3&#34;], ack[&#34;MSH.5&#34;]) self.assertEqual(msg[&#34;MSH.4&#34;], ack[&#34;MSH.6&#34;]) ack2 = msg.create_ack( ack_code=&#34;AE&#34;, message_id=&#34;testid&#34;, application=&#34;python&#34;, facility=&#34;test&#34; ) self.assertEqual(&#34;AE&#34;, ack2[&#34;MSA.1&#34;]) self.assertEqual(&#34;testid&#34;, ack2[&#34;MSH.10&#34;]) self.assertEqual(&#34;python&#34;, ack2[&#34;MSH.3&#34;]) self.assertEqual(&#34;test&#34;, ack2[&#34;MSH.4&#34;]) self.assertNotEqual(ack[&#34;MSH.10&#34;], ack2[&#34;MSH.10&#34;])",
                    "signature": "def test_ack(self): msg = hl7.parse(sample_hl7) ack = msg.create_ack() self.assertEqual(msg[&#34;MSH.1&#34;], ack[&#34;MSH.1&#34;]) self.assertEqual(msg[&#34;MSH.2&#34;], ack[&#34;MSH.2&#34;]) self.assertEqual(&#34;ACK&#34;, ack[&#34;MSH.9.1.1&#34;]) self.assertEqual(msg[&#34;MSH.9.1.2&#34;], ack[&#34;MSH.9.1.2&#34;]) self.assertEqual(&#34;ACK&#34;, ack[&#34;MSH.9.1.3&#34;]) self.assertNotEqual(msg[&#34;MSH.7&#34;], ack[&#34;MSH.7&#34;]) self.assertNotEqual(msg[&#34;MSH.10&#34;], ack[&#34;MSH.10&#34;]) self.assertEqual(&#34;AA&#34;, ack[&#34;MSA.1&#34;]) self.assertEqual(msg[&#34;MSH.10&#34;], ack[&#34;MSA.2&#34;]) self.assertEqual(20, len(ack[&#34;MSH.10&#34;])) self.assertEqual(msg[&#34;MSH.5&#34;], ack[&#34;MSH.3&#34;]) self.assertEqual(msg[&#34;MSH.6&#34;], ack[&#34;MSH.4&#34;]) self.assertEqual(msg[&#34;MSH.3&#34;], ack[&#34;MSH.5&#34;]) self.assertEqual(msg[&#34;MSH.4&#34;], ack[&#34;MSH.6&#34;]) ack2 = msg.create_ack( ack_code=&#34;AE&#34;, message_id=&#34;testid&#34;, application=&#34;python&#34;, facility=&#34;test&#34; ) self.assertEqual(&#34;AE&#34;, ack2[&#34;MSA.1&#34;]) self.assertEqual(&#34;testid&#34;, ack2[&#34;MSH.10&#34;]) self.assertEqual(&#34;python&#34;, ack2[&#34;MSH.3&#34;]) self.assertEqual(&#34;test&#34;, ack2[&#34;MSH.4&#34;]) self.assertNotEqual(ack[&#34;MSH.10&#34;], ack2[&#34;MSH.10&#34;])"
                }
            },
            {
                "id": 444,
                "attributes": {
                    "id": 444.0,
                    "label": "hl7.tests.test_containers.FactoryTest",
                    "type": "class",
                    "code": "class FactoryTest(TestCase): def test_parse(self): msg = hl7.parse(sample_hl7, factory=TestFactory) self.assertIsInstance(msg, TestMessage) s = msg.segments(&#34;OBX&#34;) self.assertIsInstance(s[0], TestSegment) self.assertIsInstance(s[0](3), TestField) self.assertIsInstance(s[0](3)(1), TestRepetition) self.assertIsInstance(s[0](3)(1)(1), TestComponent) self.assertEqual(&#34;1554-5&#34;, s[0](3)(1)(1)(1))  def test_ack(self): msg = hl7.parse(sample_hl7, factory=TestFactory) ack = msg.create_ack() self.assertIsInstance(ack, TestMessage) self.assertIsInstance(ack(1)(9), TestField) self.assertIsInstance(ack(1)(9)(1), TestRepetition) self.assertIsInstance(ack(1)(9)(1)(2), TestComponent) self.assertEqual(&#34;R01&#34;, ack(1)(9)(1)(2)(1))",
                    "signature": "class FactoryTest(TestCase): def test_parse(self): msg = hl7.parse(sample_hl7, factory=TestFactory) self.assertIsInstance(msg, TestMessage) s = msg.segments(&#34;OBX&#34;) self.assertIsInstance(s[0], TestSegment) self.assertIsInstance(s[0](3), TestField) self.assertIsInstance(s[0](3)(1), TestRepetition) self.assertIsInstance(s[0](3)(1)(1), TestComponent) self.assertEqual(&#34;1554-5&#34;, s[0](3)(1)(1)(1))  def test_ack(self): msg = hl7.parse(sample_hl7, factory=TestFactory) ack = msg.create_ack() self.assertIsInstance(ack, TestMessage) self.assertIsInstance(ack(1)(9), TestField) self.assertIsInstance(ack(1)(9)(1), TestRepetition) self.assertIsInstance(ack(1)(9)(1)(2), TestComponent) self.assertEqual(&#34;R01&#34;, ack(1)(9)(1)(2)(1))"
                }
            },
            {
                "id": 445,
                "attributes": {
                    "id": 445.0,
                    "label": "hl7.tests.test_containers.FactoryTest.test_parse",
                    "type": "function",
                    "code": "def test_parse(self): msg = hl7.parse(sample_hl7, factory=TestFactory) self.assertIsInstance(msg, TestMessage) s = msg.segments(&#34;OBX&#34;) self.assertIsInstance(s[0], TestSegment) self.assertIsInstance(s[0](3), TestField) self.assertIsInstance(s[0](3)(1), TestRepetition) self.assertIsInstance(s[0](3)(1)(1), TestComponent) self.assertEqual(&#34;1554-5&#34;, s[0](3)(1)(1)(1))",
                    "signature": "def test_parse(self): msg = hl7.parse(sample_hl7, factory=TestFactory) self.assertIsInstance(msg, TestMessage) s = msg.segments(&#34;OBX&#34;) self.assertIsInstance(s[0], TestSegment) self.assertIsInstance(s[0](3), TestField) self.assertIsInstance(s[0](3)(1), TestRepetition) self.assertIsInstance(s[0](3)(1)(1), TestComponent) self.assertEqual(&#34;1554-5&#34;, s[0](3)(1)(1)(1))"
                }
            },
            {
                "id": 446,
                "attributes": {
                    "id": 446.0,
                    "label": "hl7.tests.test_containers.FactoryTest.test_ack",
                    "type": "function",
                    "code": "def test_ack(self): msg = hl7.parse(sample_hl7, factory=TestFactory) ack = msg.create_ack() self.assertIsInstance(ack, TestMessage) self.assertIsInstance(ack(1)(9), TestField) self.assertIsInstance(ack(1)(9)(1), TestRepetition) self.assertIsInstance(ack(1)(9)(1)(2), TestComponent) self.assertEqual(&#34;R01&#34;, ack(1)(9)(1)(2)(1))",
                    "signature": "def test_ack(self): msg = hl7.parse(sample_hl7, factory=TestFactory) ack = msg.create_ack() self.assertIsInstance(ack, TestMessage) self.assertIsInstance(ack(1)(9), TestField) self.assertIsInstance(ack(1)(9)(1), TestRepetition) self.assertIsInstance(ack(1)(9)(1)(2), TestComponent) self.assertEqual(&#34;R01&#34;, ack(1)(9)(1)(2)(1))"
                }
            }
        ]
    },
    "2": {
        "nodes": [
            {
                "id": 151,
                "attributes": {
                    "id": 151.0,
                    "label": "hl7.tests.backports.unittest.case",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 152,
                "attributes": {
                    "id": 152.0,
                    "label": "hl7.tests.backports.unittest.case.SkipTest",
                    "type": "class",
                    "code": "class SkipTest(Exception): &#34;&#34;&#34; Raise this exception in a test to skip it.  Usually you can use TestCase.skipTest() or one of the skipping decorators instead of raising this directly. &#34;&#34;&#34;",
                    "signature": "class SkipTest(Exception): &#34;&#34;&#34; Raise this exception in a test to skip it.  Usually you can use TestCase.skipTest() or one of the skipping decorators instead of raising this directly. &#34;&#34;&#34;"
                }
            },
            {
                "id": 153,
                "attributes": {
                    "id": 153.0,
                    "label": "hl7.tests.backports.unittest.case._ShouldStop",
                    "type": "class",
                    "code": "class _ShouldStop(Exception): &#34;&#34;&#34; The test should stop. &#34;&#34;&#34;",
                    "signature": "class _ShouldStop(Exception): &#34;&#34;&#34; The test should stop. &#34;&#34;&#34;"
                }
            },
            {
                "id": 154,
                "attributes": {
                    "id": 154.0,
                    "label": "hl7.tests.backports.unittest.case._UnexpectedSuccess",
                    "type": "class",
                    "code": "class _UnexpectedSuccess(Exception): &#34;&#34;&#34; The test was supposed to fail, but it didn't! &#34;&#34;&#34;",
                    "signature": "class _UnexpectedSuccess(Exception): &#34;&#34;&#34; The test was supposed to fail, but it didn't! &#34;&#34;&#34;"
                }
            },
            {
                "id": 158,
                "attributes": {
                    "id": 158.0,
                    "label": "hl7.tests.backports.unittest.case._id",
                    "type": "function",
                    "code": "def _id(obj): return obj",
                    "signature": "def _id(obj): return obj"
                }
            },
            {
                "id": 159,
                "attributes": {
                    "id": 159.0,
                    "label": "hl7.tests.backports.unittest.case.addModuleCleanup",
                    "type": "function",
                    "code": "def addModuleCleanup(function, *args, **kwargs): &#34;&#34;&#34;Same as addCleanup, except the cleanup items are called even if setUpModule fails (unlike tearDownModule).&#34;&#34;&#34; _module_cleanups.append((function, args, kwargs))",
                    "signature": "def addModuleCleanup(function, *args, **kwargs): &#34;&#34;&#34;Same as addCleanup, except the cleanup items are called even if setUpModule fails (unlike tearDownModule).&#34;&#34;&#34; _module_cleanups.append((function, args, kwargs))"
                }
            },
            {
                "id": 160,
                "attributes": {
                    "id": 160.0,
                    "label": "hl7.tests.backports.unittest.case.doModuleCleanups",
                    "type": "function",
                    "code": "def doModuleCleanups(): &#34;&#34;&#34;Execute all module cleanup functions. Normally called for you after tearDownModule.&#34;&#34;&#34; exceptions = [] while _module_cleanups: function, args, kwargs = _module_cleanups.pop() try: function(*args, **kwargs) except Exception as exc: exceptions.append(exc) if exceptions: # Swallows all but first exception. If a multi-exception handler # gets written we should use that here instead. raise exceptions[0]",
                    "signature": "def doModuleCleanups(): &#34;&#34;&#34;Execute all module cleanup functions. Normally called for you after tearDownModule.&#34;&#34;&#34; exceptions = [] while _module_cleanups: function, args, kwargs = _module_cleanups.pop() try: function(*args, **kwargs) except Exception as exc: exceptions.append(exc) if exceptions: # Swallows all but first exception. If a multi-exception handler # gets written we should use that here instead. raise exceptions[0]"
                }
            },
            {
                "id": 161,
                "attributes": {
                    "id": 161.0,
                    "label": "hl7.tests.backports.unittest.case.skip",
                    "type": "function",
                    "code": "def skip(reason): &#34;&#34;&#34; Unconditionally skip a test. &#34;&#34;&#34;  def decorator(test_item): if not isinstance(test_item, type):  @functools.wraps(test_item) def skip_wrapper(*args, **kwargs): raise SkipTest(reason)  test_item = skip_wrapper  test_item.__unittest_skip__ = True test_item.__unittest_skip_why__ = reason return test_item  if isinstance(reason, types.FunctionType): test_item = reason reason = &#34;&#34; return decorator(test_item) return decorator",
                    "signature": "def skip(reason): &#34;&#34;&#34; Unconditionally skip a test. &#34;&#34;&#34;  def decorator(test_item): if not isinstance(test_item, type):  @functools.wraps(test_item) def skip_wrapper(*args, **kwargs): raise SkipTest(reason)  test_item = skip_wrapper  test_item.__unittest_skip__ = True test_item.__unittest_skip_why__ = reason return test_item  if isinstance(reason, types.FunctionType): test_item = reason reason = &#34;&#34; return decorator(test_item) return decorator"
                }
            },
            {
                "id": 162,
                "attributes": {
                    "id": 162.0,
                    "label": "hl7.tests.backports.unittest.case.skip.decorator",
                    "type": "function",
                    "code": "def decorator(test_item): if not isinstance(test_item, type):  @functools.wraps(test_item) def skip_wrapper(*args, **kwargs): raise SkipTest(reason)  test_item = skip_wrapper  test_item.__unittest_skip__ = True test_item.__unittest_skip_why__ = reason return test_item",
                    "signature": "def decorator(test_item): if not isinstance(test_item, type):  @functools.wraps(test_item) def skip_wrapper(*args, **kwargs): raise SkipTest(reason)  test_item = skip_wrapper  test_item.__unittest_skip__ = True test_item.__unittest_skip_why__ = reason return test_item"
                }
            },
            {
                "id": 163,
                "attributes": {
                    "id": 163.0,
                    "label": "hl7.tests.backports.unittest.case.skip.decorator.skip_wrapper",
                    "type": "function",
                    "code": "def skip_wrapper(*args, **kwargs): raise SkipTest(reason)",
                    "signature": "def skip_wrapper(*args, **kwargs): raise SkipTest(reason)"
                }
            },
            {
                "id": 164,
                "attributes": {
                    "id": 164.0,
                    "label": "hl7.tests.backports.unittest.case.skipIf",
                    "type": "function",
                    "code": "def skipIf(condition, reason): &#34;&#34;&#34; Skip a test if the condition is true. &#34;&#34;&#34; if condition: return skip(reason) return _id",
                    "signature": "def skipIf(condition, reason): &#34;&#34;&#34; Skip a test if the condition is true. &#34;&#34;&#34; if condition: return skip(reason) return _id"
                }
            },
            {
                "id": 165,
                "attributes": {
                    "id": 165.0,
                    "label": "hl7.tests.backports.unittest.case.skipUnless",
                    "type": "function",
                    "code": "def skipUnless(condition, reason): &#34;&#34;&#34; Skip a test unless the condition is true. &#34;&#34;&#34; if not condition: return skip(reason) return _id",
                    "signature": "def skipUnless(condition, reason): &#34;&#34;&#34; Skip a test unless the condition is true. &#34;&#34;&#34; if not condition: return skip(reason) return _id"
                }
            },
            {
                "id": 166,
                "attributes": {
                    "id": 166.0,
                    "label": "hl7.tests.backports.unittest.case.expectedFailure",
                    "type": "function",
                    "code": "def expectedFailure(test_item): test_item.__unittest_expecting_failure__ = True return test_item",
                    "signature": "def expectedFailure(test_item): test_item.__unittest_expecting_failure__ = True return test_item"
                }
            },
            {
                "id": 167,
                "attributes": {
                    "id": 167.0,
                    "label": "hl7.tests.backports.unittest.case._is_subtype",
                    "type": "function",
                    "code": "def _is_subtype(expected, basetype): if isinstance(expected, tuple): return all(_is_subtype(e, basetype) for e in expected) return isinstance(expected, type) and issubclass(expected, basetype)",
                    "signature": "def _is_subtype(expected, basetype): if isinstance(expected, tuple): return all(_is_subtype(e, basetype) for e in expected) return isinstance(expected, type) and issubclass(expected, basetype)"
                }
            },
            {
                "id": 168,
                "attributes": {
                    "id": 168.0,
                    "label": "hl7.tests.backports.unittest.case._BaseTestCaseContext",
                    "type": "class",
                    "code": "class _BaseTestCaseContext: def __init__(self, test_case): self.test_case = test_case  def _raiseFailure(self, standardMsg): msg = self.test_case._formatMessage(self.msg, standardMsg) raise self.test_case.failureException(msg)",
                    "signature": "class _BaseTestCaseContext: def __init__(self, test_case): self.test_case = test_case  def _raiseFailure(self, standardMsg): msg = self.test_case._formatMessage(self.msg, standardMsg) raise self.test_case.failureException(msg)"
                }
            },
            {
                "id": 169,
                "attributes": {
                    "id": 169.0,
                    "label": "hl7.tests.backports.unittest.case._BaseTestCaseContext.__init__",
                    "type": "function",
                    "code": "def __init__(self, test_case): self.test_case = test_case",
                    "signature": "def __init__(self, test_case): self.test_case = test_case"
                }
            },
            {
                "id": 170,
                "attributes": {
                    "id": 170.0,
                    "label": "hl7.tests.backports.unittest.case._BaseTestCaseContext._raiseFailure",
                    "type": "function",
                    "code": "def _raiseFailure(self, standardMsg): msg = self.test_case._formatMessage(self.msg, standardMsg) raise self.test_case.failureException(msg)",
                    "signature": "def _raiseFailure(self, standardMsg): msg = self.test_case._formatMessage(self.msg, standardMsg) raise self.test_case.failureException(msg)"
                }
            },
            {
                "id": 171,
                "attributes": {
                    "id": 171.0,
                    "label": "hl7.tests.backports.unittest.case._AssertRaisesBaseContext",
                    "type": "class",
                    "code": "class _AssertRaisesBaseContext(_BaseTestCaseContext): def __init__(self, expected, test_case, expected_regex=None): _BaseTestCaseContext.__init__(self, test_case) self.expected = expected self.test_case = test_case if expected_regex is not None: expected_regex = re.compile(expected_regex) self.expected_regex = expected_regex self.obj_name = None self.msg = None  def handle(self, name, args, kwargs): &#34;&#34;&#34; If args is empty, assertRaises/Warns is being used as a context manager, so check for a 'msg' kwarg and return self. If args is not empty, call a callable passing positional and keyword arguments. &#34;&#34;&#34; try: if not _is_subtype(self.expected, self._base_type): raise TypeError(&#34;%s() arg 1 must be %s&#34; % (name, self._base_type_str)) if not args: self.msg = kwargs.pop(&#34;msg&#34;, None) if kwargs: raise TypeError( &#34;%r is an invalid keyword argument for &#34; &#34;this function&#34; % (next(iter(kwargs)),) ) return self  callable_obj, *args = args try: self.obj_name = callable_obj.__name__ except AttributeError: self.obj_name = str(callable_obj) with self: callable_obj(*args, **kwargs) finally: # bpo-23890: manually break a reference cycle self = None",
                    "signature": "class _AssertRaisesBaseContext(_BaseTestCaseContext): def __init__(self, expected, test_case, expected_regex=None): _BaseTestCaseContext.__init__(self, test_case) self.expected = expected self.test_case = test_case if expected_regex is not None: expected_regex = re.compile(expected_regex) self.expected_regex = expected_regex self.obj_name = None self.msg = None  def handle(self, name, args, kwargs): &#34;&#34;&#34; If args is empty, assertRaises/Warns is being used as a context manager, so check for a 'msg' kwarg and return self. If args is not empty, call a callable passing positional and keyword arguments. &#34;&#34;&#34; try: if not _is_subtype(self.expected, self._base_type): raise TypeError(&#34;%s() arg 1 must be %s&#34; % (name, self._base_type_str)) if not args: self.msg = kwargs.pop(&#34;msg&#34;, None) if kwargs: raise TypeError( &#34;%r is an invalid keyword argument for &#34; &#34;this function&#34; % (next(iter(kwargs)),) ) return self  callable_obj, *args = args try: self.obj_name = callable_obj.__name__ except AttributeError: self.obj_name = str(callable_obj) with self: callable_obj(*args, **kwargs) finally: # bpo-23890: manually break a reference cycle self = None"
                }
            },
            {
                "id": 172,
                "attributes": {
                    "id": 172.0,
                    "label": "hl7.tests.backports.unittest.case._AssertRaisesBaseContext.__init__",
                    "type": "function",
                    "code": "def __init__(self, expected, test_case, expected_regex=None): _BaseTestCaseContext.__init__(self, test_case) self.expected = expected self.test_case = test_case if expected_regex is not None: expected_regex = re.compile(expected_regex) self.expected_regex = expected_regex self.obj_name = None self.msg = None",
                    "signature": "def __init__(self, expected, test_case, expected_regex=None): _BaseTestCaseContext.__init__(self, test_case) self.expected = expected self.test_case = test_case if expected_regex is not None: expected_regex = re.compile(expected_regex) self.expected_regex = expected_regex self.obj_name = None self.msg = None"
                }
            },
            {
                "id": 173,
                "attributes": {
                    "id": 173.0,
                    "label": "hl7.tests.backports.unittest.case._AssertRaisesBaseContext.handle",
                    "type": "function",
                    "code": "def handle(self, name, args, kwargs): &#34;&#34;&#34; If args is empty, assertRaises/Warns is being used as a context manager, so check for a 'msg' kwarg and return self. If args is not empty, call a callable passing positional and keyword arguments. &#34;&#34;&#34; try: if not _is_subtype(self.expected, self._base_type): raise TypeError(&#34;%s() arg 1 must be %s&#34; % (name, self._base_type_str)) if not args: self.msg = kwargs.pop(&#34;msg&#34;, None) if kwargs: raise TypeError( &#34;%r is an invalid keyword argument for &#34; &#34;this function&#34; % (next(iter(kwargs)),) ) return self  callable_obj, *args = args try: self.obj_name = callable_obj.__name__ except AttributeError: self.obj_name = str(callable_obj) with self: callable_obj(*args, **kwargs) finally: # bpo-23890: manually break a reference cycle self = None",
                    "signature": "def handle(self, name, args, kwargs): &#34;&#34;&#34; If args is empty, assertRaises/Warns is being used as a context manager, so check for a 'msg' kwarg and return self. If args is not empty, call a callable passing positional and keyword arguments. &#34;&#34;&#34; try: if not _is_subtype(self.expected, self._base_type): raise TypeError(&#34;%s() arg 1 must be %s&#34; % (name, self._base_type_str)) if not args: self.msg = kwargs.pop(&#34;msg&#34;, None) if kwargs: raise TypeError( &#34;%r is an invalid keyword argument for &#34; &#34;this function&#34; % (next(iter(kwargs)),) ) return self  callable_obj, *args = args try: self.obj_name = callable_obj.__name__ except AttributeError: self.obj_name = str(callable_obj) with self: callable_obj(*args, **kwargs) finally: # bpo-23890: manually break a reference cycle self = None"
                }
            },
            {
                "id": 174,
                "attributes": {
                    "id": 174.0,
                    "label": "hl7.tests.backports.unittest.case._AssertRaisesContext",
                    "type": "class",
                    "code": "class _AssertRaisesContext(_AssertRaisesBaseContext): &#34;&#34;&#34;A context manager used to implement TestCase.assertRaises* methods.&#34;&#34;&#34;  _base_type = BaseException _base_type_str = &#34;an exception type or tuple of exception types&#34;  def __enter__(self): return self  def __exit__(self, exc_type, exc_value, tb): if exc_type is None: try: exc_name = self.expected.__name__ except AttributeError: exc_name = str(self.expected) if self.obj_name: self._raiseFailure( &#34;{} not raised by {}&#34;.format(exc_name, self.obj_name) ) else: self._raiseFailure(&#34;{} not raised&#34;.format(exc_name)) else: traceback.clear_frames(tb) if not issubclass(exc_type, self.expected): # let unexpected exceptions pass through return False # store exception, without traceback, for later retrieval self.exception = exc_value.with_traceback(None) if self.expected_regex is None: return True  expected_regex = self.expected_regex if not expected_regex.search(str(exc_value)): self._raiseFailure( '&#34;{}&#34; does not match &#34;{}&#34;'.format( expected_regex.pattern, str(exc_value) ) ) return True",
                    "signature": "class _AssertRaisesContext(_AssertRaisesBaseContext): &#34;&#34;&#34;A context manager used to implement TestCase.assertRaises* methods.&#34;&#34;&#34;  _base_type = BaseException _base_type_str = &#34;an exception type or tuple of exception types&#34;  def __enter__(self): return self  def __exit__(self, exc_type, exc_value, tb): if exc_type is None: try: exc_name = self.expected.__name__ except AttributeError: exc_name = str(self.expected) if self.obj_name: self._raiseFailure( &#34;{} not raised by {}&#34;.format(exc_name, self.obj_name) ) else: self._raiseFailure(&#34;{} not raised&#34;.format(exc_name)) else: traceback.clear_frames(tb) if not issubclass(exc_type, self.expected): # let unexpected exceptions pass through return False # store exception, without traceback, for later retrieval self.exception = exc_value.with_traceback(None) if self.expected_regex is None: return True  expected_regex = self.expected_regex if not expected_regex.search(str(exc_value)): self._raiseFailure( '&#34;{}&#34; does not match &#34;{}&#34;'.format( expected_regex.pattern, str(exc_value) ) ) return True"
                }
            },
            {
                "id": 175,
                "attributes": {
                    "id": 175.0,
                    "label": "hl7.tests.backports.unittest.case._AssertRaisesContext.__enter__",
                    "type": "function",
                    "code": "def __enter__(self): return self",
                    "signature": "def __enter__(self): return self"
                }
            },
            {
                "id": 176,
                "attributes": {
                    "id": 176.0,
                    "label": "hl7.tests.backports.unittest.case._AssertRaisesContext.__exit__",
                    "type": "function",
                    "code": "def __exit__(self, exc_type, exc_value, tb): if exc_type is None: try: exc_name = self.expected.__name__ except AttributeError: exc_name = str(self.expected) if self.obj_name: self._raiseFailure( &#34;{} not raised by {}&#34;.format(exc_name, self.obj_name) ) else: self._raiseFailure(&#34;{} not raised&#34;.format(exc_name)) else: traceback.clear_frames(tb) if not issubclass(exc_type, self.expected): # let unexpected exceptions pass through return False # store exception, without traceback, for later retrieval self.exception = exc_value.with_traceback(None) if self.expected_regex is None: return True  expected_regex = self.expected_regex if not expected_regex.search(str(exc_value)): self._raiseFailure( '&#34;{}&#34; does not match &#34;{}&#34;'.format( expected_regex.pattern, str(exc_value) ) ) return True",
                    "signature": "def __exit__(self, exc_type, exc_value, tb): if exc_type is None: try: exc_name = self.expected.__name__ except AttributeError: exc_name = str(self.expected) if self.obj_name: self._raiseFailure( &#34;{} not raised by {}&#34;.format(exc_name, self.obj_name) ) else: self._raiseFailure(&#34;{} not raised&#34;.format(exc_name)) else: traceback.clear_frames(tb) if not issubclass(exc_type, self.expected): # let unexpected exceptions pass through return False # store exception, without traceback, for later retrieval self.exception = exc_value.with_traceback(None) if self.expected_regex is None: return True  expected_regex = self.expected_regex if not expected_regex.search(str(exc_value)): self._raiseFailure( '&#34;{}&#34; does not match &#34;{}&#34;'.format( expected_regex.pattern, str(exc_value) ) ) return True"
                }
            },
            {
                "id": 177,
                "attributes": {
                    "id": 177.0,
                    "label": "hl7.tests.backports.unittest.case._AssertWarnsContext",
                    "type": "class",
                    "code": "class _AssertWarnsContext(_AssertRaisesBaseContext): &#34;&#34;&#34;A context manager used to implement TestCase.assertWarns* methods.&#34;&#34;&#34;  _base_type = Warning _base_type_str = &#34;a warning type or tuple of warning types&#34;  def __enter__(self): # The __warningregistry__'s need to be in a pristine state for tests # to work properly. for v in list(sys.modules.values()): if getattr(v, &#34;__warningregistry__&#34;, None): v.__warningregistry__ = {} self.warnings_manager = warnings.catch_warnings(record=True) self.warnings = self.warnings_manager.__enter__() warnings.simplefilter(&#34;always&#34;, self.expected) return self  def __exit__(self, exc_type, exc_value, tb): self.warnings_manager.__exit__(exc_type, exc_value, tb) if exc_type is not None: # let unexpected exceptions pass through return try: exc_name = self.expected.__name__ except AttributeError: exc_name = str(self.expected) first_matching = None for m in self.warnings: w = m.message if not isinstance(w, self.expected): continue if first_matching is None: first_matching = w if self.expected_regex is not None and not self.expected_regex.search( str(w) ): continue # store warning for later retrieval self.warning = w self.filename = m.filename self.lineno = m.lineno return # Now we simply try to choose a helpful failure message if first_matching is not None: self._raiseFailure( '&#34;{}&#34; does not match &#34;{}&#34;'.format( self.expected_regex.pattern, str(first_matching) ) ) if self.obj_name: self._raiseFailure(&#34;{} not triggered by {}&#34;.format(exc_name, self.obj_name)) else: self._raiseFailure(&#34;{} not triggered&#34;.format(exc_name))",
                    "signature": "class _AssertWarnsContext(_AssertRaisesBaseContext): &#34;&#34;&#34;A context manager used to implement TestCase.assertWarns* methods.&#34;&#34;&#34;  _base_type = Warning _base_type_str = &#34;a warning type or tuple of warning types&#34;  def __enter__(self): # The __warningregistry__'s need to be in a pristine state for tests # to work properly. for v in list(sys.modules.values()): if getattr(v, &#34;__warningregistry__&#34;, None): v.__warningregistry__ = {} self.warnings_manager = warnings.catch_warnings(record=True) self.warnings = self.warnings_manager.__enter__() warnings.simplefilter(&#34;always&#34;, self.expected) return self  def __exit__(self, exc_type, exc_value, tb): self.warnings_manager.__exit__(exc_type, exc_value, tb) if exc_type is not None: # let unexpected exceptions pass through return try: exc_name = self.expected.__name__ except AttributeError: exc_name = str(self.expected) first_matching = None for m in self.warnings: w = m.message if not isinstance(w, self.expected): continue if first_matching is None: first_matching = w if self.expected_regex is not None and not self.expected_regex.search( str(w) ): continue # store warning for later retrieval self.warning = w self.filename = m.filename self.lineno = m.lineno return # Now we simply try to choose a helpful failure message if first_matching is not None: self._raiseFailure( '&#34;{}&#34; does not match &#34;{}&#34;'.format( self.expected_regex.pattern, str(first_matching) ) ) if self.obj_name: self._raiseFailure(&#34;{} not triggered by {}&#34;.format(exc_name, self.obj_name)) else: self._raiseFailure(&#34;{} not triggered&#34;.format(exc_name))"
                }
            },
            {
                "id": 178,
                "attributes": {
                    "id": 178.0,
                    "label": "hl7.tests.backports.unittest.case._AssertWarnsContext.__enter__",
                    "type": "function",
                    "code": "def __enter__(self): # The __warningregistry__'s need to be in a pristine state for tests # to work properly. for v in list(sys.modules.values()): if getattr(v, &#34;__warningregistry__&#34;, None): v.__warningregistry__ = {} self.warnings_manager = warnings.catch_warnings(record=True) self.warnings = self.warnings_manager.__enter__() warnings.simplefilter(&#34;always&#34;, self.expected) return self",
                    "signature": "def __enter__(self): # The __warningregistry__'s need to be in a pristine state for tests # to work properly. for v in list(sys.modules.values()): if getattr(v, &#34;__warningregistry__&#34;, None): v.__warningregistry__ = {} self.warnings_manager = warnings.catch_warnings(record=True) self.warnings = self.warnings_manager.__enter__() warnings.simplefilter(&#34;always&#34;, self.expected) return self"
                }
            },
            {
                "id": 179,
                "attributes": {
                    "id": 179.0,
                    "label": "hl7.tests.backports.unittest.case._AssertWarnsContext.__exit__",
                    "type": "function",
                    "code": "def __exit__(self, exc_type, exc_value, tb): self.warnings_manager.__exit__(exc_type, exc_value, tb) if exc_type is not None: # let unexpected exceptions pass through return try: exc_name = self.expected.__name__ except AttributeError: exc_name = str(self.expected) first_matching = None for m in self.warnings: w = m.message if not isinstance(w, self.expected): continue if first_matching is None: first_matching = w if self.expected_regex is not None and not self.expected_regex.search( str(w) ): continue # store warning for later retrieval self.warning = w self.filename = m.filename self.lineno = m.lineno return # Now we simply try to choose a helpful failure message if first_matching is not None: self._raiseFailure( '&#34;{}&#34; does not match &#34;{}&#34;'.format( self.expected_regex.pattern, str(first_matching) ) ) if self.obj_name: self._raiseFailure(&#34;{} not triggered by {}&#34;.format(exc_name, self.obj_name)) else: self._raiseFailure(&#34;{} not triggered&#34;.format(exc_name))",
                    "signature": "def __exit__(self, exc_type, exc_value, tb): self.warnings_manager.__exit__(exc_type, exc_value, tb) if exc_type is not None: # let unexpected exceptions pass through return try: exc_name = self.expected.__name__ except AttributeError: exc_name = str(self.expected) first_matching = None for m in self.warnings: w = m.message if not isinstance(w, self.expected): continue if first_matching is None: first_matching = w if self.expected_regex is not None and not self.expected_regex.search( str(w) ): continue # store warning for later retrieval self.warning = w self.filename = m.filename self.lineno = m.lineno return # Now we simply try to choose a helpful failure message if first_matching is not None: self._raiseFailure( '&#34;{}&#34; does not match &#34;{}&#34;'.format( self.expected_regex.pattern, str(first_matching) ) ) if self.obj_name: self._raiseFailure(&#34;{} not triggered by {}&#34;.format(exc_name, self.obj_name)) else: self._raiseFailure(&#34;{} not triggered&#34;.format(exc_name))"
                }
            },
            {
                "id": 180,
                "attributes": {
                    "id": 180.0,
                    "label": "hl7.tests.backports.unittest.case._CapturingHandler",
                    "type": "class",
                    "code": "class _CapturingHandler(logging.Handler): &#34;&#34;&#34; A logging handler capturing all (raw and formatted) logging output. &#34;&#34;&#34;  def __init__(self): logging.Handler.__init__(self) self.watcher = _LoggingWatcher([], [])  def flush(self): pass  def emit(self, record): self.watcher.records.append(record) msg = self.format(record) self.watcher.output.append(msg)",
                    "signature": "class _CapturingHandler(logging.Handler): &#34;&#34;&#34; A logging handler capturing all (raw and formatted) logging output. &#34;&#34;&#34;  def __init__(self): logging.Handler.__init__(self) self.watcher = _LoggingWatcher([], [])  def flush(self): pass  def emit(self, record): self.watcher.records.append(record) msg = self.format(record) self.watcher.output.append(msg)"
                }
            },
            {
                "id": 181,
                "attributes": {
                    "id": 181.0,
                    "label": "hl7.tests.backports.unittest.case._CapturingHandler.__init__",
                    "type": "function",
                    "code": "def __init__(self): logging.Handler.__init__(self) self.watcher = _LoggingWatcher([], [])",
                    "signature": "def __init__(self): logging.Handler.__init__(self) self.watcher = _LoggingWatcher([], [])"
                }
            },
            {
                "id": 182,
                "attributes": {
                    "id": 182.0,
                    "label": "hl7.tests.backports.unittest.case._CapturingHandler.flush",
                    "type": "function",
                    "code": "def flush(self): pass",
                    "signature": "def flush(self): pass"
                }
            },
            {
                "id": 183,
                "attributes": {
                    "id": 183.0,
                    "label": "hl7.tests.backports.unittest.case._CapturingHandler.emit",
                    "type": "function",
                    "code": "def emit(self, record): self.watcher.records.append(record) msg = self.format(record) self.watcher.output.append(msg)",
                    "signature": "def emit(self, record): self.watcher.records.append(record) msg = self.format(record) self.watcher.output.append(msg)"
                }
            },
            {
                "id": 184,
                "attributes": {
                    "id": 184.0,
                    "label": "hl7.tests.backports.unittest.case._AssertLogsContext",
                    "type": "class",
                    "code": "class _AssertLogsContext(_BaseTestCaseContext): &#34;&#34;&#34;A context manager used to implement TestCase.assertLogs().&#34;&#34;&#34;  LOGGING_FORMAT = &#34;%(levelname)s:%(name)s:%(message)s&#34;  def __init__(self, test_case, logger_name, level): _BaseTestCaseContext.__init__(self, test_case) self.logger_name = logger_name if level: self.level = logging._nameToLevel.get(level, level) else: self.level = logging.INFO self.msg = None  def __enter__(self): if isinstance(self.logger_name, logging.Logger): logger = self.logger = self.logger_name else: logger = self.logger = logging.getLogger(self.logger_name) formatter = logging.Formatter(self.LOGGING_FORMAT) handler = _CapturingHandler() handler.setFormatter(formatter) self.watcher = handler.watcher self.old_handlers = logger.handlers[:] self.old_level = logger.level self.old_propagate = logger.propagate logger.handlers = [handler] logger.setLevel(self.level) logger.propagate = False return handler.watcher  def __exit__(self, exc_type, exc_value, tb): self.logger.handlers = self.old_handlers self.logger.propagate = self.old_propagate self.logger.setLevel(self.old_level) if exc_type is not None: # let unexpected exceptions pass through return False if len(self.watcher.records) == 0: self._raiseFailure( &#34;no logs of level {} or higher triggered on {}&#34;.format( logging.getLevelName(self.level), self.logger.name ) )",
                    "signature": "class _AssertLogsContext(_BaseTestCaseContext): &#34;&#34;&#34;A context manager used to implement TestCase.assertLogs().&#34;&#34;&#34;  LOGGING_FORMAT = &#34;%(levelname)s:%(name)s:%(message)s&#34;  def __init__(self, test_case, logger_name, level): _BaseTestCaseContext.__init__(self, test_case) self.logger_name = logger_name if level: self.level = logging._nameToLevel.get(level, level) else: self.level = logging.INFO self.msg = None  def __enter__(self): if isinstance(self.logger_name, logging.Logger): logger = self.logger = self.logger_name else: logger = self.logger = logging.getLogger(self.logger_name) formatter = logging.Formatter(self.LOGGING_FORMAT) handler = _CapturingHandler() handler.setFormatter(formatter) self.watcher = handler.watcher self.old_handlers = logger.handlers[:] self.old_level = logger.level self.old_propagate = logger.propagate logger.handlers = [handler] logger.setLevel(self.level) logger.propagate = False return handler.watcher  def __exit__(self, exc_type, exc_value, tb): self.logger.handlers = self.old_handlers self.logger.propagate = self.old_propagate self.logger.setLevel(self.old_level) if exc_type is not None: # let unexpected exceptions pass through return False if len(self.watcher.records) == 0: self._raiseFailure( &#34;no logs of level {} or higher triggered on {}&#34;.format( logging.getLevelName(self.level), self.logger.name ) )"
                }
            },
            {
                "id": 185,
                "attributes": {
                    "id": 185.0,
                    "label": "hl7.tests.backports.unittest.case._AssertLogsContext.__init__",
                    "type": "function",
                    "code": "def __init__(self, test_case, logger_name, level): _BaseTestCaseContext.__init__(self, test_case) self.logger_name = logger_name if level: self.level = logging._nameToLevel.get(level, level) else: self.level = logging.INFO self.msg = None",
                    "signature": "def __init__(self, test_case, logger_name, level): _BaseTestCaseContext.__init__(self, test_case) self.logger_name = logger_name if level: self.level = logging._nameToLevel.get(level, level) else: self.level = logging.INFO self.msg = None"
                }
            },
            {
                "id": 186,
                "attributes": {
                    "id": 186.0,
                    "label": "hl7.tests.backports.unittest.case._AssertLogsContext.__enter__",
                    "type": "function",
                    "code": "def __enter__(self): if isinstance(self.logger_name, logging.Logger): logger = self.logger = self.logger_name else: logger = self.logger = logging.getLogger(self.logger_name) formatter = logging.Formatter(self.LOGGING_FORMAT) handler = _CapturingHandler() handler.setFormatter(formatter) self.watcher = handler.watcher self.old_handlers = logger.handlers[:] self.old_level = logger.level self.old_propagate = logger.propagate logger.handlers = [handler] logger.setLevel(self.level) logger.propagate = False return handler.watcher",
                    "signature": "def __enter__(self): if isinstance(self.logger_name, logging.Logger): logger = self.logger = self.logger_name else: logger = self.logger = logging.getLogger(self.logger_name) formatter = logging.Formatter(self.LOGGING_FORMAT) handler = _CapturingHandler() handler.setFormatter(formatter) self.watcher = handler.watcher self.old_handlers = logger.handlers[:] self.old_level = logger.level self.old_propagate = logger.propagate logger.handlers = [handler] logger.setLevel(self.level) logger.propagate = False return handler.watcher"
                }
            },
            {
                "id": 187,
                "attributes": {
                    "id": 187.0,
                    "label": "hl7.tests.backports.unittest.case._AssertLogsContext.__exit__",
                    "type": "function",
                    "code": "def __exit__(self, exc_type, exc_value, tb): self.logger.handlers = self.old_handlers self.logger.propagate = self.old_propagate self.logger.setLevel(self.old_level) if exc_type is not None: # let unexpected exceptions pass through return False if len(self.watcher.records) == 0: self._raiseFailure( &#34;no logs of level {} or higher triggered on {}&#34;.format( logging.getLevelName(self.level), self.logger.name ) )",
                    "signature": "def __exit__(self, exc_type, exc_value, tb): self.logger.handlers = self.old_handlers self.logger.propagate = self.old_propagate self.logger.setLevel(self.old_level) if exc_type is not None: # let unexpected exceptions pass through return False if len(self.watcher.records) == 0: self._raiseFailure( &#34;no logs of level {} or higher triggered on {}&#34;.format( logging.getLevelName(self.level), self.logger.name ) )"
                }
            },
            {
                "id": 221,
                "attributes": {
                    "id": 221.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.skipTest",
                    "type": "function",
                    "code": "def skipTest(self, reason): &#34;&#34;&#34;Skip this test.&#34;&#34;&#34; raise SkipTest(reason)",
                    "signature": "def skipTest(self, reason): &#34;&#34;&#34;Skip this test.&#34;&#34;&#34; raise SkipTest(reason)"
                }
            },
            {
                "id": 227,
                "attributes": {
                    "id": 227.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertWarns",
                    "type": "function",
                    "code": "def assertWarns(self, expected_warning, *args, **kwargs): &#34;&#34;&#34;Fail unless a warning of class warnClass is triggered by the callable when invoked with specified positional and keyword arguments.  If a different type of warning is triggered, it will not be handled: depending on the other warning filtering rules in effect, it might be silenced, printed out, or raised as an exception.  If called with the callable and arguments omitted, will return a context object used like this::  with self.assertWarns(SomeWarning): do_something()  An optional keyword argument 'msg' can be provided when assertWarns is used as a context object.  The context manager keeps a reference to the first matching warning as the 'warning' attribute; similarly, the 'filename' and 'lineno' attributes give you information about the line of Python code from which the warning was triggered. This allows you to inspect the warning after the assertion::  with self.assertWarns(SomeWarning) as cm: do_something() the_warning = cm.warning self.assertEqual(the_warning.some_attribute, 147) &#34;&#34;&#34; context = _AssertWarnsContext(expected_warning, self) return context.handle(&#34;assertWarns&#34;, args, kwargs)",
                    "signature": "def assertWarns(self, expected_warning, *args, **kwargs): &#34;&#34;&#34;Fail unless a warning of class warnClass is triggered by the callable when invoked with specified positional and keyword arguments.  If a different type of warning is triggered, it will not be handled: depending on the other warning filtering rules in effect, it might be silenced, printed out, or raised as an exception.  If called with the callable and arguments omitted, will return a context object used like this::  with self.assertWarns(SomeWarning): do_something()  An optional keyword argument 'msg' can be provided when assertWarns is used as a context object.  The context manager keeps a reference to the first matching warning as the 'warning' attribute; similarly, the 'filename' and 'lineno' attributes give you information about the line of Python code from which the warning was triggered. This allows you to inspect the warning after the assertion::  with self.assertWarns(SomeWarning) as cm: do_something() the_warning = cm.warning self.assertEqual(the_warning.some_attribute, 147) &#34;&#34;&#34; context = _AssertWarnsContext(expected_warning, self) return context.handle(&#34;assertWarns&#34;, args, kwargs)"
                }
            },
            {
                "id": 228,
                "attributes": {
                    "id": 228.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertLogs",
                    "type": "function",
                    "code": "def assertLogs(self, logger=None, level=None): &#34;&#34;&#34;Fail unless a log message of level *level* or higher is emitted on *logger_name* or its children.  If omitted, *level* defaults to INFO and *logger* defaults to the root logger.  This method must be used as a context manager, and will yield a recording object with two attributes: `output` and `records`. At the end of the context manager, the `output` attribute will be a list of the matching formatted log messages and the `records` attribute will be a list of the corresponding LogRecord objects.  Example::  with self.assertLogs('foo', level='INFO') as cm: logging.getLogger('foo').info('first message') logging.getLogger('foo.bar').error('second message') self.assertEqual(cm.output, ['INFO:foo:first message', 'ERROR:foo.bar:second message']) &#34;&#34;&#34; return _AssertLogsContext(self, logger, level)",
                    "signature": "def assertLogs(self, logger=None, level=None): &#34;&#34;&#34;Fail unless a log message of level *level* or higher is emitted on *logger_name* or its children.  If omitted, *level* defaults to INFO and *logger* defaults to the root logger.  This method must be used as a context manager, and will yield a recording object with two attributes: `output` and `records`. At the end of the context manager, the `output` attribute will be a list of the matching formatted log messages and the `records` attribute will be a list of the corresponding LogRecord objects.  Example::  with self.assertLogs('foo', level='INFO') as cm: logging.getLogger('foo').info('first message') logging.getLogger('foo.bar').error('second message') self.assertEqual(cm.output, ['INFO:foo:first message', 'ERROR:foo.bar:second message']) &#34;&#34;&#34; return _AssertLogsContext(self, logger, level)"
                }
            },
            {
                "id": 256,
                "attributes": {
                    "id": 256.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertRaisesRegex",
                    "type": "function",
                    "code": "def assertRaisesRegex(self, expected_exception, expected_regex, *args, **kwargs): &#34;&#34;&#34;Asserts that the message in a raised exception matches a regex.  Args: expected_exception: Exception class expected to be raised. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertRaisesRegex is used as a context manager. &#34;&#34;&#34; context = _AssertRaisesContext(expected_exception, self, expected_regex) return context.handle(&#34;assertRaisesRegex&#34;, args, kwargs)",
                    "signature": "def assertRaisesRegex(self, expected_exception, expected_regex, *args, **kwargs): &#34;&#34;&#34;Asserts that the message in a raised exception matches a regex.  Args: expected_exception: Exception class expected to be raised. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertRaisesRegex is used as a context manager. &#34;&#34;&#34; context = _AssertRaisesContext(expected_exception, self, expected_regex) return context.handle(&#34;assertRaisesRegex&#34;, args, kwargs)"
                }
            },
            {
                "id": 257,
                "attributes": {
                    "id": 257.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertWarnsRegex",
                    "type": "function",
                    "code": "def assertWarnsRegex(self, expected_warning, expected_regex, *args, **kwargs): &#34;&#34;&#34;Asserts that the message in a triggered warning matches a regexp. Basic functioning is similar to assertWarns() with the addition that only warnings whose messages also match the regular expression are considered successful matches.  Args: expected_warning: Warning class expected to be triggered. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertWarnsRegex is used as a context manager. &#34;&#34;&#34; context = _AssertWarnsContext(expected_warning, self, expected_regex) return context.handle(&#34;assertWarnsRegex&#34;, args, kwargs)",
                    "signature": "def assertWarnsRegex(self, expected_warning, expected_regex, *args, **kwargs): &#34;&#34;&#34;Asserts that the message in a triggered warning matches a regexp. Basic functioning is similar to assertWarns() with the addition that only warnings whose messages also match the regular expression are considered successful matches.  Args: expected_warning: Warning class expected to be triggered. expected_regex: Regex (re.Pattern object or string) expected to be found in error message. args: Function to be called and extra positional args. kwargs: Extra kwargs. msg: Optional message used in case of failure. Can only be used when assertWarnsRegex is used as a context manager. &#34;&#34;&#34; context = _AssertWarnsContext(expected_warning, self, expected_regex) return context.handle(&#34;assertWarnsRegex&#34;, args, kwargs)"
                }
            },
            {
                "id": 470,
                "attributes": {
                    "id": 470.0,
                    "label": "collections",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 471,
                "attributes": {
                    "id": 471.0,
                    "label": "contextlib",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 472,
                "attributes": {
                    "id": 472.0,
                    "label": "difflib",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 473,
                "attributes": {
                    "id": 473.0,
                    "label": "functools",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 474,
                "attributes": {
                    "id": 474.0,
                    "label": "pprint",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 475,
                "attributes": {
                    "id": 475.0,
                    "label": "traceback",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 476,
                "attributes": {
                    "id": 476.0,
                    "label": "types",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            }
        ]
    },
    "3": {
        "nodes": [
            {
                "id": 13,
                "attributes": {
                    "id": 13.0,
                    "label": "hl7.hl7.mllp",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 14,
                "attributes": {
                    "id": 14.0,
                    "label": "hl7.hl7.mllp.exceptions",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 15,
                "attributes": {
                    "id": 15.0,
                    "label": "hl7.hl7.mllp.exceptions.InvalidBlockError",
                    "type": "class",
                    "code": "class InvalidBlockError(Exception): &#34;&#34;&#34;An MLLP Block was received that violates MLLP protocol&#34;&#34;&#34;",
                    "signature": "class InvalidBlockError(Exception): &#34;&#34;&#34;An MLLP Block was received that violates MLLP protocol&#34;&#34;&#34;"
                }
            },
            {
                "id": 16,
                "attributes": {
                    "id": 16.0,
                    "label": "hl7.hl7.mllp.streams",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 17,
                "attributes": {
                    "id": 17.0,
                    "label": "hl7.hl7.mllp.streams.open_hl7_connection",
                    "type": "function",
                    "code": "async def open_hl7_connection( host=None, port=None, *, loop=None, limit=_DEFAULT_LIMIT, encoding=None, encoding_errors=None, **kwds ): &#34;&#34;&#34;A wrapper for `loop.create_connection()` returning a (reader, writer) pair.  The reader returned is a :py:class:`hl7.mllp.HL7StreamReader` instance; the writer is a :py:class:`hl7.mllp.HL7StreamWriter` instance.  The arguments are all the usual arguments to create_connection() except `protocol_factory`; most common are positional `host` and `port`, with various optional keyword arguments following.  Additional optional keyword arguments are `loop` (to set the event loop instance to use), `limit` (to set the buffer limit passed to the :py:class:`hl7.mllp.HL7StreamReader`), `encoding` (to set the encoding on the :py:class:`hl7.mllp.HL7StreamReader` and :py:class:`hl7.mllp.HL7StreamWriter`) and `encoding_errors` (to set the encoding_errors on the :py:class:`hl7.mllp.HL7StreamReader` and :py:class:`hl7.mllp.HL7StreamWriter`). &#34;&#34;&#34; if loop is None: loop = get_event_loop() else: warnings.warn( &#34;The loop argument is deprecated since Python 3.8, &#34; &#34;and scheduled for removal in Python 3.10.&#34;, DeprecationWarning, stacklevel=2, ) reader = HL7StreamReader( limit=limit, loop=loop, encoding=encoding, encoding_errors=encoding_errors ) protocol = HL7StreamProtocol( reader, loop=loop, encoding=encoding, encoding_errors=encoding_errors ) transport, _ = await loop.create_connection(lambda: protocol, host, port, **kwds) writer = HL7StreamWriter( transport, protocol, reader, loop, encoding, encoding_errors ) return reader, writer",
                    "signature": "async def open_hl7_connection( host=None, port=None, *, loop=None, limit=_DEFAULT_LIMIT, encoding=None, encoding_errors=None, **kwds ): &#34;&#34;&#34;A wrapper for `loop.create_connection()` returning a (reader, writer) pair.  The reader returned is a :py:class:`hl7.mllp.HL7StreamReader` instance; the writer is a :py:class:`hl7.mllp.HL7StreamWriter` instance.  The arguments are all the usual arguments to create_connection() except `protocol_factory`; most common are positional `host` and `port`, with various optional keyword arguments following.  Additional optional keyword arguments are `loop` (to set the event loop instance to use), `limit` (to set the buffer limit passed to the :py:class:`hl7.mllp.HL7StreamReader`), `encoding` (to set the encoding on the :py:class:`hl7.mllp.HL7StreamReader` and :py:class:`hl7.mllp.HL7StreamWriter`) and `encoding_errors` (to set the encoding_errors on the :py:class:`hl7.mllp.HL7StreamReader` and :py:class:`hl7.mllp.HL7StreamWriter`). &#34;&#34;&#34; if loop is None: loop = get_event_loop() else: warnings.warn( &#34;The loop argument is deprecated since Python 3.8, &#34; &#34;and scheduled for removal in Python 3.10.&#34;, DeprecationWarning, stacklevel=2, ) reader = HL7StreamReader( limit=limit, loop=loop, encoding=encoding, encoding_errors=encoding_errors ) protocol = HL7StreamProtocol( reader, loop=loop, encoding=encoding, encoding_errors=encoding_errors ) transport, _ = await loop.create_connection(lambda: protocol, host, port, **kwds) writer = HL7StreamWriter( transport, protocol, reader, loop, encoding, encoding_errors ) return reader, writer"
                }
            },
            {
                "id": 18,
                "attributes": {
                    "id": 18.0,
                    "label": "hl7.hl7.mllp.streams.start_hl7_server",
                    "type": "function",
                    "code": "async def start_hl7_server( client_connected_cb, host=None, port=None, *, loop=None, limit=_DEFAULT_LIMIT, encoding=None, encoding_errors=None, **kwds ): &#34;&#34;&#34;Start a socket server, call back for each client connected.  The first parameter, `client_connected_cb`, takes two parameters: `client_reader`, `client_writer`.  `client_reader` is a :py:class:`hl7.mllp.HL7StreamReader` object, while `client_writer` is a :py:class:`hl7.mllp.HL7StreamWriter` object.  This parameter can either be a plain callback function or a coroutine; if it is a coroutine, it will be automatically converted into a `Task`.  The rest of the arguments are all the usual arguments to `loop.create_server()` except `protocol_factory`; most common are positional `host` and `port`, with various optional keyword arguments following.  The return value is the same as `loop.create_server()`. Additional optional keyword arguments are `loop` (to set the event loop instance to use) and `limit` (to set the buffer limit passed to the StreamReader).  The return value is the same as `loop.create_server()`, i.e. a `Server` object which can be used to stop the service. &#34;&#34;&#34; if loop is None: loop = get_event_loop() else: warnings.warn( &#34;The loop argument is deprecated since Python 3.8, &#34; &#34;and scheduled for removal in Python 3.10.&#34;, DeprecationWarning, stacklevel=2, )  def factory(): reader = HL7StreamReader( limit=limit, loop=loop, encoding=encoding, encoding_errors=encoding_errors ) protocol = HL7StreamProtocol( reader, client_connected_cb, loop=loop, encoding=encoding, encoding_errors=encoding_errors, ) return protocol  return await loop.create_server(factory, host, port, **kwds)",
                    "signature": "async def start_hl7_server( client_connected_cb, host=None, port=None, *, loop=None, limit=_DEFAULT_LIMIT, encoding=None, encoding_errors=None, **kwds ): &#34;&#34;&#34;Start a socket server, call back for each client connected.  The first parameter, `client_connected_cb`, takes two parameters: `client_reader`, `client_writer`.  `client_reader` is a :py:class:`hl7.mllp.HL7StreamReader` object, while `client_writer` is a :py:class:`hl7.mllp.HL7StreamWriter` object.  This parameter can either be a plain callback function or a coroutine; if it is a coroutine, it will be automatically converted into a `Task`.  The rest of the arguments are all the usual arguments to `loop.create_server()` except `protocol_factory`; most common are positional `host` and `port`, with various optional keyword arguments following.  The return value is the same as `loop.create_server()`. Additional optional keyword arguments are `loop` (to set the event loop instance to use) and `limit` (to set the buffer limit passed to the StreamReader).  The return value is the same as `loop.create_server()`, i.e. a `Server` object which can be used to stop the service. &#34;&#34;&#34; if loop is None: loop = get_event_loop() else: warnings.warn( &#34;The loop argument is deprecated since Python 3.8, &#34; &#34;and scheduled for removal in Python 3.10.&#34;, DeprecationWarning, stacklevel=2, )  def factory(): reader = HL7StreamReader( limit=limit, loop=loop, encoding=encoding, encoding_errors=encoding_errors ) protocol = HL7StreamProtocol( reader, client_connected_cb, loop=loop, encoding=encoding, encoding_errors=encoding_errors, ) return protocol  return await loop.create_server(factory, host, port, **kwds)"
                }
            },
            {
                "id": 19,
                "attributes": {
                    "id": 19.0,
                    "label": "hl7.hl7.mllp.streams.start_hl7_server.factory",
                    "type": "function",
                    "code": "def factory(): reader = HL7StreamReader( limit=limit, loop=loop, encoding=encoding, encoding_errors=encoding_errors ) protocol = HL7StreamProtocol( reader, client_connected_cb, loop=loop, encoding=encoding, encoding_errors=encoding_errors, ) return protocol",
                    "signature": "def factory(): reader = HL7StreamReader( limit=limit, loop=loop, encoding=encoding, encoding_errors=encoding_errors ) protocol = HL7StreamProtocol( reader, client_connected_cb, loop=loop, encoding=encoding, encoding_errors=encoding_errors, ) return protocol"
                }
            },
            {
                "id": 20,
                "attributes": {
                    "id": 20.0,
                    "label": "hl7.hl7.mllp.streams.MLLPStreamReader",
                    "type": "class",
                    "code": "class MLLPStreamReader(StreamReader): def __init__(self, limit=_DEFAULT_LIMIT, loop=None): super().__init__(limit, loop)  async def readblock(self): &#34;&#34;&#34;Read a chunk of data from the stream until the block termination separator (b'\\x1c\\x0d') are found.  On success, the data and separator will be removed from the internal buffer (consumed). Returned data will not include the separator at the end or the MLLP start block character (b'\\x0b') at the beginning.  Configured stream limit is used to check result. Limit sets the maximal length of data that can be returned, not counting the separator.  If an EOF occurs and the complete separator is still not found, an IncompleteReadError exception will be raised, and the internal buffer will be reset.  The IncompleteReadError.partial attribute may contain the separator partially.  If limit is reached, ValueError will be raised. In that case, if block termination separator was found, complete line including separator will be removed from internal buffer. Else, internal buffer will be cleared. Limit is compared against part of the line without separator.  If the block is invalid (missing required start block character) and InvalidBlockError will be raised.  If stream was paused, this function will automatically resume it if needed. &#34;&#34;&#34; sep = END_BLOCK + CARRIAGE_RETURN seplen = len(sep) try: block = await self.readuntil(sep) except LimitOverrunError as loe: if self._buffer.startswith(sep, loe.consumed): del self._buffer[: loe.consumed + seplen] else: self._buffer.clear() self._maybe_resume_transport() raise ValueError(loe.args[0]) if not block or block[0:1] != START_BLOCK: raise InvalidBlockError( &#34;Block does not begin with Start Block character <VT>&#34; ) return block[1:-2]",
                    "signature": "class MLLPStreamReader(StreamReader): def __init__(self, limit=_DEFAULT_LIMIT, loop=None): super().__init__(limit, loop)  async def readblock(self): &#34;&#34;&#34;Read a chunk of data from the stream until the block termination separator (b'\\x1c\\x0d') are found.  On success, the data and separator will be removed from the internal buffer (consumed). Returned data will not include the separator at the end or the MLLP start block character (b'\\x0b') at the beginning.  Configured stream limit is used to check result. Limit sets the maximal length of data that can be returned, not counting the separator.  If an EOF occurs and the complete separator is still not found, an IncompleteReadError exception will be raised, and the internal buffer will be reset.  The IncompleteReadError.partial attribute may contain the separator partially.  If limit is reached, ValueError will be raised. In that case, if block termination separator was found, complete line including separator will be removed from internal buffer. Else, internal buffer will be cleared. Limit is compared against part of the line without separator.  If the block is invalid (missing required start block character) and InvalidBlockError will be raised.  If stream was paused, this function will automatically resume it if needed. &#34;&#34;&#34; sep = END_BLOCK + CARRIAGE_RETURN seplen = len(sep) try: block = await self.readuntil(sep) except LimitOverrunError as loe: if self._buffer.startswith(sep, loe.consumed): del self._buffer[: loe.consumed + seplen] else: self._buffer.clear() self._maybe_resume_transport() raise ValueError(loe.args[0]) if not block or block[0:1] != START_BLOCK: raise InvalidBlockError( &#34;Block does not begin with Start Block character <VT>&#34; ) return block[1:-2]"
                }
            },
            {
                "id": 21,
                "attributes": {
                    "id": 21.0,
                    "label": "hl7.hl7.mllp.streams.MLLPStreamReader.__init__",
                    "type": "function",
                    "code": "def __init__(self, limit=_DEFAULT_LIMIT, loop=None): super().__init__(limit, loop)",
                    "signature": "def __init__(self, limit=_DEFAULT_LIMIT, loop=None): super().__init__(limit, loop)"
                }
            },
            {
                "id": 22,
                "attributes": {
                    "id": 22.0,
                    "label": "hl7.hl7.mllp.streams.MLLPStreamReader.readblock",
                    "type": "function",
                    "code": "async def readblock(self): &#34;&#34;&#34;Read a chunk of data from the stream until the block termination separator (b'\\x1c\\x0d') are found.  On success, the data and separator will be removed from the internal buffer (consumed). Returned data will not include the separator at the end or the MLLP start block character (b'\\x0b') at the beginning.  Configured stream limit is used to check result. Limit sets the maximal length of data that can be returned, not counting the separator.  If an EOF occurs and the complete separator is still not found, an IncompleteReadError exception will be raised, and the internal buffer will be reset.  The IncompleteReadError.partial attribute may contain the separator partially.  If limit is reached, ValueError will be raised. In that case, if block termination separator was found, complete line including separator will be removed from internal buffer. Else, internal buffer will be cleared. Limit is compared against part of the line without separator.  If the block is invalid (missing required start block character) and InvalidBlockError will be raised.  If stream was paused, this function will automatically resume it if needed. &#34;&#34;&#34; sep = END_BLOCK + CARRIAGE_RETURN seplen = len(sep) try: block = await self.readuntil(sep) except LimitOverrunError as loe: if self._buffer.startswith(sep, loe.consumed): del self._buffer[: loe.consumed + seplen] else: self._buffer.clear() self._maybe_resume_transport() raise ValueError(loe.args[0]) if not block or block[0:1] != START_BLOCK: raise InvalidBlockError( &#34;Block does not begin with Start Block character <VT>&#34; ) return block[1:-2]",
                    "signature": "async def readblock(self): &#34;&#34;&#34;Read a chunk of data from the stream until the block termination separator (b'\\x1c\\x0d') are found.  On success, the data and separator will be removed from the internal buffer (consumed). Returned data will not include the separator at the end or the MLLP start block character (b'\\x0b') at the beginning.  Configured stream limit is used to check result. Limit sets the maximal length of data that can be returned, not counting the separator.  If an EOF occurs and the complete separator is still not found, an IncompleteReadError exception will be raised, and the internal buffer will be reset.  The IncompleteReadError.partial attribute may contain the separator partially.  If limit is reached, ValueError will be raised. In that case, if block termination separator was found, complete line including separator will be removed from internal buffer. Else, internal buffer will be cleared. Limit is compared against part of the line without separator.  If the block is invalid (missing required start block character) and InvalidBlockError will be raised.  If stream was paused, this function will automatically resume it if needed. &#34;&#34;&#34; sep = END_BLOCK + CARRIAGE_RETURN seplen = len(sep) try: block = await self.readuntil(sep) except LimitOverrunError as loe: if self._buffer.startswith(sep, loe.consumed): del self._buffer[: loe.consumed + seplen] else: self._buffer.clear() self._maybe_resume_transport() raise ValueError(loe.args[0]) if not block or block[0:1] != START_BLOCK: raise InvalidBlockError( &#34;Block does not begin with Start Block character <VT>&#34; ) return block[1:-2]"
                }
            },
            {
                "id": 23,
                "attributes": {
                    "id": 23.0,
                    "label": "hl7.hl7.mllp.streams.MLLPStreamWriter",
                    "type": "class",
                    "code": "class MLLPStreamWriter(StreamWriter): def __init__(self, transport, protocol, reader, loop): super().__init__(transport, protocol, reader, loop)  def writeblock(self, data): &#34;&#34;&#34;Write a block of data to the stream, encapsulating the block with b'\\x0b' at the beginning and b'\\x1c\\x0d' at the end. &#34;&#34;&#34; self.write(START_BLOCK + data + END_BLOCK + CARRIAGE_RETURN)",
                    "signature": "class MLLPStreamWriter(StreamWriter): def __init__(self, transport, protocol, reader, loop): super().__init__(transport, protocol, reader, loop)  def writeblock(self, data): &#34;&#34;&#34;Write a block of data to the stream, encapsulating the block with b'\\x0b' at the beginning and b'\\x1c\\x0d' at the end. &#34;&#34;&#34; self.write(START_BLOCK + data + END_BLOCK + CARRIAGE_RETURN)"
                }
            },
            {
                "id": 24,
                "attributes": {
                    "id": 24.0,
                    "label": "hl7.hl7.mllp.streams.MLLPStreamWriter.__init__",
                    "type": "function",
                    "code": "def __init__(self, transport, protocol, reader, loop): super().__init__(transport, protocol, reader, loop)",
                    "signature": "def __init__(self, transport, protocol, reader, loop): super().__init__(transport, protocol, reader, loop)"
                }
            },
            {
                "id": 25,
                "attributes": {
                    "id": 25.0,
                    "label": "hl7.hl7.mllp.streams.MLLPStreamWriter.writeblock",
                    "type": "function",
                    "code": "def writeblock(self, data): &#34;&#34;&#34;Write a block of data to the stream, encapsulating the block with b'\\x0b' at the beginning and b'\\x1c\\x0d' at the end. &#34;&#34;&#34; self.write(START_BLOCK + data + END_BLOCK + CARRIAGE_RETURN)",
                    "signature": "def writeblock(self, data): &#34;&#34;&#34;Write a block of data to the stream, encapsulating the block with b'\\x0b' at the beginning and b'\\x1c\\x0d' at the end. &#34;&#34;&#34; self.write(START_BLOCK + data + END_BLOCK + CARRIAGE_RETURN)"
                }
            },
            {
                "id": 26,
                "attributes": {
                    "id": 26.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamProtocol",
                    "type": "class",
                    "code": "class HL7StreamProtocol(StreamReaderProtocol): def __init__( self, stream_reader, client_connected_cb=None, loop=None, encoding=None, encoding_errors=None, ): super().__init__(stream_reader, client_connected_cb, loop) self._encoding = encoding self._encoding_errors = encoding_errors  def connection_made(self, transport): # _reject_connection not added until 3.8 if getattr(self, &#34;_reject_connection&#34;, False): context = { &#34;message&#34;: ( &#34;An open stream was garbage collected prior to &#34; &#34;establishing network connection; &#34; 'call &#34;stream.close()&#34; explicitly.' ) } if self._source_traceback: context[&#34;source_traceback&#34;] = self._source_traceback self._loop.call_exception_handler(context) transport.abort() return self._transport = transport reader = self._stream_reader if reader is not None: reader.set_transport(transport) self._over_ssl = transport.get_extra_info(&#34;sslcontext&#34;) is not None if self._client_connected_cb is not None: self._stream_writer = HL7StreamWriter( transport, self, reader, self._loop, self._encoding, self._encoding_errors, ) res = self._client_connected_cb(reader, self._stream_writer) if iscoroutine(res): self._loop.create_task(res) self._strong_reader = None",
                    "signature": "class HL7StreamProtocol(StreamReaderProtocol): def __init__( self, stream_reader, client_connected_cb=None, loop=None, encoding=None, encoding_errors=None, ): super().__init__(stream_reader, client_connected_cb, loop) self._encoding = encoding self._encoding_errors = encoding_errors  def connection_made(self, transport): # _reject_connection not added until 3.8 if getattr(self, &#34;_reject_connection&#34;, False): context = { &#34;message&#34;: ( &#34;An open stream was garbage collected prior to &#34; &#34;establishing network connection; &#34; 'call &#34;stream.close()&#34; explicitly.' ) } if self._source_traceback: context[&#34;source_traceback&#34;] = self._source_traceback self._loop.call_exception_handler(context) transport.abort() return self._transport = transport reader = self._stream_reader if reader is not None: reader.set_transport(transport) self._over_ssl = transport.get_extra_info(&#34;sslcontext&#34;) is not None if self._client_connected_cb is not None: self._stream_writer = HL7StreamWriter( transport, self, reader, self._loop, self._encoding, self._encoding_errors, ) res = self._client_connected_cb(reader, self._stream_writer) if iscoroutine(res): self._loop.create_task(res) self._strong_reader = None"
                }
            },
            {
                "id": 27,
                "attributes": {
                    "id": 27.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamProtocol.__init__",
                    "type": "function",
                    "code": "def __init__( self, stream_reader, client_connected_cb=None, loop=None, encoding=None, encoding_errors=None, ): super().__init__(stream_reader, client_connected_cb, loop) self._encoding = encoding self._encoding_errors = encoding_errors",
                    "signature": "def __init__( self, stream_reader, client_connected_cb=None, loop=None, encoding=None, encoding_errors=None, ): super().__init__(stream_reader, client_connected_cb, loop) self._encoding = encoding self._encoding_errors = encoding_errors"
                }
            },
            {
                "id": 28,
                "attributes": {
                    "id": 28.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamProtocol.connection_made",
                    "type": "function",
                    "code": "def connection_made(self, transport): # _reject_connection not added until 3.8 if getattr(self, &#34;_reject_connection&#34;, False): context = { &#34;message&#34;: ( &#34;An open stream was garbage collected prior to &#34; &#34;establishing network connection; &#34; 'call &#34;stream.close()&#34; explicitly.' ) } if self._source_traceback: context[&#34;source_traceback&#34;] = self._source_traceback self._loop.call_exception_handler(context) transport.abort() return self._transport = transport reader = self._stream_reader if reader is not None: reader.set_transport(transport) self._over_ssl = transport.get_extra_info(&#34;sslcontext&#34;) is not None if self._client_connected_cb is not None: self._stream_writer = HL7StreamWriter( transport, self, reader, self._loop, self._encoding, self._encoding_errors, ) res = self._client_connected_cb(reader, self._stream_writer) if iscoroutine(res): self._loop.create_task(res) self._strong_reader = None",
                    "signature": "def connection_made(self, transport): # _reject_connection not added until 3.8 if getattr(self, &#34;_reject_connection&#34;, False): context = { &#34;message&#34;: ( &#34;An open stream was garbage collected prior to &#34; &#34;establishing network connection; &#34; 'call &#34;stream.close()&#34; explicitly.' ) } if self._source_traceback: context[&#34;source_traceback&#34;] = self._source_traceback self._loop.call_exception_handler(context) transport.abort() return self._transport = transport reader = self._stream_reader if reader is not None: reader.set_transport(transport) self._over_ssl = transport.get_extra_info(&#34;sslcontext&#34;) is not None if self._client_connected_cb is not None: self._stream_writer = HL7StreamWriter( transport, self, reader, self._loop, self._encoding, self._encoding_errors, ) res = self._client_connected_cb(reader, self._stream_writer) if iscoroutine(res): self._loop.create_task(res) self._strong_reader = None"
                }
            },
            {
                "id": 29,
                "attributes": {
                    "id": 29.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamReader",
                    "type": "class",
                    "code": "class HL7StreamReader(MLLPStreamReader): def __init__( self, limit=_DEFAULT_LIMIT, loop=None, encoding=None, encoding_errors=None ): super().__init__(limit=limit, loop=loop) self.encoding = encoding self.encoding_errors = encoding_errors  @property def encoding(self): return self._encoding  @encoding.setter def encoding(self, encoding): if encoding and not isinstance(encoding, str): raise TypeError(&#34;encoding must be a str or None&#34;) self._encoding = encoding or &#34;ascii&#34;  @property def encoding_errors(self): return self._encoding_errors  @encoding_errors.setter def encoding_errors(self, encoding_errors): if encoding_errors and not isinstance(encoding_errors, str): raise TypeError(&#34;encoding_errors must be a str or None&#34;) self._encoding_errors = encoding_errors or &#34;strict&#34;  async def readmessage(self): &#34;&#34;&#34;Reads a full HL7 message from the stream.  This will return an :py:class:`hl7.Message`.  If `limit` is reached, `ValueError` will be raised. In that case, if block termination separator was found, complete line including separator will be removed from internal buffer. Else, internal buffer will be cleared. Limit is compared against part of the line without separator.  If an invalid MLLP block is encountered, :py:class:`hl7.mllp.InvalidBlockError` will be raised. &#34;&#34;&#34; block = await self.readblock() return hl7_parse(block.decode(self.encoding, self.encoding_errors))",
                    "signature": "class HL7StreamReader(MLLPStreamReader): def __init__( self, limit=_DEFAULT_LIMIT, loop=None, encoding=None, encoding_errors=None ): super().__init__(limit=limit, loop=loop) self.encoding = encoding self.encoding_errors = encoding_errors  @property def encoding(self): return self._encoding  @encoding.setter def encoding(self, encoding): if encoding and not isinstance(encoding, str): raise TypeError(&#34;encoding must be a str or None&#34;) self._encoding = encoding or &#34;ascii&#34;  @property def encoding_errors(self): return self._encoding_errors  @encoding_errors.setter def encoding_errors(self, encoding_errors): if encoding_errors and not isinstance(encoding_errors, str): raise TypeError(&#34;encoding_errors must be a str or None&#34;) self._encoding_errors = encoding_errors or &#34;strict&#34;  async def readmessage(self): &#34;&#34;&#34;Reads a full HL7 message from the stream.  This will return an :py:class:`hl7.Message`.  If `limit` is reached, `ValueError` will be raised. In that case, if block termination separator was found, complete line including separator will be removed from internal buffer. Else, internal buffer will be cleared. Limit is compared against part of the line without separator.  If an invalid MLLP block is encountered, :py:class:`hl7.mllp.InvalidBlockError` will be raised. &#34;&#34;&#34; block = await self.readblock() return hl7_parse(block.decode(self.encoding, self.encoding_errors))"
                }
            },
            {
                "id": 30,
                "attributes": {
                    "id": 30.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamReader.__init__",
                    "type": "function",
                    "code": "def __init__( self, limit=_DEFAULT_LIMIT, loop=None, encoding=None, encoding_errors=None ): super().__init__(limit=limit, loop=loop) self.encoding = encoding self.encoding_errors = encoding_errors",
                    "signature": "def __init__( self, limit=_DEFAULT_LIMIT, loop=None, encoding=None, encoding_errors=None ): super().__init__(limit=limit, loop=loop) self.encoding = encoding self.encoding_errors = encoding_errors"
                }
            },
            {
                "id": 31,
                "attributes": {
                    "id": 31.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamReader.encoding",
                    "type": "function",
                    "code": "def encoding(self, encoding): if encoding and not isinstance(encoding, str): raise TypeError(&#34;encoding must be a str or None&#34;) self._encoding = encoding or &#34;ascii&#34;",
                    "signature": "def encoding(self, encoding): if encoding and not isinstance(encoding, str): raise TypeError(&#34;encoding must be a str or None&#34;) self._encoding = encoding or &#34;ascii&#34;"
                }
            },
            {
                "id": 32,
                "attributes": {
                    "id": 32.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamReader.encoding_errors",
                    "type": "function",
                    "code": "def encoding_errors(self, encoding_errors): if encoding_errors and not isinstance(encoding_errors, str): raise TypeError(&#34;encoding_errors must be a str or None&#34;) self._encoding_errors = encoding_errors or &#34;strict&#34;",
                    "signature": "def encoding_errors(self, encoding_errors): if encoding_errors and not isinstance(encoding_errors, str): raise TypeError(&#34;encoding_errors must be a str or None&#34;) self._encoding_errors = encoding_errors or &#34;strict&#34;"
                }
            },
            {
                "id": 33,
                "attributes": {
                    "id": 33.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamReader.readmessage",
                    "type": "function",
                    "code": "async def readmessage(self): &#34;&#34;&#34;Reads a full HL7 message from the stream.  This will return an :py:class:`hl7.Message`.  If `limit` is reached, `ValueError` will be raised. In that case, if block termination separator was found, complete line including separator will be removed from internal buffer. Else, internal buffer will be cleared. Limit is compared against part of the line without separator.  If an invalid MLLP block is encountered, :py:class:`hl7.mllp.InvalidBlockError` will be raised. &#34;&#34;&#34; block = await self.readblock() return hl7_parse(block.decode(self.encoding, self.encoding_errors))",
                    "signature": "async def readmessage(self): &#34;&#34;&#34;Reads a full HL7 message from the stream.  This will return an :py:class:`hl7.Message`.  If `limit` is reached, `ValueError` will be raised. In that case, if block termination separator was found, complete line including separator will be removed from internal buffer. Else, internal buffer will be cleared. Limit is compared against part of the line without separator.  If an invalid MLLP block is encountered, :py:class:`hl7.mllp.InvalidBlockError` will be raised. &#34;&#34;&#34; block = await self.readblock() return hl7_parse(block.decode(self.encoding, self.encoding_errors))"
                }
            },
            {
                "id": 34,
                "attributes": {
                    "id": 34.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamWriter",
                    "type": "class",
                    "code": "class HL7StreamWriter(MLLPStreamWriter): def __init__( self, transport, protocol, reader, loop, encoding=None, encoding_errors=None ): super().__init__(transport, protocol, reader, loop) self.encoding = encoding self.encoding_errors = encoding_errors  @property def encoding(self): return self._encoding  @encoding.setter def encoding(self, encoding): if encoding and not isinstance(encoding, str): raise TypeError(&#34;encoding must be a str or None&#34;) self._encoding = encoding or &#34;ascii&#34;  @property def encoding_errors(self): return self._encoding_errors  @encoding_errors.setter def encoding_errors(self, encoding_errors): if encoding_errors and not isinstance(encoding_errors, str): raise TypeError(&#34;encoding_errors must be a str or None&#34;) self._encoding_errors = encoding_errors or &#34;strict&#34;  def writemessage(self, message): &#34;&#34;&#34;Writes an :py:class:`hl7.Message` to the stream.&#34;&#34;&#34; self.writeblock(str(message).encode(self.encoding, self.encoding_errors))",
                    "signature": "class HL7StreamWriter(MLLPStreamWriter): def __init__( self, transport, protocol, reader, loop, encoding=None, encoding_errors=None ): super().__init__(transport, protocol, reader, loop) self.encoding = encoding self.encoding_errors = encoding_errors  @property def encoding(self): return self._encoding  @encoding.setter def encoding(self, encoding): if encoding and not isinstance(encoding, str): raise TypeError(&#34;encoding must be a str or None&#34;) self._encoding = encoding or &#34;ascii&#34;  @property def encoding_errors(self): return self._encoding_errors  @encoding_errors.setter def encoding_errors(self, encoding_errors): if encoding_errors and not isinstance(encoding_errors, str): raise TypeError(&#34;encoding_errors must be a str or None&#34;) self._encoding_errors = encoding_errors or &#34;strict&#34;  def writemessage(self, message): &#34;&#34;&#34;Writes an :py:class:`hl7.Message` to the stream.&#34;&#34;&#34; self.writeblock(str(message).encode(self.encoding, self.encoding_errors))"
                }
            },
            {
                "id": 35,
                "attributes": {
                    "id": 35.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamWriter.__init__",
                    "type": "function",
                    "code": "def __init__( self, transport, protocol, reader, loop, encoding=None, encoding_errors=None ): super().__init__(transport, protocol, reader, loop) self.encoding = encoding self.encoding_errors = encoding_errors",
                    "signature": "def __init__( self, transport, protocol, reader, loop, encoding=None, encoding_errors=None ): super().__init__(transport, protocol, reader, loop) self.encoding = encoding self.encoding_errors = encoding_errors"
                }
            },
            {
                "id": 36,
                "attributes": {
                    "id": 36.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamWriter.encoding",
                    "type": "function",
                    "code": "def encoding(self, encoding): if encoding and not isinstance(encoding, str): raise TypeError(&#34;encoding must be a str or None&#34;) self._encoding = encoding or &#34;ascii&#34;",
                    "signature": "def encoding(self, encoding): if encoding and not isinstance(encoding, str): raise TypeError(&#34;encoding must be a str or None&#34;) self._encoding = encoding or &#34;ascii&#34;"
                }
            },
            {
                "id": 37,
                "attributes": {
                    "id": 37.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamWriter.encoding_errors",
                    "type": "function",
                    "code": "def encoding_errors(self, encoding_errors): if encoding_errors and not isinstance(encoding_errors, str): raise TypeError(&#34;encoding_errors must be a str or None&#34;) self._encoding_errors = encoding_errors or &#34;strict&#34;",
                    "signature": "def encoding_errors(self, encoding_errors): if encoding_errors and not isinstance(encoding_errors, str): raise TypeError(&#34;encoding_errors must be a str or None&#34;) self._encoding_errors = encoding_errors or &#34;strict&#34;"
                }
            },
            {
                "id": 38,
                "attributes": {
                    "id": 38.0,
                    "label": "hl7.hl7.mllp.streams.HL7StreamWriter.writemessage",
                    "type": "function",
                    "code": "def writemessage(self, message): &#34;&#34;&#34;Writes an :py:class:`hl7.Message` to the stream.&#34;&#34;&#34; self.writeblock(str(message).encode(self.encoding, self.encoding_errors))",
                    "signature": "def writemessage(self, message): &#34;&#34;&#34;Writes an :py:class:`hl7.Message` to the stream.&#34;&#34;&#34; self.writeblock(str(message).encode(self.encoding, self.encoding_errors))"
                }
            },
            {
                "id": 39,
                "attributes": {
                    "id": 39.0,
                    "label": "hl7.hl7.mllp.__init__",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 335,
                "attributes": {
                    "id": 335.0,
                    "label": "hl7.tests.test_mllp.MLLPStreamWriterTest",
                    "type": "class",
                    "code": "class MLLPStreamWriterTest(IsolatedAsyncioTestCase): def setUp(self): self.transport = create_autospec(asyncio.Transport)  async def asyncSetUp(self): self.writer = hl7.mllp.MLLPStreamWriter( self.transport, create_autospec(asyncio.streams.StreamReaderProtocol), create_autospec(hl7.mllp.MLLPStreamReader), asyncio.get_running_loop(), )  def test_writeblock(self): self.writer.writeblock(b&#34;foobar&#34;) self.transport.write.assert_called_with( START_BLOCK + b&#34;foobar&#34; + END_BLOCK + CARRIAGE_RETURN )",
                    "signature": "class MLLPStreamWriterTest(IsolatedAsyncioTestCase): def setUp(self): self.transport = create_autospec(asyncio.Transport)  async def asyncSetUp(self): self.writer = hl7.mllp.MLLPStreamWriter( self.transport, create_autospec(asyncio.streams.StreamReaderProtocol), create_autospec(hl7.mllp.MLLPStreamReader), asyncio.get_running_loop(), )  def test_writeblock(self): self.writer.writeblock(b&#34;foobar&#34;) self.transport.write.assert_called_with( START_BLOCK + b&#34;foobar&#34; + END_BLOCK + CARRIAGE_RETURN )"
                }
            },
            {
                "id": 336,
                "attributes": {
                    "id": 336.0,
                    "label": "hl7.tests.test_mllp.MLLPStreamWriterTest.setUp",
                    "type": "function",
                    "code": "def setUp(self): self.transport = create_autospec(asyncio.Transport)",
                    "signature": "def setUp(self): self.transport = create_autospec(asyncio.Transport)"
                }
            },
            {
                "id": 337,
                "attributes": {
                    "id": 337.0,
                    "label": "hl7.tests.test_mllp.MLLPStreamWriterTest.asyncSetUp",
                    "type": "function",
                    "code": "async def asyncSetUp(self): self.writer = hl7.mllp.MLLPStreamWriter( self.transport, create_autospec(asyncio.streams.StreamReaderProtocol), create_autospec(hl7.mllp.MLLPStreamReader), asyncio.get_running_loop(), )",
                    "signature": "async def asyncSetUp(self): self.writer = hl7.mllp.MLLPStreamWriter( self.transport, create_autospec(asyncio.streams.StreamReaderProtocol), create_autospec(hl7.mllp.MLLPStreamReader), asyncio.get_running_loop(), )"
                }
            },
            {
                "id": 338,
                "attributes": {
                    "id": 338.0,
                    "label": "hl7.tests.test_mllp.MLLPStreamWriterTest.test_writeblock",
                    "type": "function",
                    "code": "def test_writeblock(self): self.writer.writeblock(b&#34;foobar&#34;) self.transport.write.assert_called_with( START_BLOCK + b&#34;foobar&#34; + END_BLOCK + CARRIAGE_RETURN )",
                    "signature": "def test_writeblock(self): self.writer.writeblock(b&#34;foobar&#34;) self.transport.write.assert_called_with( START_BLOCK + b&#34;foobar&#34; + END_BLOCK + CARRIAGE_RETURN )"
                }
            },
            {
                "id": 339,
                "attributes": {
                    "id": 339.0,
                    "label": "hl7.tests.test_mllp.MLLPStreamReaderTest",
                    "type": "class",
                    "code": "class MLLPStreamReaderTest(IsolatedAsyncioTestCase): def setUp(self): self.reader = hl7.mllp.MLLPStreamReader()  async def test_readblock(self): self.reader.feed_data(START_BLOCK + b&#34;foobar&#34; + END_BLOCK + CARRIAGE_RETURN) block = await self.reader.readblock() self.assertEqual(block, b&#34;foobar&#34;)",
                    "signature": "class MLLPStreamReaderTest(IsolatedAsyncioTestCase): def setUp(self): self.reader = hl7.mllp.MLLPStreamReader()  async def test_readblock(self): self.reader.feed_data(START_BLOCK + b&#34;foobar&#34; + END_BLOCK + CARRIAGE_RETURN) block = await self.reader.readblock() self.assertEqual(block, b&#34;foobar&#34;)"
                }
            },
            {
                "id": 340,
                "attributes": {
                    "id": 340.0,
                    "label": "hl7.tests.test_mllp.MLLPStreamReaderTest.setUp",
                    "type": "function",
                    "code": "def setUp(self): self.reader = hl7.mllp.MLLPStreamReader()",
                    "signature": "def setUp(self): self.reader = hl7.mllp.MLLPStreamReader()"
                }
            },
            {
                "id": 341,
                "attributes": {
                    "id": 341.0,
                    "label": "hl7.tests.test_mllp.MLLPStreamReaderTest.test_readblock",
                    "type": "function",
                    "code": "async def test_readblock(self): self.reader.feed_data(START_BLOCK + b&#34;foobar&#34; + END_BLOCK + CARRIAGE_RETURN) block = await self.reader.readblock() self.assertEqual(block, b&#34;foobar&#34;)",
                    "signature": "async def test_readblock(self): self.reader.feed_data(START_BLOCK + b&#34;foobar&#34; + END_BLOCK + CARRIAGE_RETURN) block = await self.reader.readblock() self.assertEqual(block, b&#34;foobar&#34;)"
                }
            },
            {
                "id": 342,
                "attributes": {
                    "id": 342.0,
                    "label": "hl7.tests.test_mllp.HL7StreamWriterTest",
                    "type": "class",
                    "code": "class HL7StreamWriterTest(IsolatedAsyncioTestCase): def setUp(self): self.transport = create_autospec(asyncio.Transport)  async def asyncSetUp(self): def mock_cb(reader, writer): pass  reader = create_autospec(asyncio.streams.StreamReader)  self.writer = hl7.mllp.HL7StreamWriter( self.transport, hl7.mllp.HL7StreamProtocol(reader, mock_cb, asyncio.get_running_loop()), reader, asyncio.get_running_loop(), )  def test_writemessage(self): message = r&#34;MSH|^~\\&#38;|LABADT|DH|EPICADT|DH|201301011228||ACK^A01^ACK|HL7ACK00001|P|2.3\\r&#34; message += &#34;MSA|AA|HL7MSG00001\\r&#34; hl7_message = hl7.parse(message) self.writer.writemessage(hl7_message) self.transport.write.assert_called_with( START_BLOCK + message.encode() + END_BLOCK + CARRIAGE_RETURN )",
                    "signature": "class HL7StreamWriterTest(IsolatedAsyncioTestCase): def setUp(self): self.transport = create_autospec(asyncio.Transport)  async def asyncSetUp(self): def mock_cb(reader, writer): pass  reader = create_autospec(asyncio.streams.StreamReader)  self.writer = hl7.mllp.HL7StreamWriter( self.transport, hl7.mllp.HL7StreamProtocol(reader, mock_cb, asyncio.get_running_loop()), reader, asyncio.get_running_loop(), )  def test_writemessage(self): message = r&#34;MSH|^~\\&#38;|LABADT|DH|EPICADT|DH|201301011228||ACK^A01^ACK|HL7ACK00001|P|2.3\\r&#34; message += &#34;MSA|AA|HL7MSG00001\\r&#34; hl7_message = hl7.parse(message) self.writer.writemessage(hl7_message) self.transport.write.assert_called_with( START_BLOCK + message.encode() + END_BLOCK + CARRIAGE_RETURN )"
                }
            },
            {
                "id": 343,
                "attributes": {
                    "id": 343.0,
                    "label": "hl7.tests.test_mllp.HL7StreamWriterTest.setUp",
                    "type": "function",
                    "code": "def setUp(self): self.transport = create_autospec(asyncio.Transport)",
                    "signature": "def setUp(self): self.transport = create_autospec(asyncio.Transport)"
                }
            },
            {
                "id": 344,
                "attributes": {
                    "id": 344.0,
                    "label": "hl7.tests.test_mllp.HL7StreamWriterTest.asyncSetUp",
                    "type": "function",
                    "code": "async def asyncSetUp(self): def mock_cb(reader, writer): pass  reader = create_autospec(asyncio.streams.StreamReader)  self.writer = hl7.mllp.HL7StreamWriter( self.transport, hl7.mllp.HL7StreamProtocol(reader, mock_cb, asyncio.get_running_loop()), reader, asyncio.get_running_loop(), )",
                    "signature": "async def asyncSetUp(self): def mock_cb(reader, writer): pass  reader = create_autospec(asyncio.streams.StreamReader)  self.writer = hl7.mllp.HL7StreamWriter( self.transport, hl7.mllp.HL7StreamProtocol(reader, mock_cb, asyncio.get_running_loop()), reader, asyncio.get_running_loop(), )"
                }
            },
            {
                "id": 345,
                "attributes": {
                    "id": 345.0,
                    "label": "hl7.tests.test_mllp.HL7StreamWriterTest.asyncSetUp.mock_cb",
                    "type": "function",
                    "code": "def mock_cb(reader, writer): pass",
                    "signature": "def mock_cb(reader, writer): pass"
                }
            },
            {
                "id": 346,
                "attributes": {
                    "id": 346.0,
                    "label": "hl7.tests.test_mllp.HL7StreamWriterTest.test_writemessage",
                    "type": "function",
                    "code": "def test_writemessage(self): message = r&#34;MSH|^~\\&#38;|LABADT|DH|EPICADT|DH|201301011228||ACK^A01^ACK|HL7ACK00001|P|2.3\\r&#34; message += &#34;MSA|AA|HL7MSG00001\\r&#34; hl7_message = hl7.parse(message) self.writer.writemessage(hl7_message) self.transport.write.assert_called_with( START_BLOCK + message.encode() + END_BLOCK + CARRIAGE_RETURN )",
                    "signature": "def test_writemessage(self): message = r&#34;MSH|^~\\&#38;|LABADT|DH|EPICADT|DH|201301011228||ACK^A01^ACK|HL7ACK00001|P|2.3\\r&#34; message += &#34;MSA|AA|HL7MSG00001\\r&#34; hl7_message = hl7.parse(message) self.writer.writemessage(hl7_message) self.transport.write.assert_called_with( START_BLOCK + message.encode() + END_BLOCK + CARRIAGE_RETURN )"
                }
            },
            {
                "id": 348,
                "attributes": {
                    "id": 348.0,
                    "label": "hl7.tests.test_mllp.HL7StreamReaderTest.setUp",
                    "type": "function",
                    "code": "def setUp(self): self.reader = hl7.mllp.HL7StreamReader()",
                    "signature": "def setUp(self): self.reader = hl7.mllp.HL7StreamReader()"
                }
            },
            {
                "id": 465,
                "attributes": {
                    "id": 465.0,
                    "label": "warnings",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            }
        ]
    },
    "4": {
        "nodes": [
            {
                "id": 12,
                "attributes": {
                    "id": 12.0,
                    "label": "hl7.hl7.util.unescape",
                    "type": "function",
                    "code": "def unescape(container, field, app_map=None):  # noqa: C901 &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  This will convert the identifiable sequences. If the application provides mapping, these are also used. Items which cannot be mapped are removed  For example, the App Map count provide N, H, Zxxx values  Chapter 2: Section 2.10  At the moment, this functionality can:  *   replace the parsing characters (2.10.4) *   replace highlight characters (2.10.3) *   replace hex characters. (2.10.5) *   replace rich text characters (2.10.6) *   replace application defined characters (2.10.7)  It cannot:  *   switch code pages / ISO IR character sets &#34;&#34;&#34; if not field or field.find(container.esc) == -1: return field  DEFAULT_MAP = { &#34;H&#34;: &#34;_&#34;,  # Override using the APP MAP: 2.10.3 &#34;N&#34;: &#34;_&#34;,  # Override using the APP MAP &#34;F&#34;: container.separators[1],  # 2.10.4 &#34;R&#34;: container.separators[2], &#34;S&#34;: container.separators[3], &#34;T&#34;: container.separators[4], &#34;E&#34;: container.esc, &#34;.br&#34;: &#34;\\r&#34;,  # 2.10.6 &#34;.sp&#34;: &#34;\\r&#34;, &#34;.fi&#34;: &#34;&#34;, &#34;.nf&#34;: &#34;&#34;, &#34;.in&#34;: &#34;    &#34;, &#34;.ti&#34;: &#34;    &#34;, &#34;.sk&#34;: &#34; &#34;, &#34;.ce&#34;: &#34;\\r&#34;, }  rv = [] collecting = [] in_seq = False for offset, c in enumerate(field): if in_seq: if c == container.esc: in_seq = False value = &#34;&#34;.join(collecting) collecting = [] if not value: logger.warn( &#34;Error unescaping value [%s], empty sequence found at %d&#34;, field, offset, ) continue if app_map and value in app_map: rv.append(app_map[value]) elif value in DEFAULT_MAP: rv.append(DEFAULT_MAP[value]) elif value.startswith(&#34;.&#34;) and ( (app_map and value[:3] in app_map) or value[:3] in DEFAULT_MAP ): # Substitution with a number of repetitions defined (2.10.6) if app_map and value[:3] in app_map: ch = app_map[value[:3]] else: ch = DEFAULT_MAP[value[:3]] count = int(value[3:]) rv.append(ch * count)  elif ( value[0] == &#34;C&#34; ):  # Convert to new Single Byte character set : 2.10.2 # Two HEX values, first value chooses the character set (ISO-IR), second gives the value logger.warn( &#34;Error inline character sets [%s] not implemented, field [%s], offset [%s]&#34;, value, field, offset, ) elif value[0] == &#34;M&#34;:  # Switch to new Multi Byte character set : 2.10.2 # Three HEX values, first value chooses the character set (ISO-IR), rest give the value logger.warn( &#34;Error inline character sets [%s] not implemented, field [%s], offset [%s]&#34;, value, field, offset, ) elif value[0] == &#34;X&#34;:  # Hex encoded Bytes: 2.10.5 value = value[1:] try: for off in range(0, len(value), 2): rv.append(chr(int(value[off : off + 2], 16))) except Exception: logger.exception( &#34;Error decoding hex value [%s], field [%s], offset [%s]&#34;, value, field, offset, ) else: logger.exception( &#34;Error decoding value [%s], field [%s], offset [%s]&#34;, value, field, offset, ) else: collecting.append(c) elif c == container.esc: in_seq = True else: rv.append(str(c))  return &#34;&#34;.join(rv)",
                    "signature": "def unescape(container, field, app_map=None):  # noqa: C901 &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  This will convert the identifiable sequences. If the application provides mapping, these are also used. Items which cannot be mapped are removed  For example, the App Map count provide N, H, Zxxx values  Chapter 2: Section 2.10  At the moment, this functionality can:  *   replace the parsing characters (2.10.4) *   replace highlight characters (2.10.3) *   replace hex characters. (2.10.5) *   replace rich text characters (2.10.6) *   replace application defined characters (2.10.7)  It cannot:  *   switch code pages / ISO IR character sets &#34;&#34;&#34; if not field or field.find(container.esc) == -1: return field  DEFAULT_MAP = { &#34;H&#34;: &#34;_&#34;,  # Override using the APP MAP: 2.10.3 &#34;N&#34;: &#34;_&#34;,  # Override using the APP MAP &#34;F&#34;: container.separators[1],  # 2.10.4 &#34;R&#34;: container.separators[2], &#34;S&#34;: container.separators[3], &#34;T&#34;: container.separators[4], &#34;E&#34;: container.esc, &#34;.br&#34;: &#34;\\r&#34;,  # 2.10.6 &#34;.sp&#34;: &#34;\\r&#34;, &#34;.fi&#34;: &#34;&#34;, &#34;.nf&#34;: &#34;&#34;, &#34;.in&#34;: &#34;    &#34;, &#34;.ti&#34;: &#34;    &#34;, &#34;.sk&#34;: &#34; &#34;, &#34;.ce&#34;: &#34;\\r&#34;, }  rv = [] collecting = [] in_seq = False for offset, c in enumerate(field): if in_seq: if c == container.esc: in_seq = False value = &#34;&#34;.join(collecting) collecting = [] if not value: logger.warn( &#34;Error unescaping value [%s], empty sequence found at %d&#34;, field, offset, ) continue if app_map and value in app_map: rv.append(app_map[value]) elif value in DEFAULT_MAP: rv.append(DEFAULT_MAP[value]) elif value.startswith(&#34;.&#34;) and ( (app_map and value[:3] in app_map) or value[:3] in DEFAULT_MAP ): # Substitution with a number of repetitions defined (2.10.6) if app_map and value[:3] in app_map: ch = app_map[value[:3]] else: ch = DEFAULT_MAP[value[:3]] count = int(value[3:]) rv.append(ch * count)  elif ( value[0] == &#34;C&#34; ):  # Convert to new Single Byte character set : 2.10.2 # Two HEX values, first value chooses the character set (ISO-IR), second gives the value logger.warn( &#34;Error inline character sets [%s] not implemented, field [%s], offset [%s]&#34;, value, field, offset, ) elif value[0] == &#34;M&#34;:  # Switch to new Multi Byte character set : 2.10.2 # Three HEX values, first value chooses the character set (ISO-IR), rest give the value logger.warn( &#34;Error inline character sets [%s] not implemented, field [%s], offset [%s]&#34;, value, field, offset, ) elif value[0] == &#34;X&#34;:  # Hex encoded Bytes: 2.10.5 value = value[1:] try: for off in range(0, len(value), 2): rv.append(chr(int(value[off : off + 2], 16))) except Exception: logger.exception( &#34;Error decoding hex value [%s], field [%s], offset [%s]&#34;, value, field, offset, ) else: logger.exception( &#34;Error decoding value [%s], field [%s], offset [%s]&#34;, value, field, offset, ) else: collecting.append(c) elif c == container.esc: in_seq = True else: rv.append(str(c))  return &#34;&#34;.join(rv)"
                }
            },
            {
                "id": 85,
                "attributes": {
                    "id": 85.0,
                    "label": "hl7.hl7.containers",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 86,
                "attributes": {
                    "id": 86.0,
                    "label": "hl7.hl7.containers.Sequence",
                    "type": "class",
                    "code": "class Sequence(list): &#34;&#34;&#34;Base class for sequences that can be indexed using 1-based index&#34;&#34;&#34;  def __call__(self, index, value=_SENTINEL): &#34;&#34;&#34;Support list access using HL7 compatible 1-based indices. Can be used to get and set values.  >>> s = hl7.Sequence([1, 2, 3, 4]) >>> s(1) == s[0] True >>> s(2, &#34;new&#34;) >>> s [1, 'new', 3, 4] &#34;&#34;&#34; index = self._adjust_index(int(index)) if value is _SENTINEL: return self[index] else: self[index] = value  def _adjust_index(self, index): &#34;&#34;&#34;Subclasses can override if they do not want HL7 1-based indexing when used as callable&#34;&#34;&#34; if index >= 1: return index - 1 else: return index",
                    "signature": "class Sequence(list): &#34;&#34;&#34;Base class for sequences that can be indexed using 1-based index&#34;&#34;&#34;  def __call__(self, index, value=_SENTINEL): &#34;&#34;&#34;Support list access using HL7 compatible 1-based indices. Can be used to get and set values.  >>> s = hl7.Sequence([1, 2, 3, 4]) >>> s(1) == s[0] True >>> s(2, &#34;new&#34;) >>> s [1, 'new', 3, 4] &#34;&#34;&#34; index = self._adjust_index(int(index)) if value is _SENTINEL: return self[index] else: self[index] = value  def _adjust_index(self, index): &#34;&#34;&#34;Subclasses can override if they do not want HL7 1-based indexing when used as callable&#34;&#34;&#34; if index >= 1: return index - 1 else: return index"
                }
            },
            {
                "id": 87,
                "attributes": {
                    "id": 87.0,
                    "label": "hl7.hl7.containers.Sequence.__call__",
                    "type": "function",
                    "code": "def __call__(self, index, value=_SENTINEL): &#34;&#34;&#34;Support list access using HL7 compatible 1-based indices. Can be used to get and set values.  >>> s = hl7.Sequence([1, 2, 3, 4]) >>> s(1) == s[0] True >>> s(2, &#34;new&#34;) >>> s [1, 'new', 3, 4] &#34;&#34;&#34; index = self._adjust_index(int(index)) if value is _SENTINEL: return self[index] else: self[index] = value",
                    "signature": "def __call__(self, index, value=_SENTINEL): &#34;&#34;&#34;Support list access using HL7 compatible 1-based indices. Can be used to get and set values.  >>> s = hl7.Sequence([1, 2, 3, 4]) >>> s(1) == s[0] True >>> s(2, &#34;new&#34;) >>> s [1, 'new', 3, 4] &#34;&#34;&#34; index = self._adjust_index(int(index)) if value is _SENTINEL: return self[index] else: self[index] = value"
                }
            },
            {
                "id": 88,
                "attributes": {
                    "id": 88.0,
                    "label": "hl7.hl7.containers.Sequence._adjust_index",
                    "type": "function",
                    "code": "def _adjust_index(self, index): &#34;&#34;&#34;Subclasses can override if they do not want HL7 1-based indexing when used as callable&#34;&#34;&#34; if index >= 1: return index - 1 else: return index",
                    "signature": "def _adjust_index(self, index): &#34;&#34;&#34;Subclasses can override if they do not want HL7 1-based indexing when used as callable&#34;&#34;&#34; if index >= 1: return index - 1 else: return index"
                }
            },
            {
                "id": 90,
                "attributes": {
                    "id": 90.0,
                    "label": "hl7.hl7.containers.Container.__init__",
                    "type": "function",
                    "code": "def __init__( self, separator, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert separator in separators # Initialize the list object, optionally passing in the # sequence.  Since list([]) == [], using the default # parameter will not cause any issues. super(Container, self).__init__(sequence) self.separator = separator self.esc = esc self.separators = separators self.factory = factory if factory is not None else Factory",
                    "signature": "def __init__( self, separator, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert separator in separators # Initialize the list object, optionally passing in the # sequence.  Since list([]) == [], using the default # parameter will not cause any issues. super(Container, self).__init__(sequence) self.separator = separator self.esc = esc self.separators = separators self.factory = factory if factory is not None else Factory"
                }
            },
            {
                "id": 115,
                "attributes": {
                    "id": 115.0,
                    "label": "hl7.hl7.containers.Message",
                    "type": "class",
                    "code": "class Message(Container): def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(Message, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, )  &#34;&#34;&#34;Representation of an HL7 message. It contains a list of :py:class:`hl7.Segment` instances. &#34;&#34;&#34;  def __getitem__(self, key): &#34;&#34;&#34;Index, segment-based or accessor lookup.  If key is an integer, ``__getitem__`` acts list a list, returning the :py:class:`hl7.Segment` held at that index:  >>> h[1]  # doctest: +ELLIPSIS [['PID'], ...]  If the key is a string of length 3, ``__getitem__`` acts like a dictionary, returning all segments whose *segment_id* is *key* (alias of :py:meth:`hl7.Message.segments`).  >>> h['OBX']  # doctest: +ELLIPSIS [[['OBX'], ['1'], ...]]  If the key is a string of length greater than 3, the key is parsed into an :py:class:`hl7.Accessor` and passed to :py:meth:`hl7.Message.extract_field`.  If the key is an :py:class:`hl7.Accessor`, it is passed to :py:meth:`hl7.Message.extract_field`. &#34;&#34;&#34; if isinstance(key, str): if len(key) == 3: return self.segments(key) return self.extract_field(*Accessor.parse_key(key)) elif isinstance(key, Accessor): return self.extract_field(*key) return super(Message, self).__getitem__(key)  def __setitem__(self, key, value): &#34;&#34;&#34;Index or accessor assignment.  If key is an integer, ``__setitem__`` acts list a list, setting the :py:class:`hl7.Segment` held at that index:  >>> h[1] = hl7.Segment(&#34;|&#34;, [hl7.Field(&#34;~&#34;, ['PID'], [''])])  If the key is a string of length greater than 3, the key is parsed into an :py:class:`hl7.Accessor` and passed to :py:meth:`hl7.Message.assign_field`.  >>> h[&#34;PID.2&#34;] = &#34;NEW&#34;  If the key is an :py:class:`hl7.Accessor`, it is passed to :py:meth:`hl7.Message.assign_field`. &#34;&#34;&#34; if isinstance(key, str) and len(key) > 3 and isinstance(value, str): return self.assign_field(value, *Accessor.parse_key(key)) elif isinstance(key, Accessor): return self.assign_field(value, *key) return super(Message, self).__setitem__(key, value)  def segment(self, segment_id): &#34;&#34;&#34;Gets the first segment with the *segment_id* from the parsed *message*.  >>> h.segment('PID')  # doctest: +ELLIPSIS [['PID'], ...]  :rtype: :py:class:`hl7.Segment` &#34;&#34;&#34; # Get the list of all the segments and pull out the first one, # if possible match = self.segments(segment_id) # We should never get an IndexError, since segments will instead # throw an KeyError return match[0]  def segments(self, segment_id): &#34;&#34;&#34;Returns the requested segments from the parsed *message* that are identified by the *segment_id* (e.g. OBR, MSH, ORC, OBX).  >>> h.segments('OBX') [[['OBX'], ['1'], ...]]  :rtype: list of :py:class:`hl7.Segment` &#34;&#34;&#34; # Compare segment_id to the very first string in each segment, # returning all segments that match. # Return as a Sequence so 1-based indexing can be used matches = Sequence(segment for segment in self if segment[0][0] == segment_id) if len(matches) == 0: raise KeyError(&#34;No %s segments&#34; % segment_id) return matches  def extract_field( self, segment, segment_num=1, field_num=1, repeat_num=1, component_num=1, subcomponent_num=1, ): &#34;&#34;&#34; Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing  'PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2',  |   PID.F3.R1.C2.S2 = 'Sub-Component2' |   PID.F4.R2.C1 = 'Repeat1'  Compatibility Rules:  If the parse tree is deeper than the specified path continue following the first child branch until a leaf of the tree is encountered and return that value (which could be blank).  Example:  |   PID.F3.R1.C2 = 'Sub-Component1' (assume .SC1)  If the parse tree terminates before the full path is satisfied check each of the subsequent paths and if every one is specified at position 1 then the leaf value reached can be returned as the result.  |   PID.F4.R1.C1.SC1 = 'Repeat1'    (ignore .SC1) &#34;&#34;&#34; return self.segments(segment)(segment_num).extract_field( segment_num, field_num, repeat_num, component_num, subcomponent_num )  def assign_field( self, value, segment, segment_num=1, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34; Assign a value into a message using the tree based assignment notation. The segment must exist.  Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing &#34;&#34;&#34; self.segments(segment)(segment_num).assign_field( value, field_num, repeat_num, component_num, subcomponent_num )  def escape(self, field, app_map=None): &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  Pass through the message. Replace recognised characters with their escaped version. Return an ascii encoded string.  Functionality:  *   Replace separator characters (2.10.4) *   replace application defined characters (2.10.7) *   Replace non-ascii values with hex versions using HL7 conventions.  Incomplete:  *   replace highlight characters (2.10.3) *   How to handle the rich text substitutions. *   Merge contiguous hex values &#34;&#34;&#34; return escape(self, field, app_map)  def unescape(self, field, app_map=None): &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  This will convert the identifiable sequences. If the application provides mapping, these are also used. Items which cannot be mapped are removed  For example, the App Map count provide N, H, Zxxx values  Chapter 2: Section 2.10  At the moment, this functionality can:  *   replace the parsing characters (2.10.4) *   replace highlight characters (2.10.3) *   replace hex characters. (2.10.5) *   replace rich text characters (2.10.6) *   replace application defined characters (2.10.7)  It cannot:  *   switch code pages / ISO IR character sets &#34;&#34;&#34; return unescape(self, field, app_map)  def create_ack( self, ack_code=&#34;AA&#34;, message_id=None, application=None, facility=None ): &#34;&#34;&#34; Create an hl7 ACK response :py:class:`hl7.Message`, per spec 2.9.2, for this message.  See http://www.hl7standards.com/blog/2007/02/01/ack-message-original-mode-acknowledgement/  ``ack_code`` options are one of `AA` (Application Accept), `AR` (Application Reject), `AE` (Application Error), `CA` (Commit Accept - Enhanced Mode), `CR` (Commit Reject - Enhanced Mode), or `CE` (Commit Error - Enhanced Mode) (see HL7 Table 0008 - Acknowledgment Code) ``message_id`` control message ID for ACK, defaults to unique generated ID ``application`` name of sending application, defaults to receiving application of message ``facility`` name of sending facility, defaults to receiving facility of message &#34;&#34;&#34; source_msh = self.segment(&#34;MSH&#34;) msh = self.create_segment([self.create_field([&#34;MSH&#34;])])  msh.assign_field(str(source_msh(1)), 1) msh.assign_field(str(source_msh(2)), 2) # Sending application is source receving application msh.assign_field( str(application) if application is not None else str(source_msh(5)), 3 ) # Sending facility is source receving facility msh.assign_field( str(facility) if facility is not None else str(source_msh(6)), 4 ) # Receiving application is source sending application msh.assign_field(str(source_msh(3)), 5) # Receiving facility is source sending facility msh.assign_field(str(source_msh(4)), 6) msh.assign_field(str(datetime.datetime.utcnow().strftime(&#34;%Y%m%d%H%M%S&#34;)), 7) # Message type code msh.assign_field(&#34;ACK&#34;, 9, 1, 1) # Copy trigger event from source msh.assign_field(str(source_msh(9)(1)(2)), 9, 1, 2) msh.assign_field(&#34;ACK&#34;, 9, 1, 3) msh.assign_field( message_id if message_id is not None else generate_message_control_id(), 10 ) msh.assign_field(str(source_msh(11)), 11) msh.assign_field(str(source_msh(12)), 12)  msa = self.create_segment([self.create_field([&#34;MSA&#34;])]) msa.assign_field(str(ack_code), 1) msa.assign_field(str(source_msh(10)), 2) ack = self.create_message([msh, msa])  return ack  def __str__(self): &#34;&#34;&#34;Join a the child containers into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  >>> str(hl7.parse(message)) == message True  &#34;&#34;&#34; # Per spec, Message Construction Rules, Section 2.6 (v2.8), Message ends # with the carriage return return super(Message, self).__str__() + self.separator",
                    "signature": "class Message(Container): def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(Message, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, )  &#34;&#34;&#34;Representation of an HL7 message. It contains a list of :py:class:`hl7.Segment` instances. &#34;&#34;&#34;  def __getitem__(self, key): &#34;&#34;&#34;Index, segment-based or accessor lookup.  If key is an integer, ``__getitem__`` acts list a list, returning the :py:class:`hl7.Segment` held at that index:  >>> h[1]  # doctest: +ELLIPSIS [['PID'], ...]  If the key is a string of length 3, ``__getitem__`` acts like a dictionary, returning all segments whose *segment_id* is *key* (alias of :py:meth:`hl7.Message.segments`).  >>> h['OBX']  # doctest: +ELLIPSIS [[['OBX'], ['1'], ...]]  If the key is a string of length greater than 3, the key is parsed into an :py:class:`hl7.Accessor` and passed to :py:meth:`hl7.Message.extract_field`.  If the key is an :py:class:`hl7.Accessor`, it is passed to :py:meth:`hl7.Message.extract_field`. &#34;&#34;&#34; if isinstance(key, str): if len(key) == 3: return self.segments(key) return self.extract_field(*Accessor.parse_key(key)) elif isinstance(key, Accessor): return self.extract_field(*key) return super(Message, self).__getitem__(key)  def __setitem__(self, key, value): &#34;&#34;&#34;Index or accessor assignment.  If key is an integer, ``__setitem__`` acts list a list, setting the :py:class:`hl7.Segment` held at that index:  >>> h[1] = hl7.Segment(&#34;|&#34;, [hl7.Field(&#34;~&#34;, ['PID'], [''])])  If the key is a string of length greater than 3, the key is parsed into an :py:class:`hl7.Accessor` and passed to :py:meth:`hl7.Message.assign_field`.  >>> h[&#34;PID.2&#34;] = &#34;NEW&#34;  If the key is an :py:class:`hl7.Accessor`, it is passed to :py:meth:`hl7.Message.assign_field`. &#34;&#34;&#34; if isinstance(key, str) and len(key) > 3 and isinstance(value, str): return self.assign_field(value, *Accessor.parse_key(key)) elif isinstance(key, Accessor): return self.assign_field(value, *key) return super(Message, self).__setitem__(key, value)  def segment(self, segment_id): &#34;&#34;&#34;Gets the first segment with the *segment_id* from the parsed *message*.  >>> h.segment('PID')  # doctest: +ELLIPSIS [['PID'], ...]  :rtype: :py:class:`hl7.Segment` &#34;&#34;&#34; # Get the list of all the segments and pull out the first one, # if possible match = self.segments(segment_id) # We should never get an IndexError, since segments will instead # throw an KeyError return match[0]  def segments(self, segment_id): &#34;&#34;&#34;Returns the requested segments from the parsed *message* that are identified by the *segment_id* (e.g. OBR, MSH, ORC, OBX).  >>> h.segments('OBX') [[['OBX'], ['1'], ...]]  :rtype: list of :py:class:`hl7.Segment` &#34;&#34;&#34; # Compare segment_id to the very first string in each segment, # returning all segments that match. # Return as a Sequence so 1-based indexing can be used matches = Sequence(segment for segment in self if segment[0][0] == segment_id) if len(matches) == 0: raise KeyError(&#34;No %s segments&#34; % segment_id) return matches  def extract_field( self, segment, segment_num=1, field_num=1, repeat_num=1, component_num=1, subcomponent_num=1, ): &#34;&#34;&#34; Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing  'PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2',  |   PID.F3.R1.C2.S2 = 'Sub-Component2' |   PID.F4.R2.C1 = 'Repeat1'  Compatibility Rules:  If the parse tree is deeper than the specified path continue following the first child branch until a leaf of the tree is encountered and return that value (which could be blank).  Example:  |   PID.F3.R1.C2 = 'Sub-Component1' (assume .SC1)  If the parse tree terminates before the full path is satisfied check each of the subsequent paths and if every one is specified at position 1 then the leaf value reached can be returned as the result.  |   PID.F4.R1.C1.SC1 = 'Repeat1'    (ignore .SC1) &#34;&#34;&#34; return self.segments(segment)(segment_num).extract_field( segment_num, field_num, repeat_num, component_num, subcomponent_num )  def assign_field( self, value, segment, segment_num=1, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34; Assign a value into a message using the tree based assignment notation. The segment must exist.  Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing &#34;&#34;&#34; self.segments(segment)(segment_num).assign_field( value, field_num, repeat_num, component_num, subcomponent_num )  def escape(self, field, app_map=None): &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  Pass through the message. Replace recognised characters with their escaped version. Return an ascii encoded string.  Functionality:  *   Replace separator characters (2.10.4) *   replace application defined characters (2.10.7) *   Replace non-ascii values with hex versions using HL7 conventions.  Incomplete:  *   replace highlight characters (2.10.3) *   How to handle the rich text substitutions. *   Merge contiguous hex values &#34;&#34;&#34; return escape(self, field, app_map)  def unescape(self, field, app_map=None): &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  This will convert the identifiable sequences. If the application provides mapping, these are also used. Items which cannot be mapped are removed  For example, the App Map count provide N, H, Zxxx values  Chapter 2: Section 2.10  At the moment, this functionality can:  *   replace the parsing characters (2.10.4) *   replace highlight characters (2.10.3) *   replace hex characters. (2.10.5) *   replace rich text characters (2.10.6) *   replace application defined characters (2.10.7)  It cannot:  *   switch code pages / ISO IR character sets &#34;&#34;&#34; return unescape(self, field, app_map)  def create_ack( self, ack_code=&#34;AA&#34;, message_id=None, application=None, facility=None ): &#34;&#34;&#34; Create an hl7 ACK response :py:class:`hl7.Message`, per spec 2.9.2, for this message.  See http://www.hl7standards.com/blog/2007/02/01/ack-message-original-mode-acknowledgement/  ``ack_code`` options are one of `AA` (Application Accept), `AR` (Application Reject), `AE` (Application Error), `CA` (Commit Accept - Enhanced Mode), `CR` (Commit Reject - Enhanced Mode), or `CE` (Commit Error - Enhanced Mode) (see HL7 Table 0008 - Acknowledgment Code) ``message_id`` control message ID for ACK, defaults to unique generated ID ``application`` name of sending application, defaults to receiving application of message ``facility`` name of sending facility, defaults to receiving facility of message &#34;&#34;&#34; source_msh = self.segment(&#34;MSH&#34;) msh = self.create_segment([self.create_field([&#34;MSH&#34;])])  msh.assign_field(str(source_msh(1)), 1) msh.assign_field(str(source_msh(2)), 2) # Sending application is source receving application msh.assign_field( str(application) if application is not None else str(source_msh(5)), 3 ) # Sending facility is source receving facility msh.assign_field( str(facility) if facility is not None else str(source_msh(6)), 4 ) # Receiving application is source sending application msh.assign_field(str(source_msh(3)), 5) # Receiving facility is source sending facility msh.assign_field(str(source_msh(4)), 6) msh.assign_field(str(datetime.datetime.utcnow().strftime(&#34;%Y%m%d%H%M%S&#34;)), 7) # Message type code msh.assign_field(&#34;ACK&#34;, 9, 1, 1) # Copy trigger event from source msh.assign_field(str(source_msh(9)(1)(2)), 9, 1, 2) msh.assign_field(&#34;ACK&#34;, 9, 1, 3) msh.assign_field( message_id if message_id is not None else generate_message_control_id(), 10 ) msh.assign_field(str(source_msh(11)), 11) msh.assign_field(str(source_msh(12)), 12)  msa = self.create_segment([self.create_field([&#34;MSA&#34;])]) msa.assign_field(str(ack_code), 1) msa.assign_field(str(source_msh(10)), 2) ack = self.create_message([msh, msa])  return ack  def __str__(self): &#34;&#34;&#34;Join a the child containers into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  >>> str(hl7.parse(message)) == message True  &#34;&#34;&#34; # Per spec, Message Construction Rules, Section 2.6 (v2.8), Message ends # with the carriage return return super(Message, self).__str__() + self.separator"
                }
            },
            {
                "id": 116,
                "attributes": {
                    "id": 116.0,
                    "label": "hl7.hl7.containers.Message.__init__",
                    "type": "function",
                    "code": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(Message, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, )",
                    "signature": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(Message, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, )"
                }
            },
            {
                "id": 117,
                "attributes": {
                    "id": 117.0,
                    "label": "hl7.hl7.containers.Message.__getitem__",
                    "type": "function",
                    "code": "def __getitem__(self, key): &#34;&#34;&#34;Index, segment-based or accessor lookup.  If key is an integer, ``__getitem__`` acts list a list, returning the :py:class:`hl7.Segment` held at that index:  >>> h[1]  # doctest: +ELLIPSIS [['PID'], ...]  If the key is a string of length 3, ``__getitem__`` acts like a dictionary, returning all segments whose *segment_id* is *key* (alias of :py:meth:`hl7.Message.segments`).  >>> h['OBX']  # doctest: +ELLIPSIS [[['OBX'], ['1'], ...]]  If the key is a string of length greater than 3, the key is parsed into an :py:class:`hl7.Accessor` and passed to :py:meth:`hl7.Message.extract_field`.  If the key is an :py:class:`hl7.Accessor`, it is passed to :py:meth:`hl7.Message.extract_field`. &#34;&#34;&#34; if isinstance(key, str): if len(key) == 3: return self.segments(key) return self.extract_field(*Accessor.parse_key(key)) elif isinstance(key, Accessor): return self.extract_field(*key) return super(Message, self).__getitem__(key)",
                    "signature": "def __getitem__(self, key): &#34;&#34;&#34;Index, segment-based or accessor lookup.  If key is an integer, ``__getitem__`` acts list a list, returning the :py:class:`hl7.Segment` held at that index:  >>> h[1]  # doctest: +ELLIPSIS [['PID'], ...]  If the key is a string of length 3, ``__getitem__`` acts like a dictionary, returning all segments whose *segment_id* is *key* (alias of :py:meth:`hl7.Message.segments`).  >>> h['OBX']  # doctest: +ELLIPSIS [[['OBX'], ['1'], ...]]  If the key is a string of length greater than 3, the key is parsed into an :py:class:`hl7.Accessor` and passed to :py:meth:`hl7.Message.extract_field`.  If the key is an :py:class:`hl7.Accessor`, it is passed to :py:meth:`hl7.Message.extract_field`. &#34;&#34;&#34; if isinstance(key, str): if len(key) == 3: return self.segments(key) return self.extract_field(*Accessor.parse_key(key)) elif isinstance(key, Accessor): return self.extract_field(*key) return super(Message, self).__getitem__(key)"
                }
            },
            {
                "id": 118,
                "attributes": {
                    "id": 118.0,
                    "label": "hl7.hl7.containers.Message.__setitem__",
                    "type": "function",
                    "code": "def __setitem__(self, key, value): &#34;&#34;&#34;Index or accessor assignment.  If key is an integer, ``__setitem__`` acts list a list, setting the :py:class:`hl7.Segment` held at that index:  >>> h[1] = hl7.Segment(&#34;|&#34;, [hl7.Field(&#34;~&#34;, ['PID'], [''])])  If the key is a string of length greater than 3, the key is parsed into an :py:class:`hl7.Accessor` and passed to :py:meth:`hl7.Message.assign_field`.  >>> h[&#34;PID.2&#34;] = &#34;NEW&#34;  If the key is an :py:class:`hl7.Accessor`, it is passed to :py:meth:`hl7.Message.assign_field`. &#34;&#34;&#34; if isinstance(key, str) and len(key) > 3 and isinstance(value, str): return self.assign_field(value, *Accessor.parse_key(key)) elif isinstance(key, Accessor): return self.assign_field(value, *key) return super(Message, self).__setitem__(key, value)",
                    "signature": "def __setitem__(self, key, value): &#34;&#34;&#34;Index or accessor assignment.  If key is an integer, ``__setitem__`` acts list a list, setting the :py:class:`hl7.Segment` held at that index:  >>> h[1] = hl7.Segment(&#34;|&#34;, [hl7.Field(&#34;~&#34;, ['PID'], [''])])  If the key is a string of length greater than 3, the key is parsed into an :py:class:`hl7.Accessor` and passed to :py:meth:`hl7.Message.assign_field`.  >>> h[&#34;PID.2&#34;] = &#34;NEW&#34;  If the key is an :py:class:`hl7.Accessor`, it is passed to :py:meth:`hl7.Message.assign_field`. &#34;&#34;&#34; if isinstance(key, str) and len(key) > 3 and isinstance(value, str): return self.assign_field(value, *Accessor.parse_key(key)) elif isinstance(key, Accessor): return self.assign_field(value, *key) return super(Message, self).__setitem__(key, value)"
                }
            },
            {
                "id": 120,
                "attributes": {
                    "id": 120.0,
                    "label": "hl7.hl7.containers.Message.segments",
                    "type": "function",
                    "code": "def segments(self, segment_id): &#34;&#34;&#34;Returns the requested segments from the parsed *message* that are identified by the *segment_id* (e.g. OBR, MSH, ORC, OBX).  >>> h.segments('OBX') [[['OBX'], ['1'], ...]]  :rtype: list of :py:class:`hl7.Segment` &#34;&#34;&#34; # Compare segment_id to the very first string in each segment, # returning all segments that match. # Return as a Sequence so 1-based indexing can be used matches = Sequence(segment for segment in self if segment[0][0] == segment_id) if len(matches) == 0: raise KeyError(&#34;No %s segments&#34; % segment_id) return matches",
                    "signature": "def segments(self, segment_id): &#34;&#34;&#34;Returns the requested segments from the parsed *message* that are identified by the *segment_id* (e.g. OBR, MSH, ORC, OBX).  >>> h.segments('OBX') [[['OBX'], ['1'], ...]]  :rtype: list of :py:class:`hl7.Segment` &#34;&#34;&#34; # Compare segment_id to the very first string in each segment, # returning all segments that match. # Return as a Sequence so 1-based indexing can be used matches = Sequence(segment for segment in self if segment[0][0] == segment_id) if len(matches) == 0: raise KeyError(&#34;No %s segments&#34; % segment_id) return matches"
                }
            },
            {
                "id": 121,
                "attributes": {
                    "id": 121.0,
                    "label": "hl7.hl7.containers.Message.extract_field",
                    "type": "function",
                    "code": "def extract_field( self, segment, segment_num=1, field_num=1, repeat_num=1, component_num=1, subcomponent_num=1, ): &#34;&#34;&#34; Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing  'PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2',  |   PID.F3.R1.C2.S2 = 'Sub-Component2' |   PID.F4.R2.C1 = 'Repeat1'  Compatibility Rules:  If the parse tree is deeper than the specified path continue following the first child branch until a leaf of the tree is encountered and return that value (which could be blank).  Example:  |   PID.F3.R1.C2 = 'Sub-Component1' (assume .SC1)  If the parse tree terminates before the full path is satisfied check each of the subsequent paths and if every one is specified at position 1 then the leaf value reached can be returned as the result.  |   PID.F4.R1.C1.SC1 = 'Repeat1'    (ignore .SC1) &#34;&#34;&#34; return self.segments(segment)(segment_num).extract_field( segment_num, field_num, repeat_num, component_num, subcomponent_num )",
                    "signature": "def extract_field( self, segment, segment_num=1, field_num=1, repeat_num=1, component_num=1, subcomponent_num=1, ): &#34;&#34;&#34; Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing  'PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2',  |   PID.F3.R1.C2.S2 = 'Sub-Component2' |   PID.F4.R2.C1 = 'Repeat1'  Compatibility Rules:  If the parse tree is deeper than the specified path continue following the first child branch until a leaf of the tree is encountered and return that value (which could be blank).  Example:  |   PID.F3.R1.C2 = 'Sub-Component1' (assume .SC1)  If the parse tree terminates before the full path is satisfied check each of the subsequent paths and if every one is specified at position 1 then the leaf value reached can be returned as the result.  |   PID.F4.R1.C1.SC1 = 'Repeat1'    (ignore .SC1) &#34;&#34;&#34; return self.segments(segment)(segment_num).extract_field( segment_num, field_num, repeat_num, component_num, subcomponent_num )"
                }
            },
            {
                "id": 122,
                "attributes": {
                    "id": 122.0,
                    "label": "hl7.hl7.containers.Message.assign_field",
                    "type": "function",
                    "code": "def assign_field( self, value, segment, segment_num=1, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34; Assign a value into a message using the tree based assignment notation. The segment must exist.  Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing &#34;&#34;&#34; self.segments(segment)(segment_num).assign_field( value, field_num, repeat_num, component_num, subcomponent_num )",
                    "signature": "def assign_field( self, value, segment, segment_num=1, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34; Assign a value into a message using the tree based assignment notation. The segment must exist.  Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing &#34;&#34;&#34; self.segments(segment)(segment_num).assign_field( value, field_num, repeat_num, component_num, subcomponent_num )"
                }
            },
            {
                "id": 124,
                "attributes": {
                    "id": 124.0,
                    "label": "hl7.hl7.containers.Message.unescape",
                    "type": "function",
                    "code": "def unescape(self, field, app_map=None): &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  This will convert the identifiable sequences. If the application provides mapping, these are also used. Items which cannot be mapped are removed  For example, the App Map count provide N, H, Zxxx values  Chapter 2: Section 2.10  At the moment, this functionality can:  *   replace the parsing characters (2.10.4) *   replace highlight characters (2.10.3) *   replace hex characters. (2.10.5) *   replace rich text characters (2.10.6) *   replace application defined characters (2.10.7)  It cannot:  *   switch code pages / ISO IR character sets &#34;&#34;&#34; return unescape(self, field, app_map)",
                    "signature": "def unescape(self, field, app_map=None): &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  This will convert the identifiable sequences. If the application provides mapping, these are also used. Items which cannot be mapped are removed  For example, the App Map count provide N, H, Zxxx values  Chapter 2: Section 2.10  At the moment, this functionality can:  *   replace the parsing characters (2.10.4) *   replace highlight characters (2.10.3) *   replace hex characters. (2.10.5) *   replace rich text characters (2.10.6) *   replace application defined characters (2.10.7)  It cannot:  *   switch code pages / ISO IR character sets &#34;&#34;&#34; return unescape(self, field, app_map)"
                }
            },
            {
                "id": 127,
                "attributes": {
                    "id": 127.0,
                    "label": "hl7.hl7.containers.Segment",
                    "type": "class",
                    "code": "class Segment(Container): def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[1] super(Segment, self).__init__( separator=separators[1], sequence=sequence, esc=esc, separators=separators, factory=factory, )  &#34;&#34;&#34;Second level of an HL7 message, which represents an HL7 Segment. Traditionally this is a line of a message that ends with a carriage return and is separated by pipes. It contains a list of :py:class:`hl7.Field` instances. &#34;&#34;&#34;  def extract_field( self, segment_num=1, field_num=1, repeat_num=1, component_num=1, subcomponent_num=1, ): &#34;&#34;&#34; Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing  'PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2',  |   F3.R1.C2.S2 = 'Sub-Component2' |   F4.R2.C1 = 'Repeat1'  Compatibility Rules:  If the parse tree is deeper than the specified path continue following the first child branch until a leaf of the tree is encountered and return that value (which could be blank).  Example:  |   F3.R1.C2 = 'Sub-Component1' (assume .SC1)  If the parse tree terminates before the full path is satisfied check each of the subsequent paths and if every one is specified at position 1 then the leaf value reached can be returned as the result.  |   F4.R1.C1.SC1 = 'Repeat1'    (ignore .SC1) &#34;&#34;&#34; # Save original values for error messages accessor = Accessor( self[0][0], segment_num, field_num, repeat_num, component_num, subcomponent_num, )  field_num = field_num or 1 repeat_num = repeat_num or 1 component_num = component_num or 1 subcomponent_num = subcomponent_num or 1  if field_num < len(self): field = self(field_num) else: if repeat_num == 1 and component_num == 1 and subcomponent_num == 1: return &#34;&#34;  # Assume non-present optional value raise IndexError(&#34;Field not present: {0}&#34;.format(accessor.key))  rep = field(repeat_num)  if not isinstance(rep, Repetition): # leaf if component_num == 1 and subcomponent_num == 1: return ( rep if accessor.segment == &#34;MSH&#34; and accessor.field_num in (1, 2) else unescape(self, rep) ) raise IndexError( &#34;Field reaches leaf node before completing path: {0}&#34;.format( accessor.key ) )  if component_num > len(rep): if subcomponent_num == 1: return &#34;&#34;  # Assume non-present optional value raise IndexError(&#34;Component not present: {0}&#34;.format(accessor.key))  component = rep(component_num) if not isinstance(component, Component): # leaf if subcomponent_num == 1: return unescape(self, component) raise IndexError( &#34;Field reaches leaf node before completing path: {0}&#34;.format( accessor.key ) )  if subcomponent_num <= len(component): subcomponent = component(subcomponent_num) return unescape(self, subcomponent) else: return &#34;&#34;  # Assume non-present optional value  def assign_field( self, value, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34; Assign a value into a message using the tree based assignment notation. The segment must exist.  Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing &#34;&#34;&#34;  while len(self) <= field_num: self.append(self.create_field([])) field = self(field_num) if repeat_num is None: field[:] = [value] return while len(field) < repeat_num: field.append(self.create_repetition([])) repetition = field(repeat_num) if component_num is None: repetition[:] = [value] return while len(repetition) < component_num: repetition.append(self.create_component([])) component = repetition(component_num) if subcomponent_num is None: component[:] = [value] return while len(component) < subcomponent_num: component.append(&#34;&#34;) component(subcomponent_num, value)  def _adjust_index(self, index): # First element is the segment name, so we don't need to adjust to get 1-based return index  def __str__(self): if str(self[0]) in [&#34;MSH&#34;, &#34;FHS&#34;, &#34;BHS&#34;]: return ( str(self[0]) + str(self[1]) + str(self[2]) + str(self[1]) + self.separator.join((str(x) for x in self[3:])) ) return super(Segment, self).__str__()",
                    "signature": "class Segment(Container): def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[1] super(Segment, self).__init__( separator=separators[1], sequence=sequence, esc=esc, separators=separators, factory=factory, )  &#34;&#34;&#34;Second level of an HL7 message, which represents an HL7 Segment. Traditionally this is a line of a message that ends with a carriage return and is separated by pipes. It contains a list of :py:class:`hl7.Field` instances. &#34;&#34;&#34;  def extract_field( self, segment_num=1, field_num=1, repeat_num=1, component_num=1, subcomponent_num=1, ): &#34;&#34;&#34; Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing  'PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2',  |   F3.R1.C2.S2 = 'Sub-Component2' |   F4.R2.C1 = 'Repeat1'  Compatibility Rules:  If the parse tree is deeper than the specified path continue following the first child branch until a leaf of the tree is encountered and return that value (which could be blank).  Example:  |   F3.R1.C2 = 'Sub-Component1' (assume .SC1)  If the parse tree terminates before the full path is satisfied check each of the subsequent paths and if every one is specified at position 1 then the leaf value reached can be returned as the result.  |   F4.R1.C1.SC1 = 'Repeat1'    (ignore .SC1) &#34;&#34;&#34; # Save original values for error messages accessor = Accessor( self[0][0], segment_num, field_num, repeat_num, component_num, subcomponent_num, )  field_num = field_num or 1 repeat_num = repeat_num or 1 component_num = component_num or 1 subcomponent_num = subcomponent_num or 1  if field_num < len(self): field = self(field_num) else: if repeat_num == 1 and component_num == 1 and subcomponent_num == 1: return &#34;&#34;  # Assume non-present optional value raise IndexError(&#34;Field not present: {0}&#34;.format(accessor.key))  rep = field(repeat_num)  if not isinstance(rep, Repetition): # leaf if component_num == 1 and subcomponent_num == 1: return ( rep if accessor.segment == &#34;MSH&#34; and accessor.field_num in (1, 2) else unescape(self, rep) ) raise IndexError( &#34;Field reaches leaf node before completing path: {0}&#34;.format( accessor.key ) )  if component_num > len(rep): if subcomponent_num == 1: return &#34;&#34;  # Assume non-present optional value raise IndexError(&#34;Component not present: {0}&#34;.format(accessor.key))  component = rep(component_num) if not isinstance(component, Component): # leaf if subcomponent_num == 1: return unescape(self, component) raise IndexError( &#34;Field reaches leaf node before completing path: {0}&#34;.format( accessor.key ) )  if subcomponent_num <= len(component): subcomponent = component(subcomponent_num) return unescape(self, subcomponent) else: return &#34;&#34;  # Assume non-present optional value  def assign_field( self, value, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34; Assign a value into a message using the tree based assignment notation. The segment must exist.  Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing &#34;&#34;&#34;  while len(self) <= field_num: self.append(self.create_field([])) field = self(field_num) if repeat_num is None: field[:] = [value] return while len(field) < repeat_num: field.append(self.create_repetition([])) repetition = field(repeat_num) if component_num is None: repetition[:] = [value] return while len(repetition) < component_num: repetition.append(self.create_component([])) component = repetition(component_num) if subcomponent_num is None: component[:] = [value] return while len(component) < subcomponent_num: component.append(&#34;&#34;) component(subcomponent_num, value)  def _adjust_index(self, index): # First element is the segment name, so we don't need to adjust to get 1-based return index  def __str__(self): if str(self[0]) in [&#34;MSH&#34;, &#34;FHS&#34;, &#34;BHS&#34;]: return ( str(self[0]) + str(self[1]) + str(self[2]) + str(self[1]) + self.separator.join((str(x) for x in self[3:])) ) return super(Segment, self).__str__()"
                }
            },
            {
                "id": 128,
                "attributes": {
                    "id": 128.0,
                    "label": "hl7.hl7.containers.Segment.__init__",
                    "type": "function",
                    "code": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[1] super(Segment, self).__init__( separator=separators[1], sequence=sequence, esc=esc, separators=separators, factory=factory, )",
                    "signature": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[1] super(Segment, self).__init__( separator=separators[1], sequence=sequence, esc=esc, separators=separators, factory=factory, )"
                }
            },
            {
                "id": 129,
                "attributes": {
                    "id": 129.0,
                    "label": "hl7.hl7.containers.Segment.extract_field",
                    "type": "function",
                    "code": "def extract_field( self, segment_num=1, field_num=1, repeat_num=1, component_num=1, subcomponent_num=1, ): &#34;&#34;&#34; Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing  'PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2',  |   F3.R1.C2.S2 = 'Sub-Component2' |   F4.R2.C1 = 'Repeat1'  Compatibility Rules:  If the parse tree is deeper than the specified path continue following the first child branch until a leaf of the tree is encountered and return that value (which could be blank).  Example:  |   F3.R1.C2 = 'Sub-Component1' (assume .SC1)  If the parse tree terminates before the full path is satisfied check each of the subsequent paths and if every one is specified at position 1 then the leaf value reached can be returned as the result.  |   F4.R1.C1.SC1 = 'Repeat1'    (ignore .SC1) &#34;&#34;&#34; # Save original values for error messages accessor = Accessor( self[0][0], segment_num, field_num, repeat_num, component_num, subcomponent_num, )  field_num = field_num or 1 repeat_num = repeat_num or 1 component_num = component_num or 1 subcomponent_num = subcomponent_num or 1  if field_num < len(self): field = self(field_num) else: if repeat_num == 1 and component_num == 1 and subcomponent_num == 1: return &#34;&#34;  # Assume non-present optional value raise IndexError(&#34;Field not present: {0}&#34;.format(accessor.key))  rep = field(repeat_num)  if not isinstance(rep, Repetition): # leaf if component_num == 1 and subcomponent_num == 1: return ( rep if accessor.segment == &#34;MSH&#34; and accessor.field_num in (1, 2) else unescape(self, rep) ) raise IndexError( &#34;Field reaches leaf node before completing path: {0}&#34;.format( accessor.key ) )  if component_num > len(rep): if subcomponent_num == 1: return &#34;&#34;  # Assume non-present optional value raise IndexError(&#34;Component not present: {0}&#34;.format(accessor.key))  component = rep(component_num) if not isinstance(component, Component): # leaf if subcomponent_num == 1: return unescape(self, component) raise IndexError( &#34;Field reaches leaf node before completing path: {0}&#34;.format( accessor.key ) )  if subcomponent_num <= len(component): subcomponent = component(subcomponent_num) return unescape(self, subcomponent) else: return &#34;&#34;  # Assume non-present optional value",
                    "signature": "def extract_field( self, segment_num=1, field_num=1, repeat_num=1, component_num=1, subcomponent_num=1, ): &#34;&#34;&#34; Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing  'PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2',  |   F3.R1.C2.S2 = 'Sub-Component2' |   F4.R2.C1 = 'Repeat1'  Compatibility Rules:  If the parse tree is deeper than the specified path continue following the first child branch until a leaf of the tree is encountered and return that value (which could be blank).  Example:  |   F3.R1.C2 = 'Sub-Component1' (assume .SC1)  If the parse tree terminates before the full path is satisfied check each of the subsequent paths and if every one is specified at position 1 then the leaf value reached can be returned as the result.  |   F4.R1.C1.SC1 = 'Repeat1'    (ignore .SC1) &#34;&#34;&#34; # Save original values for error messages accessor = Accessor( self[0][0], segment_num, field_num, repeat_num, component_num, subcomponent_num, )  field_num = field_num or 1 repeat_num = repeat_num or 1 component_num = component_num or 1 subcomponent_num = subcomponent_num or 1  if field_num < len(self): field = self(field_num) else: if repeat_num == 1 and component_num == 1 and subcomponent_num == 1: return &#34;&#34;  # Assume non-present optional value raise IndexError(&#34;Field not present: {0}&#34;.format(accessor.key))  rep = field(repeat_num)  if not isinstance(rep, Repetition): # leaf if component_num == 1 and subcomponent_num == 1: return ( rep if accessor.segment == &#34;MSH&#34; and accessor.field_num in (1, 2) else unescape(self, rep) ) raise IndexError( &#34;Field reaches leaf node before completing path: {0}&#34;.format( accessor.key ) )  if component_num > len(rep): if subcomponent_num == 1: return &#34;&#34;  # Assume non-present optional value raise IndexError(&#34;Component not present: {0}&#34;.format(accessor.key))  component = rep(component_num) if not isinstance(component, Component): # leaf if subcomponent_num == 1: return unescape(self, component) raise IndexError( &#34;Field reaches leaf node before completing path: {0}&#34;.format( accessor.key ) )  if subcomponent_num <= len(component): subcomponent = component(subcomponent_num) return unescape(self, subcomponent) else: return &#34;&#34;  # Assume non-present optional value"
                }
            },
            {
                "id": 131,
                "attributes": {
                    "id": 131.0,
                    "label": "hl7.hl7.containers.Segment._adjust_index",
                    "type": "function",
                    "code": "def _adjust_index(self, index): # First element is the segment name, so we don't need to adjust to get 1-based return index",
                    "signature": "def _adjust_index(self, index): # First element is the segment name, so we don't need to adjust to get 1-based return index"
                }
            },
            {
                "id": 133,
                "attributes": {
                    "id": 133.0,
                    "label": "hl7.hl7.containers.Field",
                    "type": "class",
                    "code": "class Field(Container): def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[2] super(Field, self).__init__( separator=separators[2], sequence=sequence, esc=esc, separators=separators, factory=factory, )  &#34;&#34;&#34;Third level of an HL7 message, that traditionally is surrounded by pipes and separated by carets. It contains a list of strings or :py:class:`hl7.Repetition` instances. &#34;&#34;&#34;",
                    "signature": "class Field(Container): def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[2] super(Field, self).__init__( separator=separators[2], sequence=sequence, esc=esc, separators=separators, factory=factory, )  &#34;&#34;&#34;Third level of an HL7 message, that traditionally is surrounded by pipes and separated by carets. It contains a list of strings or :py:class:`hl7.Repetition` instances. &#34;&#34;&#34;"
                }
            },
            {
                "id": 134,
                "attributes": {
                    "id": 134.0,
                    "label": "hl7.hl7.containers.Field.__init__",
                    "type": "function",
                    "code": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[2] super(Field, self).__init__( separator=separators[2], sequence=sequence, esc=esc, separators=separators, factory=factory, )",
                    "signature": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[2] super(Field, self).__init__( separator=separators[2], sequence=sequence, esc=esc, separators=separators, factory=factory, )"
                }
            },
            {
                "id": 135,
                "attributes": {
                    "id": 135.0,
                    "label": "hl7.hl7.containers.Repetition",
                    "type": "class",
                    "code": "class Repetition(Container): def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[3] super(Repetition, self).__init__( separator=separators[3], sequence=sequence, esc=esc, separators=separators, factory=factory, )  &#34;&#34;&#34;Fourth level of an HL7 message. A field can repeat. It contains a list of strings or :py:class:`hl7.Component` instances. &#34;&#34;&#34;",
                    "signature": "class Repetition(Container): def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[3] super(Repetition, self).__init__( separator=separators[3], sequence=sequence, esc=esc, separators=separators, factory=factory, )  &#34;&#34;&#34;Fourth level of an HL7 message. A field can repeat. It contains a list of strings or :py:class:`hl7.Component` instances. &#34;&#34;&#34;"
                }
            },
            {
                "id": 136,
                "attributes": {
                    "id": 136.0,
                    "label": "hl7.hl7.containers.Repetition.__init__",
                    "type": "function",
                    "code": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[3] super(Repetition, self).__init__( separator=separators[3], sequence=sequence, esc=esc, separators=separators, factory=factory, )",
                    "signature": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[3] super(Repetition, self).__init__( separator=separators[3], sequence=sequence, esc=esc, separators=separators, factory=factory, )"
                }
            },
            {
                "id": 137,
                "attributes": {
                    "id": 137.0,
                    "label": "hl7.hl7.containers.Component",
                    "type": "class",
                    "code": "class Component(Container): def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[4] super(Component, self).__init__( separator=separators[4], sequence=sequence, esc=esc, separators=separators, factory=factory, )  &#34;&#34;&#34;Fifth level of an HL7 message. A component is a composite datatypes. It contains a list of string sub-components. &#34;&#34;&#34;",
                    "signature": "class Component(Container): def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[4] super(Component, self).__init__( separator=separators[4], sequence=sequence, esc=esc, separators=separators, factory=factory, )  &#34;&#34;&#34;Fifth level of an HL7 message. A component is a composite datatypes. It contains a list of string sub-components. &#34;&#34;&#34;"
                }
            },
            {
                "id": 138,
                "attributes": {
                    "id": 138.0,
                    "label": "hl7.hl7.containers.Component.__init__",
                    "type": "function",
                    "code": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[4] super(Component, self).__init__( separator=separators[4], sequence=sequence, esc=esc, separators=separators, factory=factory, )",
                    "signature": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[4] super(Component, self).__init__( separator=separators[4], sequence=sequence, esc=esc, separators=separators, factory=factory, )"
                }
            },
            {
                "id": 139,
                "attributes": {
                    "id": 139.0,
                    "label": "hl7.hl7.containers.Factory",
                    "type": "class",
                    "code": "class Factory(object): &#34;&#34;&#34;Factory used to create each type of Container.  A subclass can be used to create specialized subclasses of each container. &#34;&#34;&#34;  create_file = File  #: Create an instance of :py:class:`hl7.File` create_batch = Batch  #: Create an instance of :py:class:`hl7.Batch` create_message = Message  #: Create an instance of :py:class:`hl7.Message` create_segment = Segment  #: Create an instance of :py:class:`hl7.Segment` create_field = Field  #: Create an instance of :py:class:`hl7.Field` create_repetition = Repetition  #: Create an instance of :py:class:`hl7.Repetition` create_component = Component  #: Create an instance of :py:class:`hl7.Component`",
                    "signature": "class Factory(object): &#34;&#34;&#34;Factory used to create each type of Container.  A subclass can be used to create specialized subclasses of each container. &#34;&#34;&#34;  create_file = File  #: Create an instance of :py:class:`hl7.File` create_batch = Batch  #: Create an instance of :py:class:`hl7.Batch` create_message = Message  #: Create an instance of :py:class:`hl7.Message` create_segment = Segment  #: Create an instance of :py:class:`hl7.Segment` create_field = Field  #: Create an instance of :py:class:`hl7.Field` create_repetition = Repetition  #: Create an instance of :py:class:`hl7.Repetition` create_component = Component  #: Create an instance of :py:class:`hl7.Component`"
                }
            },
            {
                "id": 141,
                "attributes": {
                    "id": 141.0,
                    "label": "hl7.hl7.accessor.Accessor",
                    "type": "class",
                    "code": "class Accessor( namedtuple( &#34;Accessor&#34;, [ &#34;segment&#34;, &#34;segment_num&#34;, &#34;field_num&#34;, &#34;repeat_num&#34;, &#34;component_num&#34;, &#34;subcomponent_num&#34;, ], ) ): __slots__ = ()  def __new__( cls, segment, segment_num=1, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34;Create a new instance of Accessor for *segment*. Index numbers start from 1.&#34;&#34;&#34; return super(Accessor, cls).__new__( cls, segment, segment_num, field_num, repeat_num, component_num, subcomponent_num, )  @property def key(self): &#34;&#34;&#34;Return the string accessor key that represents this instance&#34;&#34;&#34; seg = ( self.segment if self.segment_num == 1 else self.segment + str(self.segment_num) ) return &#34;.&#34;.join( str(f) for f in [ seg, self.field_num, self.repeat_num, self.component_num, self.subcomponent_num, ] if f is not None )  def __str__(self): return self.key  @classmethod def parse_key(cls, key): &#34;&#34;&#34;Create an Accessor by parsing an accessor key.  The key is defined as:  |   SEG[n]-Fn-Rn-Cn-Sn |       F   Field |       R   Repeat |       C   Component |       S   Sub-Component | |   *Indexing is from 1 for compatibility with HL7 spec numbering.*  Example:  |   PID.F1.R1.C2.S2 or PID.1.1.2.2 | |   PID (default to first PID segment, counting from 1) |   F1  (first after segment id, HL7 Spec numbering) |   R1  (repeat counting from 1) |   C2  (component 2 counting from 1) |   S2  (component 2 counting from 1) &#34;&#34;&#34;  def parse_part(keyparts, index, prefix): if len(keyparts) > index: num = keyparts[index] if num[0].upper() == prefix: num = num[1:] return int(num) else: return None  parts = key.split(&#34;.&#34;) segment = parts[0][:3] if len(parts[0]) > 3: segment_num = int(parts[0][3:]) else: segment_num = 1 field_num = parse_part(parts, 1, &#34;F&#34;) repeat_num = parse_part(parts, 2, &#34;R&#34;) component_num = parse_part(parts, 3, &#34;C&#34;) subcomponent_num = parse_part(parts, 4, &#34;S&#34;) return cls( segment, segment_num, field_num, repeat_num, component_num, subcomponent_num )",
                    "signature": "class Accessor( namedtuple( &#34;Accessor&#34;, [ &#34;segment&#34;, &#34;segment_num&#34;, &#34;field_num&#34;, &#34;repeat_num&#34;, &#34;component_num&#34;, &#34;subcomponent_num&#34;, ], ) ): __slots__ = ()  def __new__( cls, segment, segment_num=1, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34;Create a new instance of Accessor for *segment*. Index numbers start from 1.&#34;&#34;&#34; return super(Accessor, cls).__new__( cls, segment, segment_num, field_num, repeat_num, component_num, subcomponent_num, )  @property def key(self): &#34;&#34;&#34;Return the string accessor key that represents this instance&#34;&#34;&#34; seg = ( self.segment if self.segment_num == 1 else self.segment + str(self.segment_num) ) return &#34;.&#34;.join( str(f) for f in [ seg, self.field_num, self.repeat_num, self.component_num, self.subcomponent_num, ] if f is not None )  def __str__(self): return self.key  @classmethod def parse_key(cls, key): &#34;&#34;&#34;Create an Accessor by parsing an accessor key.  The key is defined as:  |   SEG[n]-Fn-Rn-Cn-Sn |       F   Field |       R   Repeat |       C   Component |       S   Sub-Component | |   *Indexing is from 1 for compatibility with HL7 spec numbering.*  Example:  |   PID.F1.R1.C2.S2 or PID.1.1.2.2 | |   PID (default to first PID segment, counting from 1) |   F1  (first after segment id, HL7 Spec numbering) |   R1  (repeat counting from 1) |   C2  (component 2 counting from 1) |   S2  (component 2 counting from 1) &#34;&#34;&#34;  def parse_part(keyparts, index, prefix): if len(keyparts) > index: num = keyparts[index] if num[0].upper() == prefix: num = num[1:] return int(num) else: return None  parts = key.split(&#34;.&#34;) segment = parts[0][:3] if len(parts[0]) > 3: segment_num = int(parts[0][3:]) else: segment_num = 1 field_num = parse_part(parts, 1, &#34;F&#34;) repeat_num = parse_part(parts, 2, &#34;R&#34;) component_num = parse_part(parts, 3, &#34;C&#34;) subcomponent_num = parse_part(parts, 4, &#34;S&#34;) return cls( segment, segment_num, field_num, repeat_num, component_num, subcomponent_num )"
                }
            },
            {
                "id": 142,
                "attributes": {
                    "id": 142.0,
                    "label": "hl7.hl7.accessor.Accessor.__new__",
                    "type": "function",
                    "code": "def __new__( cls, segment, segment_num=1, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34;Create a new instance of Accessor for *segment*. Index numbers start from 1.&#34;&#34;&#34; return super(Accessor, cls).__new__( cls, segment, segment_num, field_num, repeat_num, component_num, subcomponent_num, )",
                    "signature": "def __new__( cls, segment, segment_num=1, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34;Create a new instance of Accessor for *segment*. Index numbers start from 1.&#34;&#34;&#34; return super(Accessor, cls).__new__( cls, segment, segment_num, field_num, repeat_num, component_num, subcomponent_num, )"
                }
            },
            {
                "id": 143,
                "attributes": {
                    "id": 143.0,
                    "label": "hl7.hl7.accessor.Accessor.key",
                    "type": "function",
                    "code": "def key(self): &#34;&#34;&#34;Return the string accessor key that represents this instance&#34;&#34;&#34; seg = ( self.segment if self.segment_num == 1 else self.segment + str(self.segment_num) ) return &#34;.&#34;.join( str(f) for f in [ seg, self.field_num, self.repeat_num, self.component_num, self.subcomponent_num, ] if f is not None )",
                    "signature": "def key(self): &#34;&#34;&#34;Return the string accessor key that represents this instance&#34;&#34;&#34; seg = ( self.segment if self.segment_num == 1 else self.segment + str(self.segment_num) ) return &#34;.&#34;.join( str(f) for f in [ seg, self.field_num, self.repeat_num, self.component_num, self.subcomponent_num, ] if f is not None )"
                }
            },
            {
                "id": 144,
                "attributes": {
                    "id": 144.0,
                    "label": "hl7.hl7.accessor.Accessor.__str__",
                    "type": "function",
                    "code": "def __str__(self): return self.key",
                    "signature": "def __str__(self): return self.key"
                }
            },
            {
                "id": 145,
                "attributes": {
                    "id": 145.0,
                    "label": "hl7.hl7.accessor.Accessor.parse_key",
                    "type": "function",
                    "code": "def parse_key(cls, key): &#34;&#34;&#34;Create an Accessor by parsing an accessor key.  The key is defined as:  |   SEG[n]-Fn-Rn-Cn-Sn |       F   Field |       R   Repeat |       C   Component |       S   Sub-Component | |   *Indexing is from 1 for compatibility with HL7 spec numbering.*  Example:  |   PID.F1.R1.C2.S2 or PID.1.1.2.2 | |   PID (default to first PID segment, counting from 1) |   F1  (first after segment id, HL7 Spec numbering) |   R1  (repeat counting from 1) |   C2  (component 2 counting from 1) |   S2  (component 2 counting from 1) &#34;&#34;&#34;  def parse_part(keyparts, index, prefix): if len(keyparts) > index: num = keyparts[index] if num[0].upper() == prefix: num = num[1:] return int(num) else: return None  parts = key.split(&#34;.&#34;) segment = parts[0][:3] if len(parts[0]) > 3: segment_num = int(parts[0][3:]) else: segment_num = 1 field_num = parse_part(parts, 1, &#34;F&#34;) repeat_num = parse_part(parts, 2, &#34;R&#34;) component_num = parse_part(parts, 3, &#34;C&#34;) subcomponent_num = parse_part(parts, 4, &#34;S&#34;) return cls( segment, segment_num, field_num, repeat_num, component_num, subcomponent_num )",
                    "signature": "def parse_key(cls, key): &#34;&#34;&#34;Create an Accessor by parsing an accessor key.  The key is defined as:  |   SEG[n]-Fn-Rn-Cn-Sn |       F   Field |       R   Repeat |       C   Component |       S   Sub-Component | |   *Indexing is from 1 for compatibility with HL7 spec numbering.*  Example:  |   PID.F1.R1.C2.S2 or PID.1.1.2.2 | |   PID (default to first PID segment, counting from 1) |   F1  (first after segment id, HL7 Spec numbering) |   R1  (repeat counting from 1) |   C2  (component 2 counting from 1) |   S2  (component 2 counting from 1) &#34;&#34;&#34;  def parse_part(keyparts, index, prefix): if len(keyparts) > index: num = keyparts[index] if num[0].upper() == prefix: num = num[1:] return int(num) else: return None  parts = key.split(&#34;.&#34;) segment = parts[0][:3] if len(parts[0]) > 3: segment_num = int(parts[0][3:]) else: segment_num = 1 field_num = parse_part(parts, 1, &#34;F&#34;) repeat_num = parse_part(parts, 2, &#34;R&#34;) component_num = parse_part(parts, 3, &#34;C&#34;) subcomponent_num = parse_part(parts, 4, &#34;S&#34;) return cls( segment, segment_num, field_num, repeat_num, component_num, subcomponent_num )"
                }
            },
            {
                "id": 146,
                "attributes": {
                    "id": 146.0,
                    "label": "hl7.hl7.accessor.Accessor.parse_key.parse_part",
                    "type": "function",
                    "code": "def parse_part(keyparts, index, prefix): if len(keyparts) > index: num = keyparts[index] if num[0].upper() == prefix: num = num[1:] return int(num) else: return None",
                    "signature": "def parse_part(keyparts, index, prefix): if len(keyparts) > index: num = keyparts[index] if num[0].upper() == prefix: num = num[1:] return int(num) else: return None"
                }
            },
            {
                "id": 299,
                "attributes": {
                    "id": 299.0,
                    "label": "hl7.tests.test_accessor.AccessorTest",
                    "type": "class",
                    "code": "class AccessorTest(TestCase): def test_key(self): self.assertEqual(&#34;FOO&#34;, Accessor(&#34;FOO&#34;).key) self.assertEqual(&#34;FOO2&#34;, Accessor(&#34;FOO&#34;, 2).key) self.assertEqual(&#34;FOO2.3&#34;, Accessor(&#34;FOO&#34;, 2, 3).key) self.assertEqual(&#34;FOO2.3.1.4.6&#34;, Accessor(&#34;FOO&#34;, 2, 3, 1, 4, 6).key)  def test_parse(self): self.assertEqual(Accessor(&#34;FOO&#34;), Accessor.parse_key(&#34;FOO&#34;)) self.assertEqual( Accessor(&#34;FOO&#34;, 2, 3, 1, 4, 6), Accessor.parse_key(&#34;FOO2.3.1.4.6&#34;) )  def test_equality(self): self.assertEqual(Accessor(&#34;FOO&#34;, 1, 3, 4), Accessor(&#34;FOO&#34;, 1, 3, 4)) self.assertNotEqual(Accessor(&#34;FOO&#34;, 1), Accessor(&#34;FOO&#34;, 2))  def test_string(self): SEP = &#34;|^~\\\\&#38;&#34; CR_SEP = &#34;\\r&#34; MSH = Segment(SEP[0], [Field(SEP[2], [&#34;MSH&#34;])]) MSA = Segment(SEP[0], [Field(SEP[2], [&#34;MSA&#34;])]) response = Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)  response[&#34;MSH.F9.R1.C1&#34;] = &#34;ORU&#34; response[&#34;MSH.F9.R1.C2&#34;] = &#34;R01&#34; response[&#34;MSH.F9.R1.C3&#34;] = &#34;&#34; response[&#34;MSH.F12.R1&#34;] = &#34;2.4&#34; response[&#34;MSA.F1.R1&#34;] = &#34;AA&#34; response[&#34;MSA.F3.R1&#34;] = &#34;Application Message&#34; self.assertEqual( str(response), &#34;MSH|^~\\\\&#38;|||||||ORU^R01^|||2.4\\rMSA|AA||Application Message\\r&#34;, )",
                    "signature": "class AccessorTest(TestCase): def test_key(self): self.assertEqual(&#34;FOO&#34;, Accessor(&#34;FOO&#34;).key) self.assertEqual(&#34;FOO2&#34;, Accessor(&#34;FOO&#34;, 2).key) self.assertEqual(&#34;FOO2.3&#34;, Accessor(&#34;FOO&#34;, 2, 3).key) self.assertEqual(&#34;FOO2.3.1.4.6&#34;, Accessor(&#34;FOO&#34;, 2, 3, 1, 4, 6).key)  def test_parse(self): self.assertEqual(Accessor(&#34;FOO&#34;), Accessor.parse_key(&#34;FOO&#34;)) self.assertEqual( Accessor(&#34;FOO&#34;, 2, 3, 1, 4, 6), Accessor.parse_key(&#34;FOO2.3.1.4.6&#34;) )  def test_equality(self): self.assertEqual(Accessor(&#34;FOO&#34;, 1, 3, 4), Accessor(&#34;FOO&#34;, 1, 3, 4)) self.assertNotEqual(Accessor(&#34;FOO&#34;, 1), Accessor(&#34;FOO&#34;, 2))  def test_string(self): SEP = &#34;|^~\\\\&#38;&#34; CR_SEP = &#34;\\r&#34; MSH = Segment(SEP[0], [Field(SEP[2], [&#34;MSH&#34;])]) MSA = Segment(SEP[0], [Field(SEP[2], [&#34;MSA&#34;])]) response = Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)  response[&#34;MSH.F9.R1.C1&#34;] = &#34;ORU&#34; response[&#34;MSH.F9.R1.C2&#34;] = &#34;R01&#34; response[&#34;MSH.F9.R1.C3&#34;] = &#34;&#34; response[&#34;MSH.F12.R1&#34;] = &#34;2.4&#34; response[&#34;MSA.F1.R1&#34;] = &#34;AA&#34; response[&#34;MSA.F3.R1&#34;] = &#34;Application Message&#34; self.assertEqual( str(response), &#34;MSH|^~\\\\&#38;|||||||ORU^R01^|||2.4\\rMSA|AA||Application Message\\r&#34;, )"
                }
            },
            {
                "id": 300,
                "attributes": {
                    "id": 300.0,
                    "label": "hl7.tests.test_accessor.AccessorTest.test_key",
                    "type": "function",
                    "code": "def test_key(self): self.assertEqual(&#34;FOO&#34;, Accessor(&#34;FOO&#34;).key) self.assertEqual(&#34;FOO2&#34;, Accessor(&#34;FOO&#34;, 2).key) self.assertEqual(&#34;FOO2.3&#34;, Accessor(&#34;FOO&#34;, 2, 3).key) self.assertEqual(&#34;FOO2.3.1.4.6&#34;, Accessor(&#34;FOO&#34;, 2, 3, 1, 4, 6).key)",
                    "signature": "def test_key(self): self.assertEqual(&#34;FOO&#34;, Accessor(&#34;FOO&#34;).key) self.assertEqual(&#34;FOO2&#34;, Accessor(&#34;FOO&#34;, 2).key) self.assertEqual(&#34;FOO2.3&#34;, Accessor(&#34;FOO&#34;, 2, 3).key) self.assertEqual(&#34;FOO2.3.1.4.6&#34;, Accessor(&#34;FOO&#34;, 2, 3, 1, 4, 6).key)"
                }
            },
            {
                "id": 301,
                "attributes": {
                    "id": 301.0,
                    "label": "hl7.tests.test_accessor.AccessorTest.test_parse",
                    "type": "function",
                    "code": "def test_parse(self): self.assertEqual(Accessor(&#34;FOO&#34;), Accessor.parse_key(&#34;FOO&#34;)) self.assertEqual( Accessor(&#34;FOO&#34;, 2, 3, 1, 4, 6), Accessor.parse_key(&#34;FOO2.3.1.4.6&#34;) )",
                    "signature": "def test_parse(self): self.assertEqual(Accessor(&#34;FOO&#34;), Accessor.parse_key(&#34;FOO&#34;)) self.assertEqual( Accessor(&#34;FOO&#34;, 2, 3, 1, 4, 6), Accessor.parse_key(&#34;FOO2.3.1.4.6&#34;) )"
                }
            },
            {
                "id": 302,
                "attributes": {
                    "id": 302.0,
                    "label": "hl7.tests.test_accessor.AccessorTest.test_equality",
                    "type": "function",
                    "code": "def test_equality(self): self.assertEqual(Accessor(&#34;FOO&#34;, 1, 3, 4), Accessor(&#34;FOO&#34;, 1, 3, 4)) self.assertNotEqual(Accessor(&#34;FOO&#34;, 1), Accessor(&#34;FOO&#34;, 2))",
                    "signature": "def test_equality(self): self.assertEqual(Accessor(&#34;FOO&#34;, 1, 3, 4), Accessor(&#34;FOO&#34;, 1, 3, 4)) self.assertNotEqual(Accessor(&#34;FOO&#34;, 1), Accessor(&#34;FOO&#34;, 2))"
                }
            },
            {
                "id": 303,
                "attributes": {
                    "id": 303.0,
                    "label": "hl7.tests.test_accessor.AccessorTest.test_string",
                    "type": "function",
                    "code": "def test_string(self): SEP = &#34;|^~\\\\&#38;&#34; CR_SEP = &#34;\\r&#34; MSH = Segment(SEP[0], [Field(SEP[2], [&#34;MSH&#34;])]) MSA = Segment(SEP[0], [Field(SEP[2], [&#34;MSA&#34;])]) response = Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)  response[&#34;MSH.F9.R1.C1&#34;] = &#34;ORU&#34; response[&#34;MSH.F9.R1.C2&#34;] = &#34;R01&#34; response[&#34;MSH.F9.R1.C3&#34;] = &#34;&#34; response[&#34;MSH.F12.R1&#34;] = &#34;2.4&#34; response[&#34;MSA.F1.R1&#34;] = &#34;AA&#34; response[&#34;MSA.F3.R1&#34;] = &#34;Application Message&#34; self.assertEqual( str(response), &#34;MSH|^~\\\\&#38;|||||||ORU^R01^|||2.4\\rMSA|AA||Application Message\\r&#34;, )",
                    "signature": "def test_string(self): SEP = &#34;|^~\\\\&#38;&#34; CR_SEP = &#34;\\r&#34; MSH = Segment(SEP[0], [Field(SEP[2], [&#34;MSH&#34;])]) MSA = Segment(SEP[0], [Field(SEP[2], [&#34;MSA&#34;])]) response = Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)  response[&#34;MSH.F9.R1.C1&#34;] = &#34;ORU&#34; response[&#34;MSH.F9.R1.C2&#34;] = &#34;R01&#34; response[&#34;MSH.F9.R1.C3&#34;] = &#34;&#34; response[&#34;MSH.F12.R1&#34;] = &#34;2.4&#34; response[&#34;MSA.F1.R1&#34;] = &#34;AA&#34; response[&#34;MSA.F3.R1&#34;] = &#34;Application Message&#34; self.assertEqual( str(response), &#34;MSH|^~\\\\&#38;|||||||ORU^R01^|||2.4\\rMSA|AA||Application Message\\r&#34;, )"
                }
            },
            {
                "id": 419,
                "attributes": {
                    "id": 419.0,
                    "label": "hl7.tests.test_construction.ConstructionTest",
                    "type": "class",
                    "code": "class ConstructionTest(TestCase): def test_create_msg(self): # Create a message MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response = hl7.Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)  def test_append(self): # Append a segment to a message MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) response = hl7.Message(CR_SEP, [MSH]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response.append(MSA) self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)  def test_append_from_source(self): # Copy a segment between messages MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response = hl7.Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;) src_msg = hl7.parse(rep_sample_hl7) PID = src_msg[&#34;PID&#34;][0] self.assertEqual( str(PID), &#34;PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2&#34;, ) response.append(PID) self.assertEqual( str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\rPID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2\\r&#34;, )",
                    "signature": "class ConstructionTest(TestCase): def test_create_msg(self): # Create a message MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response = hl7.Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)  def test_append(self): # Append a segment to a message MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) response = hl7.Message(CR_SEP, [MSH]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response.append(MSA) self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)  def test_append_from_source(self): # Copy a segment between messages MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response = hl7.Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;) src_msg = hl7.parse(rep_sample_hl7) PID = src_msg[&#34;PID&#34;][0] self.assertEqual( str(PID), &#34;PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2&#34;, ) response.append(PID) self.assertEqual( str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\rPID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2\\r&#34;, )"
                }
            },
            {
                "id": 420,
                "attributes": {
                    "id": 420.0,
                    "label": "hl7.tests.test_construction.ConstructionTest.test_create_msg",
                    "type": "function",
                    "code": "def test_create_msg(self): # Create a message MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response = hl7.Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)",
                    "signature": "def test_create_msg(self): # Create a message MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response = hl7.Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)"
                }
            },
            {
                "id": 421,
                "attributes": {
                    "id": 421.0,
                    "label": "hl7.tests.test_construction.ConstructionTest.test_append",
                    "type": "function",
                    "code": "def test_append(self): # Append a segment to a message MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) response = hl7.Message(CR_SEP, [MSH]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response.append(MSA) self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)",
                    "signature": "def test_append(self): # Append a segment to a message MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) response = hl7.Message(CR_SEP, [MSH]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response.append(MSA) self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;)"
                }
            },
            {
                "id": 422,
                "attributes": {
                    "id": 422.0,
                    "label": "hl7.tests.test_construction.ConstructionTest.test_append_from_source",
                    "type": "function",
                    "code": "def test_append_from_source(self): # Copy a segment between messages MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response = hl7.Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;) src_msg = hl7.parse(rep_sample_hl7) PID = src_msg[&#34;PID&#34;][0] self.assertEqual( str(PID), &#34;PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2&#34;, ) response.append(PID) self.assertEqual( str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\rPID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2\\r&#34;, )",
                    "signature": "def test_append_from_source(self): # Copy a segment between messages MSH = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSH&#34;])]) MSA = hl7.Segment(SEP[0], [hl7.Field(SEP[2], [&#34;MSA&#34;])]) response = hl7.Message(CR_SEP, [MSH, MSA]) response[&#34;MSH.F1.R1&#34;] = SEP[0] response[&#34;MSH.F2.R1&#34;] = SEP[1:] self.assertEqual(str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\r&#34;) src_msg = hl7.parse(rep_sample_hl7) PID = src_msg[&#34;PID&#34;][0] self.assertEqual( str(PID), &#34;PID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2&#34;, ) response.append(PID) self.assertEqual( str(response), &#34;MSH|^~\\\\&#38;|\\rMSA\\rPID|Field1|Component1^Component2|Component1^Sub-Component1&#38;Sub-Component2^Component3|Repeat1~Repeat2\\r&#34;, )"
                }
            }
        ]
    },
    "5": {
        "nodes": [
            {
                "id": 0,
                "attributes": {
                    "id": 0.0,
                    "label": "hl7",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 1,
                "attributes": {
                    "id": 1.0,
                    "label": "hl7..pytest_cache",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 2,
                "attributes": {
                    "id": 2.0,
                    "label": "hl7..pytest_cache.v",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 3,
                "attributes": {
                    "id": 3.0,
                    "label": "hl7..pytest_cache.v.cache",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 148,
                "attributes": {
                    "id": 148.0,
                    "label": "hl7.tests",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 149,
                "attributes": {
                    "id": 149.0,
                    "label": "hl7.tests.backports",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 150,
                "attributes": {
                    "id": 150.0,
                    "label": "hl7.tests.backports.unittest",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 280,
                "attributes": {
                    "id": 280.0,
                    "label": "hl7.tests.backports.unittest.async_case",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 296,
                "attributes": {
                    "id": 296.0,
                    "label": "hl7.tests.backports.unittest.__init__",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 297,
                "attributes": {
                    "id": 297.0,
                    "label": "hl7.tests.backports.__init__",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 298,
                "attributes": {
                    "id": 298.0,
                    "label": "hl7.tests.test_accessor",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 304,
                "attributes": {
                    "id": 304.0,
                    "label": "hl7.tests.test_client",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 334,
                "attributes": {
                    "id": 334.0,
                    "label": "hl7.tests.test_mllp",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 347,
                "attributes": {
                    "id": 347.0,
                    "label": "hl7.tests.test_mllp.HL7StreamReaderTest",
                    "type": "class",
                    "code": "class HL7StreamReaderTest(IsolatedAsyncioTestCase): def setUp(self): self.reader = hl7.mllp.HL7StreamReader()  async def test_readblock(self): message = r&#34;MSH|^~\\&#38;|LABADT|DH|EPICADT|DH|201301011228||ACK^A01^ACK|HL7ACK00001|P|2.3\\r&#34; message += &#34;MSA|AA|HL7MSG00001\\r&#34; self.reader.feed_data( START_BLOCK + message.encode() + END_BLOCK + CARRIAGE_RETURN ) hl7_message = await self.reader.readmessage() self.assertEqual(str(hl7_message), str(hl7.parse(message)))",
                    "signature": "class HL7StreamReaderTest(IsolatedAsyncioTestCase): def setUp(self): self.reader = hl7.mllp.HL7StreamReader()  async def test_readblock(self): message = r&#34;MSH|^~\\&#38;|LABADT|DH|EPICADT|DH|201301011228||ACK^A01^ACK|HL7ACK00001|P|2.3\\r&#34; message += &#34;MSA|AA|HL7MSG00001\\r&#34; self.reader.feed_data( START_BLOCK + message.encode() + END_BLOCK + CARRIAGE_RETURN ) hl7_message = await self.reader.readmessage() self.assertEqual(str(hl7_message), str(hl7.parse(message)))"
                }
            },
            {
                "id": 350,
                "attributes": {
                    "id": 350.0,
                    "label": "hl7.tests.test_parse",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 390,
                "attributes": {
                    "id": 390.0,
                    "label": "hl7.tests.samples",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 402,
                "attributes": {
                    "id": 402.0,
                    "label": "hl7.tests.__pycache__",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 410,
                "attributes": {
                    "id": 410.0,
                    "label": "hl7.tests.test_util",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 418,
                "attributes": {
                    "id": 418.0,
                    "label": "hl7.tests.test_construction",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 423,
                "attributes": {
                    "id": 423.0,
                    "label": "hl7.tests.__init__",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 424,
                "attributes": {
                    "id": 424.0,
                    "label": "hl7.tests.test_containers",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 438,
                "attributes": {
                    "id": 438.0,
                    "label": "hl7.tests.test_containers.TestMessage",
                    "type": "class",
                    "code": "class TestMessage(hl7.Message): pass",
                    "signature": "class TestMessage(hl7.Message): pass"
                }
            },
            {
                "id": 439,
                "attributes": {
                    "id": 439.0,
                    "label": "hl7.tests.test_containers.TestSegment",
                    "type": "class",
                    "code": "class TestSegment(hl7.Segment): pass",
                    "signature": "class TestSegment(hl7.Segment): pass"
                }
            },
            {
                "id": 440,
                "attributes": {
                    "id": 440.0,
                    "label": "hl7.tests.test_containers.TestField",
                    "type": "class",
                    "code": "class TestField(hl7.Field): pass",
                    "signature": "class TestField(hl7.Field): pass"
                }
            },
            {
                "id": 441,
                "attributes": {
                    "id": 441.0,
                    "label": "hl7.tests.test_containers.TestRepetition",
                    "type": "class",
                    "code": "class TestRepetition(hl7.Repetition): pass",
                    "signature": "class TestRepetition(hl7.Repetition): pass"
                }
            },
            {
                "id": 442,
                "attributes": {
                    "id": 442.0,
                    "label": "hl7.tests.test_containers.TestComponent",
                    "type": "class",
                    "code": "class TestComponent(hl7.Component): pass",
                    "signature": "class TestComponent(hl7.Component): pass"
                }
            },
            {
                "id": 443,
                "attributes": {
                    "id": 443.0,
                    "label": "hl7.tests.test_containers.TestFactory",
                    "type": "class",
                    "code": "class TestFactory(hl7.Factory): create_message = TestMessage create_segment = TestSegment create_field = TestField create_repetition = TestRepetition create_component = TestComponent",
                    "signature": "class TestFactory(hl7.Factory): create_message = TestMessage create_segment = TestSegment create_field = TestField create_repetition = TestRepetition create_component = TestComponent"
                }
            },
            {
                "id": 448,
                "attributes": {
                    "id": 448.0,
                    "label": "hl7.docs",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 449,
                "attributes": {
                    "id": 449.0,
                    "label": "hl7.docs.conf",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 450,
                "attributes": {
                    "id": 450.0,
                    "label": "hl7.docs._static",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 451,
                "attributes": {
                    "id": 451.0,
                    "label": "hl7.docs._templates",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 452,
                "attributes": {
                    "id": 452.0,
                    "label": "hl7..github",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 453,
                "attributes": {
                    "id": 453.0,
                    "label": "hl7..github.workflows",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 454,
                "attributes": {
                    "id": 454.0,
                    "label": "hl7.hl7.egg-info",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 464,
                "attributes": {
                    "id": 464.0,
                    "label": "sys",
                    "type": "standard_library",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 466,
                "attributes": {
                    "id": 466.0,
                    "label": "os",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 467,
                "attributes": {
                    "id": 467.0,
                    "label": "asyncio",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 468,
                "attributes": {
                    "id": 468.0,
                    "label": "asyncio.streams",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 469,
                "attributes": {
                    "id": 469.0,
                    "label": "hl7.mllp",
                    "type": "unknown",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 477,
                "attributes": {
                    "id": 477.0,
                    "label": "inspect",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            }
        ]
    },
    "6": {
        "nodes": [
            {
                "id": 70,
                "attributes": {
                    "id": 70.0,
                    "label": "hl7.hl7.client",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 71,
                "attributes": {
                    "id": 71.0,
                    "label": "hl7.hl7.client.MLLPException",
                    "type": "class",
                    "code": "class MLLPException(Exception): pass",
                    "signature": "class MLLPException(Exception): pass"
                }
            },
            {
                "id": 79,
                "attributes": {
                    "id": 79.0,
                    "label": "hl7.hl7.client.stdout",
                    "type": "function",
                    "code": "def stdout(content): # In Python 3, can't write bytes via sys.stdout.write #   http://bugs.python.org/issue18512 if isinstance(content, bytes): out = sys.stdout.buffer newline = b&#34;\\n&#34; else: out = sys.stdout newline = &#34;\\n&#34;  out.write(content + newline)",
                    "signature": "def stdout(content): # In Python 3, can't write bytes via sys.stdout.write #   http://bugs.python.org/issue18512 if isinstance(content, bytes): out = sys.stdout.buffer newline = b&#34;\\n&#34; else: out = sys.stdout newline = &#34;\\n&#34;  out.write(content + newline)"
                }
            },
            {
                "id": 80,
                "attributes": {
                    "id": 80.0,
                    "label": "hl7.hl7.client.stdin",
                    "type": "function",
                    "code": "def stdin(): return sys.stdin",
                    "signature": "def stdin(): return sys.stdin"
                }
            },
            {
                "id": 81,
                "attributes": {
                    "id": 81.0,
                    "label": "hl7.hl7.client.stderr",
                    "type": "function",
                    "code": "def stderr(): return sys.stderr",
                    "signature": "def stderr(): return sys.stderr"
                }
            },
            {
                "id": 82,
                "attributes": {
                    "id": 82.0,
                    "label": "hl7.hl7.client.read_stream",
                    "type": "function",
                    "code": "def read_stream(stream): &#34;&#34;&#34;Buffer the stream and yield individual, stripped messages&#34;&#34;&#34; _buffer = b&#34;&#34;  while True: data = stream.read(RECV_BUFFER) if data == b&#34;&#34;: break # usually should be broken up by EB, but I have seen FF separating # messages messages = (_buffer + data).split(EB if FF not in data else FF)  # whatever is in the last chunk is an uncompleted message, so put back # into the buffer _buffer = messages.pop(-1)  for m in messages: yield m.strip(SB + CR)  if len(_buffer.strip()) > 0: raise MLLPException(&#34;buffer not terminated: %s&#34; % _buffer)",
                    "signature": "def read_stream(stream): &#34;&#34;&#34;Buffer the stream and yield individual, stripped messages&#34;&#34;&#34; _buffer = b&#34;&#34;  while True: data = stream.read(RECV_BUFFER) if data == b&#34;&#34;: break # usually should be broken up by EB, but I have seen FF separating # messages messages = (_buffer + data).split(EB if FF not in data else FF)  # whatever is in the last chunk is an uncompleted message, so put back # into the buffer _buffer = messages.pop(-1)  for m in messages: yield m.strip(SB + CR)  if len(_buffer.strip()) > 0: raise MLLPException(&#34;buffer not terminated: %s&#34; % _buffer)"
                }
            },
            {
                "id": 83,
                "attributes": {
                    "id": 83.0,
                    "label": "hl7.hl7.client.read_loose",
                    "type": "function",
                    "code": "def read_loose(stream): &#34;&#34;&#34;Turn a HL7-like blob of text into a real HL7 messages&#34;&#34;&#34; # look for the START_BLOCK to delineate messages START_BLOCK = rb&#34;MSH|^~\\&#38;|&#34;  # load all the data data = stream.read()  # Take out all the typical MLLP separators. In Python 3, iterating # through a bytestring returns ints, so we need to filter out the int # versions of the separators, then convert back from a list of ints to # a bytestring. # WARNING: There is an assumption here that we can treat the data as single bytes #   when filtering out the separators. separators = [bs[0] for bs in [EB, FF, SB]] data = bytes(b for b in data if b not in separators) # Windows &#38; Unix new lines to segment separators data = data.replace(b&#34;\\r\\n&#34;, b&#34;\\r&#34;).replace(b&#34;\\n&#34;, b&#34;\\r&#34;)  for m in data.split(START_BLOCK): if not m: # the first element will not have any data from the split continue  # strip any trailing whitespace m = m.strip(CR + b&#34;\\n &#34;)  # re-insert the START_BLOCK, which was removed via the split yield START_BLOCK + m",
                    "signature": "def read_loose(stream): &#34;&#34;&#34;Turn a HL7-like blob of text into a real HL7 messages&#34;&#34;&#34; # look for the START_BLOCK to delineate messages START_BLOCK = rb&#34;MSH|^~\\&#38;|&#34;  # load all the data data = stream.read()  # Take out all the typical MLLP separators. In Python 3, iterating # through a bytestring returns ints, so we need to filter out the int # versions of the separators, then convert back from a list of ints to # a bytestring. # WARNING: There is an assumption here that we can treat the data as single bytes #   when filtering out the separators. separators = [bs[0] for bs in [EB, FF, SB]] data = bytes(b for b in data if b not in separators) # Windows &#38; Unix new lines to segment separators data = data.replace(b&#34;\\r\\n&#34;, b&#34;\\r&#34;).replace(b&#34;\\n&#34;, b&#34;\\r&#34;)  for m in data.split(START_BLOCK): if not m: # the first element will not have any data from the split continue  # strip any trailing whitespace m = m.strip(CR + b&#34;\\n &#34;)  # re-insert the START_BLOCK, which was removed via the split yield START_BLOCK + m"
                }
            },
            {
                "id": 84,
                "attributes": {
                    "id": 84.0,
                    "label": "hl7.hl7.client.mllp_send",
                    "type": "function",
                    "code": "def mllp_send(): &#34;&#34;&#34;Command line tool to send messages to an MLLP server&#34;&#34;&#34; # set up the command line options script_name = os.path.basename(sys.argv[0]) parser = OptionParser(usage=script_name + &#34; [options] <server>&#34;) parser.add_option( &#34;--version&#34;, action=&#34;store_true&#34;, dest=&#34;version&#34;, default=False, help=&#34;print current version and exit&#34;, ) parser.add_option( &#34;-p&#34;, &#34;--port&#34;, action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;port&#34;, default=6661, help=&#34;port to connect to&#34;, ) parser.add_option( &#34;-f&#34;, &#34;--file&#34;, dest=&#34;filename&#34;, help=&#34;read from FILE instead of stdin&#34;, metavar=&#34;FILE&#34;, ) parser.add_option( &#34;-q&#34;, &#34;--quiet&#34;, action=&#34;store_true&#34;, dest=&#34;verbose&#34;, default=True, help=&#34;do not print status messages to stdout&#34;, ) parser.add_option( &#34;--loose&#34;, action=&#34;store_true&#34;, dest=&#34;loose&#34;, default=False, help=( &#34;allow file to be a HL7-like object (\\\\r\\\\n instead &#34; &#34;of \\\\r). Requires that messages start with &#34; '&#34;MSH|^~\\\\&#38;|&#34;. Requires --file option (no stdin)' ), )  (options, args) = parser.parse_args()  if options.version: import hl7  stdout(hl7.__version__) return  if len(args) == 1: host = args[0] else: # server not present parser.print_usage() stderr().write(&#34;server required\\n&#34;) sys.exit(1) return  # for testing when sys.exit mocked  if options.filename is not None: # Previously set stream to the open() handle, but then we did not # close the open file handle.  This new approach consumes the entire # file into memory before starting to process, which is not required # or ideal, since we can handle a stream with open(options.filename, &#34;rb&#34;) as f: stream = io.BytesIO(f.read()) else: if options.loose: stderr().write(&#34;--loose requires --file\\n&#34;) sys.exit(1) return  # for testing when sys.exit mocked  stream = stdin()  with MLLPClient(host, options.port) as client: message_stream = ( read_stream(stream) if not options.loose else read_loose(stream) )  for message in message_stream: result = client.send_message(message) if options.verbose: stdout(result)",
                    "signature": "def mllp_send(): &#34;&#34;&#34;Command line tool to send messages to an MLLP server&#34;&#34;&#34; # set up the command line options script_name = os.path.basename(sys.argv[0]) parser = OptionParser(usage=script_name + &#34; [options] <server>&#34;) parser.add_option( &#34;--version&#34;, action=&#34;store_true&#34;, dest=&#34;version&#34;, default=False, help=&#34;print current version and exit&#34;, ) parser.add_option( &#34;-p&#34;, &#34;--port&#34;, action=&#34;store&#34;, type=&#34;int&#34;, dest=&#34;port&#34;, default=6661, help=&#34;port to connect to&#34;, ) parser.add_option( &#34;-f&#34;, &#34;--file&#34;, dest=&#34;filename&#34;, help=&#34;read from FILE instead of stdin&#34;, metavar=&#34;FILE&#34;, ) parser.add_option( &#34;-q&#34;, &#34;--quiet&#34;, action=&#34;store_true&#34;, dest=&#34;verbose&#34;, default=True, help=&#34;do not print status messages to stdout&#34;, ) parser.add_option( &#34;--loose&#34;, action=&#34;store_true&#34;, dest=&#34;loose&#34;, default=False, help=( &#34;allow file to be a HL7-like object (\\\\r\\\\n instead &#34; &#34;of \\\\r). Requires that messages start with &#34; '&#34;MSH|^~\\\\&#38;|&#34;. Requires --file option (no stdin)' ), )  (options, args) = parser.parse_args()  if options.version: import hl7  stdout(hl7.__version__) return  if len(args) == 1: host = args[0] else: # server not present parser.print_usage() stderr().write(&#34;server required\\n&#34;) sys.exit(1) return  # for testing when sys.exit mocked  if options.filename is not None: # Previously set stream to the open() handle, but then we did not # close the open file handle.  This new approach consumes the entire # file into memory before starting to process, which is not required # or ideal, since we can handle a stream with open(options.filename, &#34;rb&#34;) as f: stream = io.BytesIO(f.read()) else: if options.loose: stderr().write(&#34;--loose requires --file\\n&#34;) sys.exit(1) return  # for testing when sys.exit mocked  stream = stdin()  with MLLPClient(host, options.port) as client: message_stream = ( read_stream(stream) if not options.loose else read_loose(stream) )  for message in message_stream: result = client.send_message(message) if options.verbose: stdout(result)"
                }
            },
            {
                "id": 316,
                "attributes": {
                    "id": 316.0,
                    "label": "hl7.tests.test_client.MLLPSendTest",
                    "type": "class",
                    "code": "class MLLPSendTest(TestCase): def setUp(self): # patch to avoid touching sys and socket self.socket_patch = patch(&#34;hl7.client.socket.socket&#34;) self.mock_socket = self.socket_patch.start() self.mock_socket().recv.return_value = &#34;thanks&#34;  self.stdout_patch = patch(&#34;hl7.client.stdout&#34;) self.mock_stdout = self.stdout_patch.start()  self.stdin_patch = patch(&#34;hl7.client.stdin&#34;) self.mock_stdin = self.stdin_patch.start()  self.stderr_patch = patch(&#34;hl7.client.stderr&#34;) self.mock_stderr = self.stderr_patch.start()  self.exit_patch = patch(&#34;hl7.client.sys.exit&#34;) self.mock_exit = self.exit_patch.start()  # we need a temporary directory self.dir = mkdtemp() self.write(SB + b&#34;foobar&#34; + EB + CR)  self.option_values = Values( { &#34;port&#34;: 6661, &#34;filename&#34;: os.path.join(self.dir, &#34;test.hl7&#34;), &#34;verbose&#34;: True, &#34;loose&#34;: False, &#34;version&#34;: False, } )  self.options_patch = patch(&#34;hl7.client.OptionParser&#34;) option_parser = self.options_patch.start() self.mock_options = Mock() option_parser.return_value = self.mock_options self.mock_options.parse_args.return_value = (self.option_values, [&#34;localhost&#34;])  def tearDown(self): # unpatch self.socket_patch.stop() self.options_patch.stop() self.stdout_patch.stop() self.stdin_patch.stop() self.stderr_patch.stop() self.exit_patch.stop()  # clean up the temp directory rmtree(self.dir)  def write(self, content, path=&#34;test.hl7&#34;): with open(os.path.join(self.dir, path), &#34;wb&#34;) as f: f.write(content)  def test_send(self): mllp_send()  self.mock_socket().connect.assert_called_once_with((&#34;localhost&#34;, 6661)) self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR) self.mock_stdout.assert_called_once_with(&#34;thanks&#34;) self.assertFalse(self.mock_exit.called)  def test_send_multiple(self): self.mock_socket().recv.return_value = &#34;thanks&#34; self.write(SB + b&#34;foobar&#34; + EB + CR + SB + b&#34;hello&#34; + EB + CR)  mllp_send()  self.assertEqual( self.mock_socket().send.call_args_list[0][0][0], SB + b&#34;foobar&#34; + EB + CR ) self.assertEqual( self.mock_socket().send.call_args_list[1][0][0], SB + b&#34;hello&#34; + EB + CR )  def test_leftover_buffer(self): self.write(SB + b&#34;foobar&#34; + EB + CR + SB + b&#34;stuff&#34;)  self.assertRaises(MLLPException, mllp_send)  self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR)  def test_quiet(self): self.option_values.verbose = False  mllp_send()  self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR) self.assertFalse(self.mock_stdout.called)  def test_port(self): self.option_values.port = 7890  mllp_send()  self.mock_socket().connect.assert_called_once_with((&#34;localhost&#34;, 7890))  def test_stdin(self): self.option_values.filename = None self.mock_stdin.return_value = FakeStream()  mllp_send()  self.mock_socket().send.assert_called_once_with(SB + b&#34;hello&#34; + EB + CR)  def test_loose_no_stdin(self): self.option_values.loose = True self.option_values.filename = None self.mock_stdin.return_value = FakeStream()  mllp_send()  self.assertFalse(self.mock_socket().send.called) self.mock_stderr().write.assert_called_with(&#34;--loose requires --file\\n&#34;) self.mock_exit.assert_called_with(1)  def test_loose_windows_newline(self): self.option_values.loose = True self.write(SB + b&#34;MSH|^~\\\\&#38;|foo\\r\\nbar\\r\\n&#34; + EB + CR)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )  def test_loose_unix_newline(self): self.option_values.loose = True self.write(SB + b&#34;MSH|^~\\\\&#38;|foo\\nbar\\n&#34; + EB + CR)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )  def test_loose_no_mllp_characters(self): self.option_values.loose = True self.write(b&#34;MSH|^~\\\\&#38;|foo\\r\\nbar\\r\\n&#34;)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )  def test_loose_send_mutliple(self): self.option_values.loose = True self.mock_socket().recv.return_value = &#34;thanks&#34; self.write(b&#34;MSH|^~\\\\&#38;|1\\r\\nOBX|1\\r\\nMSH|^~\\\\&#38;|2\\r\\nOBX|2\\r\\n&#34;)  mllp_send()  self.assertEqual( self.mock_socket().send.call_args_list[0][0][0], SB + b&#34;MSH|^~\\\\&#38;|1\\rOBX|1&#34; + EB + CR, ) self.assertEqual( self.mock_socket().send.call_args_list[1][0][0], SB + b&#34;MSH|^~\\\\&#38;|2\\rOBX|2&#34; + EB + CR, )  def test_version(self): self.option_values.version = True  mllp_send()  self.assertFalse(self.mock_socket().connect.called) self.mock_stdout.assert_called_once_with(str(hl7_version))",
                    "signature": "class MLLPSendTest(TestCase): def setUp(self): # patch to avoid touching sys and socket self.socket_patch = patch(&#34;hl7.client.socket.socket&#34;) self.mock_socket = self.socket_patch.start() self.mock_socket().recv.return_value = &#34;thanks&#34;  self.stdout_patch = patch(&#34;hl7.client.stdout&#34;) self.mock_stdout = self.stdout_patch.start()  self.stdin_patch = patch(&#34;hl7.client.stdin&#34;) self.mock_stdin = self.stdin_patch.start()  self.stderr_patch = patch(&#34;hl7.client.stderr&#34;) self.mock_stderr = self.stderr_patch.start()  self.exit_patch = patch(&#34;hl7.client.sys.exit&#34;) self.mock_exit = self.exit_patch.start()  # we need a temporary directory self.dir = mkdtemp() self.write(SB + b&#34;foobar&#34; + EB + CR)  self.option_values = Values( { &#34;port&#34;: 6661, &#34;filename&#34;: os.path.join(self.dir, &#34;test.hl7&#34;), &#34;verbose&#34;: True, &#34;loose&#34;: False, &#34;version&#34;: False, } )  self.options_patch = patch(&#34;hl7.client.OptionParser&#34;) option_parser = self.options_patch.start() self.mock_options = Mock() option_parser.return_value = self.mock_options self.mock_options.parse_args.return_value = (self.option_values, [&#34;localhost&#34;])  def tearDown(self): # unpatch self.socket_patch.stop() self.options_patch.stop() self.stdout_patch.stop() self.stdin_patch.stop() self.stderr_patch.stop() self.exit_patch.stop()  # clean up the temp directory rmtree(self.dir)  def write(self, content, path=&#34;test.hl7&#34;): with open(os.path.join(self.dir, path), &#34;wb&#34;) as f: f.write(content)  def test_send(self): mllp_send()  self.mock_socket().connect.assert_called_once_with((&#34;localhost&#34;, 6661)) self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR) self.mock_stdout.assert_called_once_with(&#34;thanks&#34;) self.assertFalse(self.mock_exit.called)  def test_send_multiple(self): self.mock_socket().recv.return_value = &#34;thanks&#34; self.write(SB + b&#34;foobar&#34; + EB + CR + SB + b&#34;hello&#34; + EB + CR)  mllp_send()  self.assertEqual( self.mock_socket().send.call_args_list[0][0][0], SB + b&#34;foobar&#34; + EB + CR ) self.assertEqual( self.mock_socket().send.call_args_list[1][0][0], SB + b&#34;hello&#34; + EB + CR )  def test_leftover_buffer(self): self.write(SB + b&#34;foobar&#34; + EB + CR + SB + b&#34;stuff&#34;)  self.assertRaises(MLLPException, mllp_send)  self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR)  def test_quiet(self): self.option_values.verbose = False  mllp_send()  self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR) self.assertFalse(self.mock_stdout.called)  def test_port(self): self.option_values.port = 7890  mllp_send()  self.mock_socket().connect.assert_called_once_with((&#34;localhost&#34;, 7890))  def test_stdin(self): self.option_values.filename = None self.mock_stdin.return_value = FakeStream()  mllp_send()  self.mock_socket().send.assert_called_once_with(SB + b&#34;hello&#34; + EB + CR)  def test_loose_no_stdin(self): self.option_values.loose = True self.option_values.filename = None self.mock_stdin.return_value = FakeStream()  mllp_send()  self.assertFalse(self.mock_socket().send.called) self.mock_stderr().write.assert_called_with(&#34;--loose requires --file\\n&#34;) self.mock_exit.assert_called_with(1)  def test_loose_windows_newline(self): self.option_values.loose = True self.write(SB + b&#34;MSH|^~\\\\&#38;|foo\\r\\nbar\\r\\n&#34; + EB + CR)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )  def test_loose_unix_newline(self): self.option_values.loose = True self.write(SB + b&#34;MSH|^~\\\\&#38;|foo\\nbar\\n&#34; + EB + CR)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )  def test_loose_no_mllp_characters(self): self.option_values.loose = True self.write(b&#34;MSH|^~\\\\&#38;|foo\\r\\nbar\\r\\n&#34;)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )  def test_loose_send_mutliple(self): self.option_values.loose = True self.mock_socket().recv.return_value = &#34;thanks&#34; self.write(b&#34;MSH|^~\\\\&#38;|1\\r\\nOBX|1\\r\\nMSH|^~\\\\&#38;|2\\r\\nOBX|2\\r\\n&#34;)  mllp_send()  self.assertEqual( self.mock_socket().send.call_args_list[0][0][0], SB + b&#34;MSH|^~\\\\&#38;|1\\rOBX|1&#34; + EB + CR, ) self.assertEqual( self.mock_socket().send.call_args_list[1][0][0], SB + b&#34;MSH|^~\\\\&#38;|2\\rOBX|2&#34; + EB + CR, )  def test_version(self): self.option_values.version = True  mllp_send()  self.assertFalse(self.mock_socket().connect.called) self.mock_stdout.assert_called_once_with(str(hl7_version))"
                }
            },
            {
                "id": 317,
                "attributes": {
                    "id": 317.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.setUp",
                    "type": "function",
                    "code": "def setUp(self): # patch to avoid touching sys and socket self.socket_patch = patch(&#34;hl7.client.socket.socket&#34;) self.mock_socket = self.socket_patch.start() self.mock_socket().recv.return_value = &#34;thanks&#34;  self.stdout_patch = patch(&#34;hl7.client.stdout&#34;) self.mock_stdout = self.stdout_patch.start()  self.stdin_patch = patch(&#34;hl7.client.stdin&#34;) self.mock_stdin = self.stdin_patch.start()  self.stderr_patch = patch(&#34;hl7.client.stderr&#34;) self.mock_stderr = self.stderr_patch.start()  self.exit_patch = patch(&#34;hl7.client.sys.exit&#34;) self.mock_exit = self.exit_patch.start()  # we need a temporary directory self.dir = mkdtemp() self.write(SB + b&#34;foobar&#34; + EB + CR)  self.option_values = Values( { &#34;port&#34;: 6661, &#34;filename&#34;: os.path.join(self.dir, &#34;test.hl7&#34;), &#34;verbose&#34;: True, &#34;loose&#34;: False, &#34;version&#34;: False, } )  self.options_patch = patch(&#34;hl7.client.OptionParser&#34;) option_parser = self.options_patch.start() self.mock_options = Mock() option_parser.return_value = self.mock_options self.mock_options.parse_args.return_value = (self.option_values, [&#34;localhost&#34;])",
                    "signature": "def setUp(self): # patch to avoid touching sys and socket self.socket_patch = patch(&#34;hl7.client.socket.socket&#34;) self.mock_socket = self.socket_patch.start() self.mock_socket().recv.return_value = &#34;thanks&#34;  self.stdout_patch = patch(&#34;hl7.client.stdout&#34;) self.mock_stdout = self.stdout_patch.start()  self.stdin_patch = patch(&#34;hl7.client.stdin&#34;) self.mock_stdin = self.stdin_patch.start()  self.stderr_patch = patch(&#34;hl7.client.stderr&#34;) self.mock_stderr = self.stderr_patch.start()  self.exit_patch = patch(&#34;hl7.client.sys.exit&#34;) self.mock_exit = self.exit_patch.start()  # we need a temporary directory self.dir = mkdtemp() self.write(SB + b&#34;foobar&#34; + EB + CR)  self.option_values = Values( { &#34;port&#34;: 6661, &#34;filename&#34;: os.path.join(self.dir, &#34;test.hl7&#34;), &#34;verbose&#34;: True, &#34;loose&#34;: False, &#34;version&#34;: False, } )  self.options_patch = patch(&#34;hl7.client.OptionParser&#34;) option_parser = self.options_patch.start() self.mock_options = Mock() option_parser.return_value = self.mock_options self.mock_options.parse_args.return_value = (self.option_values, [&#34;localhost&#34;])"
                }
            },
            {
                "id": 318,
                "attributes": {
                    "id": 318.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.tearDown",
                    "type": "function",
                    "code": "def tearDown(self): # unpatch self.socket_patch.stop() self.options_patch.stop() self.stdout_patch.stop() self.stdin_patch.stop() self.stderr_patch.stop() self.exit_patch.stop()  # clean up the temp directory rmtree(self.dir)",
                    "signature": "def tearDown(self): # unpatch self.socket_patch.stop() self.options_patch.stop() self.stdout_patch.stop() self.stdin_patch.stop() self.stderr_patch.stop() self.exit_patch.stop()  # clean up the temp directory rmtree(self.dir)"
                }
            },
            {
                "id": 319,
                "attributes": {
                    "id": 319.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.write",
                    "type": "function",
                    "code": "def write(self, content, path=&#34;test.hl7&#34;): with open(os.path.join(self.dir, path), &#34;wb&#34;) as f: f.write(content)",
                    "signature": "def write(self, content, path=&#34;test.hl7&#34;): with open(os.path.join(self.dir, path), &#34;wb&#34;) as f: f.write(content)"
                }
            },
            {
                "id": 320,
                "attributes": {
                    "id": 320.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_send",
                    "type": "function",
                    "code": "def test_send(self): mllp_send()  self.mock_socket().connect.assert_called_once_with((&#34;localhost&#34;, 6661)) self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR) self.mock_stdout.assert_called_once_with(&#34;thanks&#34;) self.assertFalse(self.mock_exit.called)",
                    "signature": "def test_send(self): mllp_send()  self.mock_socket().connect.assert_called_once_with((&#34;localhost&#34;, 6661)) self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR) self.mock_stdout.assert_called_once_with(&#34;thanks&#34;) self.assertFalse(self.mock_exit.called)"
                }
            },
            {
                "id": 321,
                "attributes": {
                    "id": 321.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_send_multiple",
                    "type": "function",
                    "code": "def test_send_multiple(self): self.mock_socket().recv.return_value = &#34;thanks&#34; self.write(SB + b&#34;foobar&#34; + EB + CR + SB + b&#34;hello&#34; + EB + CR)  mllp_send()  self.assertEqual( self.mock_socket().send.call_args_list[0][0][0], SB + b&#34;foobar&#34; + EB + CR ) self.assertEqual( self.mock_socket().send.call_args_list[1][0][0], SB + b&#34;hello&#34; + EB + CR )",
                    "signature": "def test_send_multiple(self): self.mock_socket().recv.return_value = &#34;thanks&#34; self.write(SB + b&#34;foobar&#34; + EB + CR + SB + b&#34;hello&#34; + EB + CR)  mllp_send()  self.assertEqual( self.mock_socket().send.call_args_list[0][0][0], SB + b&#34;foobar&#34; + EB + CR ) self.assertEqual( self.mock_socket().send.call_args_list[1][0][0], SB + b&#34;hello&#34; + EB + CR )"
                }
            },
            {
                "id": 322,
                "attributes": {
                    "id": 322.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_leftover_buffer",
                    "type": "function",
                    "code": "def test_leftover_buffer(self): self.write(SB + b&#34;foobar&#34; + EB + CR + SB + b&#34;stuff&#34;)  self.assertRaises(MLLPException, mllp_send)  self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR)",
                    "signature": "def test_leftover_buffer(self): self.write(SB + b&#34;foobar&#34; + EB + CR + SB + b&#34;stuff&#34;)  self.assertRaises(MLLPException, mllp_send)  self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR)"
                }
            },
            {
                "id": 323,
                "attributes": {
                    "id": 323.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_quiet",
                    "type": "function",
                    "code": "def test_quiet(self): self.option_values.verbose = False  mllp_send()  self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR) self.assertFalse(self.mock_stdout.called)",
                    "signature": "def test_quiet(self): self.option_values.verbose = False  mllp_send()  self.mock_socket().send.assert_called_once_with(SB + b&#34;foobar&#34; + EB + CR) self.assertFalse(self.mock_stdout.called)"
                }
            },
            {
                "id": 324,
                "attributes": {
                    "id": 324.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_port",
                    "type": "function",
                    "code": "def test_port(self): self.option_values.port = 7890  mllp_send()  self.mock_socket().connect.assert_called_once_with((&#34;localhost&#34;, 7890))",
                    "signature": "def test_port(self): self.option_values.port = 7890  mllp_send()  self.mock_socket().connect.assert_called_once_with((&#34;localhost&#34;, 7890))"
                }
            },
            {
                "id": 325,
                "attributes": {
                    "id": 325.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_stdin",
                    "type": "function",
                    "code": "def test_stdin(self): self.option_values.filename = None self.mock_stdin.return_value = FakeStream()  mllp_send()  self.mock_socket().send.assert_called_once_with(SB + b&#34;hello&#34; + EB + CR)",
                    "signature": "def test_stdin(self): self.option_values.filename = None self.mock_stdin.return_value = FakeStream()  mllp_send()  self.mock_socket().send.assert_called_once_with(SB + b&#34;hello&#34; + EB + CR)"
                }
            },
            {
                "id": 326,
                "attributes": {
                    "id": 326.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_loose_no_stdin",
                    "type": "function",
                    "code": "def test_loose_no_stdin(self): self.option_values.loose = True self.option_values.filename = None self.mock_stdin.return_value = FakeStream()  mllp_send()  self.assertFalse(self.mock_socket().send.called) self.mock_stderr().write.assert_called_with(&#34;--loose requires --file\\n&#34;) self.mock_exit.assert_called_with(1)",
                    "signature": "def test_loose_no_stdin(self): self.option_values.loose = True self.option_values.filename = None self.mock_stdin.return_value = FakeStream()  mllp_send()  self.assertFalse(self.mock_socket().send.called) self.mock_stderr().write.assert_called_with(&#34;--loose requires --file\\n&#34;) self.mock_exit.assert_called_with(1)"
                }
            },
            {
                "id": 327,
                "attributes": {
                    "id": 327.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_loose_windows_newline",
                    "type": "function",
                    "code": "def test_loose_windows_newline(self): self.option_values.loose = True self.write(SB + b&#34;MSH|^~\\\\&#38;|foo\\r\\nbar\\r\\n&#34; + EB + CR)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )",
                    "signature": "def test_loose_windows_newline(self): self.option_values.loose = True self.write(SB + b&#34;MSH|^~\\\\&#38;|foo\\r\\nbar\\r\\n&#34; + EB + CR)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )"
                }
            },
            {
                "id": 328,
                "attributes": {
                    "id": 328.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_loose_unix_newline",
                    "type": "function",
                    "code": "def test_loose_unix_newline(self): self.option_values.loose = True self.write(SB + b&#34;MSH|^~\\\\&#38;|foo\\nbar\\n&#34; + EB + CR)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )",
                    "signature": "def test_loose_unix_newline(self): self.option_values.loose = True self.write(SB + b&#34;MSH|^~\\\\&#38;|foo\\nbar\\n&#34; + EB + CR)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )"
                }
            },
            {
                "id": 329,
                "attributes": {
                    "id": 329.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_loose_no_mllp_characters",
                    "type": "function",
                    "code": "def test_loose_no_mllp_characters(self): self.option_values.loose = True self.write(b&#34;MSH|^~\\\\&#38;|foo\\r\\nbar\\r\\n&#34;)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )",
                    "signature": "def test_loose_no_mllp_characters(self): self.option_values.loose = True self.write(b&#34;MSH|^~\\\\&#38;|foo\\r\\nbar\\r\\n&#34;)  mllp_send()  self.mock_socket().send.assert_called_once_with( SB + b&#34;MSH|^~\\\\&#38;|foo\\rbar&#34; + EB + CR )"
                }
            },
            {
                "id": 330,
                "attributes": {
                    "id": 330.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_loose_send_mutliple",
                    "type": "function",
                    "code": "def test_loose_send_mutliple(self): self.option_values.loose = True self.mock_socket().recv.return_value = &#34;thanks&#34; self.write(b&#34;MSH|^~\\\\&#38;|1\\r\\nOBX|1\\r\\nMSH|^~\\\\&#38;|2\\r\\nOBX|2\\r\\n&#34;)  mllp_send()  self.assertEqual( self.mock_socket().send.call_args_list[0][0][0], SB + b&#34;MSH|^~\\\\&#38;|1\\rOBX|1&#34; + EB + CR, ) self.assertEqual( self.mock_socket().send.call_args_list[1][0][0], SB + b&#34;MSH|^~\\\\&#38;|2\\rOBX|2&#34; + EB + CR, )",
                    "signature": "def test_loose_send_mutliple(self): self.option_values.loose = True self.mock_socket().recv.return_value = &#34;thanks&#34; self.write(b&#34;MSH|^~\\\\&#38;|1\\r\\nOBX|1\\r\\nMSH|^~\\\\&#38;|2\\r\\nOBX|2\\r\\n&#34;)  mllp_send()  self.assertEqual( self.mock_socket().send.call_args_list[0][0][0], SB + b&#34;MSH|^~\\\\&#38;|1\\rOBX|1&#34; + EB + CR, ) self.assertEqual( self.mock_socket().send.call_args_list[1][0][0], SB + b&#34;MSH|^~\\\\&#38;|2\\rOBX|2&#34; + EB + CR, )"
                }
            },
            {
                "id": 331,
                "attributes": {
                    "id": 331.0,
                    "label": "hl7.tests.test_client.MLLPSendTest.test_version",
                    "type": "function",
                    "code": "def test_version(self): self.option_values.version = True  mllp_send()  self.assertFalse(self.mock_socket().connect.called) self.mock_stdout.assert_called_once_with(str(hl7_version))",
                    "signature": "def test_version(self): self.option_values.version = True  mllp_send()  self.assertFalse(self.mock_socket().connect.called) self.mock_stdout.assert_called_once_with(str(hl7_version))"
                }
            },
            {
                "id": 332,
                "attributes": {
                    "id": 332.0,
                    "label": "hl7.tests.test_client.FakeStream",
                    "type": "class",
                    "code": "class FakeStream(object): count = 0  def read(self, buf): self.count += 1 if self.count == 1: return SB + b&#34;hello&#34; + EB + CR else: return b&#34;&#34;",
                    "signature": "class FakeStream(object): count = 0  def read(self, buf): self.count += 1 if self.count == 1: return SB + b&#34;hello&#34; + EB + CR else: return b&#34;&#34;"
                }
            },
            {
                "id": 333,
                "attributes": {
                    "id": 333.0,
                    "label": "hl7.tests.test_client.FakeStream.read",
                    "type": "function",
                    "code": "def read(self, buf): self.count += 1 if self.count == 1: return SB + b&#34;hello&#34; + EB + CR else: return b&#34;&#34;",
                    "signature": "def read(self, buf): self.count += 1 if self.count == 1: return SB + b&#34;hello&#34; + EB + CR else: return b&#34;&#34;"
                }
            },
            {
                "id": 461,
                "attributes": {
                    "id": 461.0,
                    "label": "io",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 462,
                "attributes": {
                    "id": 462.0,
                    "label": "os.path",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 463,
                "attributes": {
                    "id": 463.0,
                    "label": "socket",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            }
        ]
    },
    "7": {
        "nodes": [
            {
                "id": 42,
                "attributes": {
                    "id": 42.0,
                    "label": "hl7.hl7.exceptions.MalformedSegmentException",
                    "type": "class",
                    "code": "class MalformedSegmentException(HL7Exception): pass",
                    "signature": "class MalformedSegmentException(HL7Exception): pass"
                }
            },
            {
                "id": 49,
                "attributes": {
                    "id": 49.0,
                    "label": "hl7.hl7.parser._create_batch",
                    "type": "function",
                    "code": "def _create_batch(batch, messages, encoding, factory): &#34;&#34;&#34;Creates a :py:class:`hl7.Batch`&#34;&#34;&#34; kwargs = { &#34;sequence&#34;: [ parse(message, encoding=encoding, factory=factory) for message in messages ], } # If the BHS/BTS were present, use those to set up the batch # otherwise default if batch: batch = parse(batch, encoding=encoding, factory=factory) kwargs[&#34;esc&#34;] = batch.esc kwargs[&#34;separators&#34;] = batch.separators kwargs[&#34;factory&#34;] = batch.factory parsed = factory.create_batch(**kwargs) # If the BHS/BTS were present then set them if batch: parsed.header = batch.segment(&#34;BHS&#34;) try: parsed.trailer = batch.segment(&#34;BTS&#34;) except KeyError: parsed.trailer = parsed.create_segment([parsed.create_field([&#34;BTS&#34;])]) return parsed",
                    "signature": "def _create_batch(batch, messages, encoding, factory): &#34;&#34;&#34;Creates a :py:class:`hl7.Batch`&#34;&#34;&#34; kwargs = { &#34;sequence&#34;: [ parse(message, encoding=encoding, factory=factory) for message in messages ], } # If the BHS/BTS were present, use those to set up the batch # otherwise default if batch: batch = parse(batch, encoding=encoding, factory=factory) kwargs[&#34;esc&#34;] = batch.esc kwargs[&#34;separators&#34;] = batch.separators kwargs[&#34;factory&#34;] = batch.factory parsed = factory.create_batch(**kwargs) # If the BHS/BTS were present then set them if batch: parsed.header = batch.segment(&#34;BHS&#34;) try: parsed.trailer = batch.segment(&#34;BTS&#34;) except KeyError: parsed.trailer = parsed.create_segment([parsed.create_field([&#34;BTS&#34;])]) return parsed"
                }
            },
            {
                "id": 51,
                "attributes": {
                    "id": 51.0,
                    "label": "hl7.hl7.parser._create_file",
                    "type": "function",
                    "code": "def _create_file(file, batches, encoding, factory): kwargs = { &#34;sequence&#34;: [ _create_batch(batch[0], batch[1], encoding, factory) for batch in batches ], } # If the FHS/FTS are present, use them to set up the file if file: file = parse(file, encoding=encoding, factory=factory) kwargs[&#34;esc&#34;] = file.esc kwargs[&#34;separators&#34;] = file.separators kwargs[&#34;factory&#34;] = file.factory parsed = factory.create_file(**kwargs) # If the FHS/FTS are present, add them if file: parsed.header = file.segment(&#34;FHS&#34;) try: parsed.trailer = file.segment(&#34;FTS&#34;) except KeyError: parsed.trailer = parsed.create_segment([parsed.create_field([&#34;FTS&#34;])]) return parsed",
                    "signature": "def _create_file(file, batches, encoding, factory): kwargs = { &#34;sequence&#34;: [ _create_batch(batch[0], batch[1], encoding, factory) for batch in batches ], } # If the FHS/FTS are present, use them to set up the file if file: file = parse(file, encoding=encoding, factory=factory) kwargs[&#34;esc&#34;] = file.esc kwargs[&#34;separators&#34;] = file.separators kwargs[&#34;factory&#34;] = file.factory parsed = factory.create_file(**kwargs) # If the FHS/FTS are present, add them if file: parsed.header = file.segment(&#34;FHS&#34;) try: parsed.trailer = file.segment(&#34;FTS&#34;) except KeyError: parsed.trailer = parsed.create_segment([parsed.create_field([&#34;FTS&#34;])]) return parsed"
                }
            },
            {
                "id": 89,
                "attributes": {
                    "id": 89.0,
                    "label": "hl7.hl7.containers.Container",
                    "type": "class",
                    "code": "class Container(Sequence): &#34;&#34;&#34;Abstract root class for the parts of the HL7 message.&#34;&#34;&#34;  def __init__( self, separator, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert separator in separators # Initialize the list object, optionally passing in the # sequence.  Since list([]) == [], using the default # parameter will not cause any issues. super(Container, self).__init__(sequence) self.separator = separator self.esc = esc self.separators = separators self.factory = factory if factory is not None else Factory  def create_file(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.File` compatible with this container&#34;&#34;&#34; return self.factory.create_file( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_batch(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Batch` compatible with this container&#34;&#34;&#34; return self.factory.create_batch( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_message(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Message` compatible with this container&#34;&#34;&#34; return self.factory.create_message( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_segment(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` compatible with this container&#34;&#34;&#34; return self.factory.create_segment( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_field(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Field` compatible with this container&#34;&#34;&#34; return self.factory.create_field( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_repetition(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Repetition` compatible with this container&#34;&#34;&#34; return self.factory.create_repetition( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_component(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Component` compatible with this container&#34;&#34;&#34; return self.factory.create_component( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def __getitem__(self, item): # Python slice operator was returning a regular list, not a # Container subclass sequence = super(Container, self).__getitem__(item) if isinstance(item, slice): return self.__class__( self.separator, sequence, self.esc, self.separators, factory=self.factory, ) return sequence  def __getslice__(self, i, j): # Python 2.x compatibility.  __getslice__ is deprecated, and # we want to wrap the logic from __getitem__ when handling slices return self.__getitem__(slice(i, j))  def __str__(self): return self.separator.join((str(x) for x in self))",
                    "signature": "class Container(Sequence): &#34;&#34;&#34;Abstract root class for the parts of the HL7 message.&#34;&#34;&#34;  def __init__( self, separator, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert separator in separators # Initialize the list object, optionally passing in the # sequence.  Since list([]) == [], using the default # parameter will not cause any issues. super(Container, self).__init__(sequence) self.separator = separator self.esc = esc self.separators = separators self.factory = factory if factory is not None else Factory  def create_file(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.File` compatible with this container&#34;&#34;&#34; return self.factory.create_file( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_batch(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Batch` compatible with this container&#34;&#34;&#34; return self.factory.create_batch( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_message(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Message` compatible with this container&#34;&#34;&#34; return self.factory.create_message( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_segment(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` compatible with this container&#34;&#34;&#34; return self.factory.create_segment( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_field(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Field` compatible with this container&#34;&#34;&#34; return self.factory.create_field( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_repetition(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Repetition` compatible with this container&#34;&#34;&#34; return self.factory.create_repetition( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def create_component(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Component` compatible with this container&#34;&#34;&#34; return self.factory.create_component( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )  def __getitem__(self, item): # Python slice operator was returning a regular list, not a # Container subclass sequence = super(Container, self).__getitem__(item) if isinstance(item, slice): return self.__class__( self.separator, sequence, self.esc, self.separators, factory=self.factory, ) return sequence  def __getslice__(self, i, j): # Python 2.x compatibility.  __getslice__ is deprecated, and # we want to wrap the logic from __getitem__ when handling slices return self.__getitem__(slice(i, j))  def __str__(self): return self.separator.join((str(x) for x in self))"
                }
            },
            {
                "id": 91,
                "attributes": {
                    "id": 91.0,
                    "label": "hl7.hl7.containers.Container.create_file",
                    "type": "function",
                    "code": "def create_file(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.File` compatible with this container&#34;&#34;&#34; return self.factory.create_file( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )",
                    "signature": "def create_file(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.File` compatible with this container&#34;&#34;&#34; return self.factory.create_file( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )"
                }
            },
            {
                "id": 92,
                "attributes": {
                    "id": 92.0,
                    "label": "hl7.hl7.containers.Container.create_batch",
                    "type": "function",
                    "code": "def create_batch(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Batch` compatible with this container&#34;&#34;&#34; return self.factory.create_batch( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )",
                    "signature": "def create_batch(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Batch` compatible with this container&#34;&#34;&#34; return self.factory.create_batch( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )"
                }
            },
            {
                "id": 93,
                "attributes": {
                    "id": 93.0,
                    "label": "hl7.hl7.containers.Container.create_message",
                    "type": "function",
                    "code": "def create_message(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Message` compatible with this container&#34;&#34;&#34; return self.factory.create_message( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )",
                    "signature": "def create_message(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Message` compatible with this container&#34;&#34;&#34; return self.factory.create_message( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )"
                }
            },
            {
                "id": 94,
                "attributes": {
                    "id": 94.0,
                    "label": "hl7.hl7.containers.Container.create_segment",
                    "type": "function",
                    "code": "def create_segment(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` compatible with this container&#34;&#34;&#34; return self.factory.create_segment( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )",
                    "signature": "def create_segment(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` compatible with this container&#34;&#34;&#34; return self.factory.create_segment( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )"
                }
            },
            {
                "id": 95,
                "attributes": {
                    "id": 95.0,
                    "label": "hl7.hl7.containers.Container.create_field",
                    "type": "function",
                    "code": "def create_field(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Field` compatible with this container&#34;&#34;&#34; return self.factory.create_field( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )",
                    "signature": "def create_field(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Field` compatible with this container&#34;&#34;&#34; return self.factory.create_field( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )"
                }
            },
            {
                "id": 96,
                "attributes": {
                    "id": 96.0,
                    "label": "hl7.hl7.containers.Container.create_repetition",
                    "type": "function",
                    "code": "def create_repetition(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Repetition` compatible with this container&#34;&#34;&#34; return self.factory.create_repetition( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )",
                    "signature": "def create_repetition(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Repetition` compatible with this container&#34;&#34;&#34; return self.factory.create_repetition( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )"
                }
            },
            {
                "id": 97,
                "attributes": {
                    "id": 97.0,
                    "label": "hl7.hl7.containers.Container.create_component",
                    "type": "function",
                    "code": "def create_component(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Component` compatible with this container&#34;&#34;&#34; return self.factory.create_component( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )",
                    "signature": "def create_component(self, seq): &#34;&#34;&#34;Create a new :py:class:`hl7.Component` compatible with this container&#34;&#34;&#34; return self.factory.create_component( sequence=seq, esc=self.esc, separators=self.separators, factory=self.factory, )"
                }
            },
            {
                "id": 98,
                "attributes": {
                    "id": 98.0,
                    "label": "hl7.hl7.containers.Container.__getitem__",
                    "type": "function",
                    "code": "def __getitem__(self, item): # Python slice operator was returning a regular list, not a # Container subclass sequence = super(Container, self).__getitem__(item) if isinstance(item, slice): return self.__class__( self.separator, sequence, self.esc, self.separators, factory=self.factory, ) return sequence",
                    "signature": "def __getitem__(self, item): # Python slice operator was returning a regular list, not a # Container subclass sequence = super(Container, self).__getitem__(item) if isinstance(item, slice): return self.__class__( self.separator, sequence, self.esc, self.separators, factory=self.factory, ) return sequence"
                }
            },
            {
                "id": 99,
                "attributes": {
                    "id": 99.0,
                    "label": "hl7.hl7.containers.Container.__getslice__",
                    "type": "function",
                    "code": "def __getslice__(self, i, j): # Python 2.x compatibility.  __getslice__ is deprecated, and # we want to wrap the logic from __getitem__ when handling slices return self.__getitem__(slice(i, j))",
                    "signature": "def __getslice__(self, i, j): # Python 2.x compatibility.  __getslice__ is deprecated, and # we want to wrap the logic from __getitem__ when handling slices return self.__getitem__(slice(i, j))"
                }
            },
            {
                "id": 101,
                "attributes": {
                    "id": 101.0,
                    "label": "hl7.hl7.containers.File",
                    "type": "class",
                    "code": "class File(Container): &#34;&#34;&#34;Representation of an HL7 file from the batch protocol. It contains a list of :py:class:`hl7.Batch` instances. It may contain FHS/FTS :py:class:`hl7.Segment` instances.  Files may or may not be wrapped in FHS/FTS segements deliniating the start/end of the batch. These are optional. &#34;&#34;&#34;  def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(File, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, ) self.header = None self.trailer = None  @property def header(self): &#34;&#34;&#34;FHS :py:class:`hl7.Segment`&#34;&#34;&#34; return self._batch_header_segment  @header.setter def header(self, segment): if segment and segment[0][0] != &#34;FHS&#34;: raise MalformedSegmentException('header must begin with &#34;FHS&#34;') self._batch_header_segment = segment  @property def trailer(self): &#34;&#34;&#34;FTS :py:class:`hl7.Segment`&#34;&#34;&#34; return self._batch_trailer_segment  @trailer.setter def trailer(self, segment): if segment and segment[0][0] != &#34;FTS&#34;: raise MalformedSegmentException('trailer must begin with &#34;FTS&#34;') self._batch_trailer_segment = segment  def create_header(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` FHS compatible with this file&#34;&#34;&#34; return self.create_segment( [ self.create_field([&#34;FHS&#34;]), self.create_field([self.separators[1]]), self.create_field( [ self.separators[3] + self.separators[2] + self.esc + self.separators[4] ] ), ] )  def create_trailer(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` FTS compatible with this file&#34;&#34;&#34; return self.create_segment([self.create_field([&#34;FTS&#34;])])  def __str__(self): &#34;&#34;&#34;Join a the child batches into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  If this batch has FHS/FTS segments, they will be added to the beginning/end of the returned string. &#34;&#34;&#34; if (self.header and not self.trailer) or (not self.header and self.trailer): raise MalformedFileException( &#34;Either both header and trailer must be present or neither&#34; ) return ( super(File, self).__str__() if not self.header else str(self.header) + self.separator + super(File, self).__str__() + str(self.trailer) + self.separator )",
                    "signature": "class File(Container): &#34;&#34;&#34;Representation of an HL7 file from the batch protocol. It contains a list of :py:class:`hl7.Batch` instances. It may contain FHS/FTS :py:class:`hl7.Segment` instances.  Files may or may not be wrapped in FHS/FTS segements deliniating the start/end of the batch. These are optional. &#34;&#34;&#34;  def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(File, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, ) self.header = None self.trailer = None  @property def header(self): &#34;&#34;&#34;FHS :py:class:`hl7.Segment`&#34;&#34;&#34; return self._batch_header_segment  @header.setter def header(self, segment): if segment and segment[0][0] != &#34;FHS&#34;: raise MalformedSegmentException('header must begin with &#34;FHS&#34;') self._batch_header_segment = segment  @property def trailer(self): &#34;&#34;&#34;FTS :py:class:`hl7.Segment`&#34;&#34;&#34; return self._batch_trailer_segment  @trailer.setter def trailer(self, segment): if segment and segment[0][0] != &#34;FTS&#34;: raise MalformedSegmentException('trailer must begin with &#34;FTS&#34;') self._batch_trailer_segment = segment  def create_header(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` FHS compatible with this file&#34;&#34;&#34; return self.create_segment( [ self.create_field([&#34;FHS&#34;]), self.create_field([self.separators[1]]), self.create_field( [ self.separators[3] + self.separators[2] + self.esc + self.separators[4] ] ), ] )  def create_trailer(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` FTS compatible with this file&#34;&#34;&#34; return self.create_segment([self.create_field([&#34;FTS&#34;])])  def __str__(self): &#34;&#34;&#34;Join a the child batches into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  If this batch has FHS/FTS segments, they will be added to the beginning/end of the returned string. &#34;&#34;&#34; if (self.header and not self.trailer) or (not self.header and self.trailer): raise MalformedFileException( &#34;Either both header and trailer must be present or neither&#34; ) return ( super(File, self).__str__() if not self.header else str(self.header) + self.separator + super(File, self).__str__() + str(self.trailer) + self.separator )"
                }
            },
            {
                "id": 102,
                "attributes": {
                    "id": 102.0,
                    "label": "hl7.hl7.containers.File.__init__",
                    "type": "function",
                    "code": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(File, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, ) self.header = None self.trailer = None",
                    "signature": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(File, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, ) self.header = None self.trailer = None"
                }
            },
            {
                "id": 103,
                "attributes": {
                    "id": 103.0,
                    "label": "hl7.hl7.containers.File.header",
                    "type": "function",
                    "code": "def header(self, segment): if segment and segment[0][0] != &#34;FHS&#34;: raise MalformedSegmentException('header must begin with &#34;FHS&#34;') self._batch_header_segment = segment",
                    "signature": "def header(self, segment): if segment and segment[0][0] != &#34;FHS&#34;: raise MalformedSegmentException('header must begin with &#34;FHS&#34;') self._batch_header_segment = segment"
                }
            },
            {
                "id": 104,
                "attributes": {
                    "id": 104.0,
                    "label": "hl7.hl7.containers.File.trailer",
                    "type": "function",
                    "code": "def trailer(self, segment): if segment and segment[0][0] != &#34;FTS&#34;: raise MalformedSegmentException('trailer must begin with &#34;FTS&#34;') self._batch_trailer_segment = segment",
                    "signature": "def trailer(self, segment): if segment and segment[0][0] != &#34;FTS&#34;: raise MalformedSegmentException('trailer must begin with &#34;FTS&#34;') self._batch_trailer_segment = segment"
                }
            },
            {
                "id": 105,
                "attributes": {
                    "id": 105.0,
                    "label": "hl7.hl7.containers.File.create_header",
                    "type": "function",
                    "code": "def create_header(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` FHS compatible with this file&#34;&#34;&#34; return self.create_segment( [ self.create_field([&#34;FHS&#34;]), self.create_field([self.separators[1]]), self.create_field( [ self.separators[3] + self.separators[2] + self.esc + self.separators[4] ] ), ] )",
                    "signature": "def create_header(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` FHS compatible with this file&#34;&#34;&#34; return self.create_segment( [ self.create_field([&#34;FHS&#34;]), self.create_field([self.separators[1]]), self.create_field( [ self.separators[3] + self.separators[2] + self.esc + self.separators[4] ] ), ] )"
                }
            },
            {
                "id": 106,
                "attributes": {
                    "id": 106.0,
                    "label": "hl7.hl7.containers.File.create_trailer",
                    "type": "function",
                    "code": "def create_trailer(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` FTS compatible with this file&#34;&#34;&#34; return self.create_segment([self.create_field([&#34;FTS&#34;])])",
                    "signature": "def create_trailer(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` FTS compatible with this file&#34;&#34;&#34; return self.create_segment([self.create_field([&#34;FTS&#34;])])"
                }
            },
            {
                "id": 108,
                "attributes": {
                    "id": 108.0,
                    "label": "hl7.hl7.containers.Batch",
                    "type": "class",
                    "code": "class Batch(Container): &#34;&#34;&#34;Representation of an HL7 batch from the batch protocol. It contains a list of :py:class:`hl7.Message` instances. It may contain BHS/BTS :py:class:`hl7.Segment` instances.  Batches may or may not be wrapped in BHS/BTS segements deliniating the start/end of the batch. These are optional. &#34;&#34;&#34;  def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(Batch, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, ) self.header = None self.trailer = None  @property def header(self): &#34;&#34;&#34;BHS :py:class:`hl7.Segment`&#34;&#34;&#34; return self._batch_header_segment  @header.setter def header(self, segment): if segment and segment[0][0] != &#34;BHS&#34;: raise MalformedSegmentException('header must begin with &#34;BHS&#34;') self._batch_header_segment = segment  @property def trailer(self): &#34;&#34;&#34;BTS :py:class:`hl7.Segment`&#34;&#34;&#34; return self._batch_trailer_segment  @trailer.setter def trailer(self, segment): if segment and segment[0][0] != &#34;BTS&#34;: raise MalformedSegmentException('trailer must begin with &#34;BTS&#34;') self._batch_trailer_segment = segment  def create_header(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` BHS compatible with this batch&#34;&#34;&#34; return self.create_segment( [ self.create_field([&#34;BHS&#34;]), self.create_field([self.separators[1]]), self.create_field( [ self.separators[3] + self.separators[2] + self.esc + self.separators[4] ] ), ] )  def create_trailer(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` BHS compatible with this batch&#34;&#34;&#34; return self.create_segment([self.create_field([&#34;BTS&#34;])])  def __str__(self): &#34;&#34;&#34;Join a the child messages into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  If this batch has BHS/BTS segments, they will be added to the beginning/end of the returned string. &#34;&#34;&#34; if (self.header and not self.trailer) or (not self.header and self.trailer): raise MalformedBatchException( &#34;Either both header and trailer must be present or neither&#34; ) return ( super(Batch, self).__str__() if not self.header else str(self.header) + self.separator + super(Batch, self).__str__() + str(self.trailer) + self.separator )",
                    "signature": "class Batch(Container): &#34;&#34;&#34;Representation of an HL7 batch from the batch protocol. It contains a list of :py:class:`hl7.Message` instances. It may contain BHS/BTS :py:class:`hl7.Segment` instances.  Batches may or may not be wrapped in BHS/BTS segements deliniating the start/end of the batch. These are optional. &#34;&#34;&#34;  def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(Batch, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, ) self.header = None self.trailer = None  @property def header(self): &#34;&#34;&#34;BHS :py:class:`hl7.Segment`&#34;&#34;&#34; return self._batch_header_segment  @header.setter def header(self, segment): if segment and segment[0][0] != &#34;BHS&#34;: raise MalformedSegmentException('header must begin with &#34;BHS&#34;') self._batch_header_segment = segment  @property def trailer(self): &#34;&#34;&#34;BTS :py:class:`hl7.Segment`&#34;&#34;&#34; return self._batch_trailer_segment  @trailer.setter def trailer(self, segment): if segment and segment[0][0] != &#34;BTS&#34;: raise MalformedSegmentException('trailer must begin with &#34;BTS&#34;') self._batch_trailer_segment = segment  def create_header(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` BHS compatible with this batch&#34;&#34;&#34; return self.create_segment( [ self.create_field([&#34;BHS&#34;]), self.create_field([self.separators[1]]), self.create_field( [ self.separators[3] + self.separators[2] + self.esc + self.separators[4] ] ), ] )  def create_trailer(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` BHS compatible with this batch&#34;&#34;&#34; return self.create_segment([self.create_field([&#34;BTS&#34;])])  def __str__(self): &#34;&#34;&#34;Join a the child messages into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  If this batch has BHS/BTS segments, they will be added to the beginning/end of the returned string. &#34;&#34;&#34; if (self.header and not self.trailer) or (not self.header and self.trailer): raise MalformedBatchException( &#34;Either both header and trailer must be present or neither&#34; ) return ( super(Batch, self).__str__() if not self.header else str(self.header) + self.separator + super(Batch, self).__str__() + str(self.trailer) + self.separator )"
                }
            },
            {
                "id": 109,
                "attributes": {
                    "id": 109.0,
                    "label": "hl7.hl7.containers.Batch.__init__",
                    "type": "function",
                    "code": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(Batch, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, ) self.header = None self.trailer = None",
                    "signature": "def __init__( self, separator=None, sequence=[], esc=&#34;\\\\&#34;, separators=&#34;\\r|~^&#38;&#34;, factory=None ): assert not separator or separator == separators[0] super(Batch, self).__init__( separator=separators[0], sequence=sequence, esc=esc, separators=separators, factory=factory, ) self.header = None self.trailer = None"
                }
            },
            {
                "id": 110,
                "attributes": {
                    "id": 110.0,
                    "label": "hl7.hl7.containers.Batch.header",
                    "type": "function",
                    "code": "def header(self, segment): if segment and segment[0][0] != &#34;BHS&#34;: raise MalformedSegmentException('header must begin with &#34;BHS&#34;') self._batch_header_segment = segment",
                    "signature": "def header(self, segment): if segment and segment[0][0] != &#34;BHS&#34;: raise MalformedSegmentException('header must begin with &#34;BHS&#34;') self._batch_header_segment = segment"
                }
            },
            {
                "id": 111,
                "attributes": {
                    "id": 111.0,
                    "label": "hl7.hl7.containers.Batch.trailer",
                    "type": "function",
                    "code": "def trailer(self, segment): if segment and segment[0][0] != &#34;BTS&#34;: raise MalformedSegmentException('trailer must begin with &#34;BTS&#34;') self._batch_trailer_segment = segment",
                    "signature": "def trailer(self, segment): if segment and segment[0][0] != &#34;BTS&#34;: raise MalformedSegmentException('trailer must begin with &#34;BTS&#34;') self._batch_trailer_segment = segment"
                }
            },
            {
                "id": 112,
                "attributes": {
                    "id": 112.0,
                    "label": "hl7.hl7.containers.Batch.create_header",
                    "type": "function",
                    "code": "def create_header(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` BHS compatible with this batch&#34;&#34;&#34; return self.create_segment( [ self.create_field([&#34;BHS&#34;]), self.create_field([self.separators[1]]), self.create_field( [ self.separators[3] + self.separators[2] + self.esc + self.separators[4] ] ), ] )",
                    "signature": "def create_header(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` BHS compatible with this batch&#34;&#34;&#34; return self.create_segment( [ self.create_field([&#34;BHS&#34;]), self.create_field([self.separators[1]]), self.create_field( [ self.separators[3] + self.separators[2] + self.esc + self.separators[4] ] ), ] )"
                }
            },
            {
                "id": 113,
                "attributes": {
                    "id": 113.0,
                    "label": "hl7.hl7.containers.Batch.create_trailer",
                    "type": "function",
                    "code": "def create_trailer(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` BHS compatible with this batch&#34;&#34;&#34; return self.create_segment([self.create_field([&#34;BTS&#34;])])",
                    "signature": "def create_trailer(self): &#34;&#34;&#34;Create a new :py:class:`hl7.Segment` BHS compatible with this batch&#34;&#34;&#34; return self.create_segment([self.create_field([&#34;BTS&#34;])])"
                }
            },
            {
                "id": 119,
                "attributes": {
                    "id": 119.0,
                    "label": "hl7.hl7.containers.Message.segment",
                    "type": "function",
                    "code": "def segment(self, segment_id): &#34;&#34;&#34;Gets the first segment with the *segment_id* from the parsed *message*.  >>> h.segment('PID')  # doctest: +ELLIPSIS [['PID'], ...]  :rtype: :py:class:`hl7.Segment` &#34;&#34;&#34; # Get the list of all the segments and pull out the first one, # if possible match = self.segments(segment_id) # We should never get an IndexError, since segments will instead # throw an KeyError return match[0]",
                    "signature": "def segment(self, segment_id): &#34;&#34;&#34;Gets the first segment with the *segment_id* from the parsed *message*.  >>> h.segment('PID')  # doctest: +ELLIPSIS [['PID'], ...]  :rtype: :py:class:`hl7.Segment` &#34;&#34;&#34; # Get the list of all the segments and pull out the first one, # if possible match = self.segments(segment_id) # We should never get an IndexError, since segments will instead # throw an KeyError return match[0]"
                }
            },
            {
                "id": 125,
                "attributes": {
                    "id": 125.0,
                    "label": "hl7.hl7.containers.Message.create_ack",
                    "type": "function",
                    "code": "def create_ack( self, ack_code=&#34;AA&#34;, message_id=None, application=None, facility=None ): &#34;&#34;&#34; Create an hl7 ACK response :py:class:`hl7.Message`, per spec 2.9.2, for this message.  See http://www.hl7standards.com/blog/2007/02/01/ack-message-original-mode-acknowledgement/  ``ack_code`` options are one of `AA` (Application Accept), `AR` (Application Reject), `AE` (Application Error), `CA` (Commit Accept - Enhanced Mode), `CR` (Commit Reject - Enhanced Mode), or `CE` (Commit Error - Enhanced Mode) (see HL7 Table 0008 - Acknowledgment Code) ``message_id`` control message ID for ACK, defaults to unique generated ID ``application`` name of sending application, defaults to receiving application of message ``facility`` name of sending facility, defaults to receiving facility of message &#34;&#34;&#34; source_msh = self.segment(&#34;MSH&#34;) msh = self.create_segment([self.create_field([&#34;MSH&#34;])])  msh.assign_field(str(source_msh(1)), 1) msh.assign_field(str(source_msh(2)), 2) # Sending application is source receving application msh.assign_field( str(application) if application is not None else str(source_msh(5)), 3 ) # Sending facility is source receving facility msh.assign_field( str(facility) if facility is not None else str(source_msh(6)), 4 ) # Receiving application is source sending application msh.assign_field(str(source_msh(3)), 5) # Receiving facility is source sending facility msh.assign_field(str(source_msh(4)), 6) msh.assign_field(str(datetime.datetime.utcnow().strftime(&#34;%Y%m%d%H%M%S&#34;)), 7) # Message type code msh.assign_field(&#34;ACK&#34;, 9, 1, 1) # Copy trigger event from source msh.assign_field(str(source_msh(9)(1)(2)), 9, 1, 2) msh.assign_field(&#34;ACK&#34;, 9, 1, 3) msh.assign_field( message_id if message_id is not None else generate_message_control_id(), 10 ) msh.assign_field(str(source_msh(11)), 11) msh.assign_field(str(source_msh(12)), 12)  msa = self.create_segment([self.create_field([&#34;MSA&#34;])]) msa.assign_field(str(ack_code), 1) msa.assign_field(str(source_msh(10)), 2) ack = self.create_message([msh, msa])  return ack",
                    "signature": "def create_ack( self, ack_code=&#34;AA&#34;, message_id=None, application=None, facility=None ): &#34;&#34;&#34; Create an hl7 ACK response :py:class:`hl7.Message`, per spec 2.9.2, for this message.  See http://www.hl7standards.com/blog/2007/02/01/ack-message-original-mode-acknowledgement/  ``ack_code`` options are one of `AA` (Application Accept), `AR` (Application Reject), `AE` (Application Error), `CA` (Commit Accept - Enhanced Mode), `CR` (Commit Reject - Enhanced Mode), or `CE` (Commit Error - Enhanced Mode) (see HL7 Table 0008 - Acknowledgment Code) ``message_id`` control message ID for ACK, defaults to unique generated ID ``application`` name of sending application, defaults to receiving application of message ``facility`` name of sending facility, defaults to receiving facility of message &#34;&#34;&#34; source_msh = self.segment(&#34;MSH&#34;) msh = self.create_segment([self.create_field([&#34;MSH&#34;])])  msh.assign_field(str(source_msh(1)), 1) msh.assign_field(str(source_msh(2)), 2) # Sending application is source receving application msh.assign_field( str(application) if application is not None else str(source_msh(5)), 3 ) # Sending facility is source receving facility msh.assign_field( str(facility) if facility is not None else str(source_msh(6)), 4 ) # Receiving application is source sending application msh.assign_field(str(source_msh(3)), 5) # Receiving facility is source sending facility msh.assign_field(str(source_msh(4)), 6) msh.assign_field(str(datetime.datetime.utcnow().strftime(&#34;%Y%m%d%H%M%S&#34;)), 7) # Message type code msh.assign_field(&#34;ACK&#34;, 9, 1, 1) # Copy trigger event from source msh.assign_field(str(source_msh(9)(1)(2)), 9, 1, 2) msh.assign_field(&#34;ACK&#34;, 9, 1, 3) msh.assign_field( message_id if message_id is not None else generate_message_control_id(), 10 ) msh.assign_field(str(source_msh(11)), 11) msh.assign_field(str(source_msh(12)), 12)  msa = self.create_segment([self.create_field([&#34;MSA&#34;])]) msa.assign_field(str(ack_code), 1) msa.assign_field(str(source_msh(10)), 2) ack = self.create_message([msh, msa])  return ack"
                }
            },
            {
                "id": 130,
                "attributes": {
                    "id": 130.0,
                    "label": "hl7.hl7.containers.Segment.assign_field",
                    "type": "function",
                    "code": "def assign_field( self, value, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34; Assign a value into a message using the tree based assignment notation. The segment must exist.  Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing &#34;&#34;&#34;  while len(self) <= field_num: self.append(self.create_field([])) field = self(field_num) if repeat_num is None: field[:] = [value] return while len(field) < repeat_num: field.append(self.create_repetition([])) repetition = field(repeat_num) if component_num is None: repetition[:] = [value] return while len(repetition) < component_num: repetition.append(self.create_component([])) component = repetition(component_num) if subcomponent_num is None: component[:] = [value] return while len(component) < subcomponent_num: component.append(&#34;&#34;) component(subcomponent_num, value)",
                    "signature": "def assign_field( self, value, field_num=None, repeat_num=None, component_num=None, subcomponent_num=None, ): &#34;&#34;&#34; Assign a value into a message using the tree based assignment notation. The segment must exist.  Extract a field using a future proofed approach, based on rules in: http://wiki.medical-objects.com.au/index.php/Hl7v2_parsing &#34;&#34;&#34;  while len(self) <= field_num: self.append(self.create_field([])) field = self(field_num) if repeat_num is None: field[:] = [value] return while len(field) < repeat_num: field.append(self.create_repetition([])) repetition = field(repeat_num) if component_num is None: repetition[:] = [value] return while len(repetition) < component_num: repetition.append(self.create_component([])) component = repetition(component_num) if subcomponent_num is None: component[:] = [value] return while len(component) < subcomponent_num: component.append(&#34;&#34;) component(subcomponent_num, value)"
                }
            }
        ]
    },
    "8": {
        "nodes": [
            {
                "id": 4,
                "attributes": {
                    "id": 4.0,
                    "label": "hl7.hl7",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 40,
                "attributes": {
                    "id": 40.0,
                    "label": "hl7.hl7.exceptions",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 41,
                "attributes": {
                    "id": 41.0,
                    "label": "hl7.hl7.exceptions.HL7Exception",
                    "type": "class",
                    "code": "class HL7Exception(Exception): pass",
                    "signature": "class HL7Exception(Exception): pass"
                }
            },
            {
                "id": 43,
                "attributes": {
                    "id": 43.0,
                    "label": "hl7.hl7.exceptions.MalformedBatchException",
                    "type": "class",
                    "code": "class MalformedBatchException(HL7Exception): pass",
                    "signature": "class MalformedBatchException(HL7Exception): pass"
                }
            },
            {
                "id": 44,
                "attributes": {
                    "id": 44.0,
                    "label": "hl7.hl7.exceptions.MalformedFileException",
                    "type": "class",
                    "code": "class MalformedFileException(HL7Exception): pass",
                    "signature": "class MalformedFileException(HL7Exception): pass"
                }
            },
            {
                "id": 60,
                "attributes": {
                    "id": 60.0,
                    "label": "hl7.hl7.version",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 61,
                "attributes": {
                    "id": 61.0,
                    "label": "hl7.hl7.version.get_version",
                    "type": "function",
                    "code": "def get_version(): &#34;&#34;&#34;Provide version number  Use verlib format [1]_: N.N[.N]+[{a|b|c|rc}N[.N]+][.postN][.devN]  .. [1] http://www.python.org/dev/peps/pep-0386/ &#34;&#34;&#34; main_version = &#34;%s.%s.%s&#34; % VERSION[0:3]  if len(VERSION) < 4: return main_version  version_type = VERSION[3] if not version_type or version_type == &#34;final&#34;: return main_version elif version_type == &#34;dev&#34;: return &#34;%s.dev&#34; % main_version else: return &#34;%s%s&#34; % (main_version, version_type)",
                    "signature": "def get_version(): &#34;&#34;&#34;Provide version number  Use verlib format [1]_: N.N[.N]+[{a|b|c|rc}N[.N]+][.postN][.devN]  .. [1] http://www.python.org/dev/peps/pep-0386/ &#34;&#34;&#34; main_version = &#34;%s.%s.%s&#34; % VERSION[0:3]  if len(VERSION) < 4: return main_version  version_type = VERSION[3] if not version_type or version_type == &#34;final&#34;: return main_version elif version_type == &#34;dev&#34;: return &#34;%s.dev&#34; % main_version else: return &#34;%s%s&#34; % (main_version, version_type)"
                }
            },
            {
                "id": 69,
                "attributes": {
                    "id": 69.0,
                    "label": "hl7.hl7.__pycache__",
                    "type": "directory",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 100,
                "attributes": {
                    "id": 100.0,
                    "label": "hl7.hl7.containers.Container.__str__",
                    "type": "function",
                    "code": "def __str__(self): return self.separator.join((str(x) for x in self))",
                    "signature": "def __str__(self): return self.separator.join((str(x) for x in self))"
                }
            },
            {
                "id": 107,
                "attributes": {
                    "id": 107.0,
                    "label": "hl7.hl7.containers.File.__str__",
                    "type": "function",
                    "code": "def __str__(self): &#34;&#34;&#34;Join a the child batches into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  If this batch has FHS/FTS segments, they will be added to the beginning/end of the returned string. &#34;&#34;&#34; if (self.header and not self.trailer) or (not self.header and self.trailer): raise MalformedFileException( &#34;Either both header and trailer must be present or neither&#34; ) return ( super(File, self).__str__() if not self.header else str(self.header) + self.separator + super(File, self).__str__() + str(self.trailer) + self.separator )",
                    "signature": "def __str__(self): &#34;&#34;&#34;Join a the child batches into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  If this batch has FHS/FTS segments, they will be added to the beginning/end of the returned string. &#34;&#34;&#34; if (self.header and not self.trailer) or (not self.header and self.trailer): raise MalformedFileException( &#34;Either both header and trailer must be present or neither&#34; ) return ( super(File, self).__str__() if not self.header else str(self.header) + self.separator + super(File, self).__str__() + str(self.trailer) + self.separator )"
                }
            },
            {
                "id": 114,
                "attributes": {
                    "id": 114.0,
                    "label": "hl7.hl7.containers.Batch.__str__",
                    "type": "function",
                    "code": "def __str__(self): &#34;&#34;&#34;Join a the child messages into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  If this batch has BHS/BTS segments, they will be added to the beginning/end of the returned string. &#34;&#34;&#34; if (self.header and not self.trailer) or (not self.header and self.trailer): raise MalformedBatchException( &#34;Either both header and trailer must be present or neither&#34; ) return ( super(Batch, self).__str__() if not self.header else str(self.header) + self.separator + super(Batch, self).__str__() + str(self.trailer) + self.separator )",
                    "signature": "def __str__(self): &#34;&#34;&#34;Join a the child messages into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  If this batch has BHS/BTS segments, they will be added to the beginning/end of the returned string. &#34;&#34;&#34; if (self.header and not self.trailer) or (not self.header and self.trailer): raise MalformedBatchException( &#34;Either both header and trailer must be present or neither&#34; ) return ( super(Batch, self).__str__() if not self.header else str(self.header) + self.separator + super(Batch, self).__str__() + str(self.trailer) + self.separator )"
                }
            },
            {
                "id": 126,
                "attributes": {
                    "id": 126.0,
                    "label": "hl7.hl7.containers.Message.__str__",
                    "type": "function",
                    "code": "def __str__(self): &#34;&#34;&#34;Join a the child containers into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  >>> str(hl7.parse(message)) == message True  &#34;&#34;&#34; # Per spec, Message Construction Rules, Section 2.6 (v2.8), Message ends # with the carriage return return super(Message, self).__str__() + self.separator",
                    "signature": "def __str__(self): &#34;&#34;&#34;Join a the child containers into a single string, separated by the self.separator.  This method acts recursively, calling the children's __unicode__ method.  Thus ``unicode()`` is the approriate method for turning the python-hl7 representation of HL7 into a standard string.  >>> str(hl7.parse(message)) == message True  &#34;&#34;&#34; # Per spec, Message Construction Rules, Section 2.6 (v2.8), Message ends # with the carriage return return super(Message, self).__str__() + self.separator"
                }
            },
            {
                "id": 132,
                "attributes": {
                    "id": 132.0,
                    "label": "hl7.hl7.containers.Segment.__str__",
                    "type": "function",
                    "code": "def __str__(self): if str(self[0]) in [&#34;MSH&#34;, &#34;FHS&#34;, &#34;BHS&#34;]: return ( str(self[0]) + str(self[1]) + str(self[2]) + str(self[1]) + self.separator.join((str(x) for x in self[3:])) ) return super(Segment, self).__str__()",
                    "signature": "def __str__(self): if str(self[0]) in [&#34;MSH&#34;, &#34;FHS&#34;, &#34;BHS&#34;]: return ( str(self[0]) + str(self[1]) + str(self[2]) + str(self[1]) + self.separator.join((str(x) for x in self[3:])) ) return super(Segment, self).__str__()"
                }
            },
            {
                "id": 140,
                "attributes": {
                    "id": 140.0,
                    "label": "hl7.hl7.accessor",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 147,
                "attributes": {
                    "id": 147.0,
                    "label": "hl7.hl7.__init__",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 391,
                "attributes": {
                    "id": 391.0,
                    "label": "hl7.tests.test_version",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 392,
                "attributes": {
                    "id": 392.0,
                    "label": "hl7.tests.test_version.GetVersionTest",
                    "type": "class",
                    "code": "class GetVersionTest(TestCase): @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1)) def test_no_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;&#34;)) def test_empty_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, None)) def test_none_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;final&#34;)) def test_final(self): self.assertEqual(&#34;0.4.1&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;rc&#34;)) def test_rc(self): self.assertEqual(&#34;0.4.1rc&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;rc4&#34;)) def test_rc_num(self): self.assertEqual(&#34;0.4.1rc4&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;b&#34;)) def test_beta(self): self.assertEqual(&#34;0.4.1b&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;a&#34;)) def test_alpha(self): self.assertEqual(&#34;0.4.1a&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;dev&#34;)) def test_dev(self): self.assertEqual(&#34;0.4.1.dev&#34;, get_version())",
                    "signature": "class GetVersionTest(TestCase): @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1)) def test_no_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;&#34;)) def test_empty_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, None)) def test_none_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;final&#34;)) def test_final(self): self.assertEqual(&#34;0.4.1&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;rc&#34;)) def test_rc(self): self.assertEqual(&#34;0.4.1rc&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;rc4&#34;)) def test_rc_num(self): self.assertEqual(&#34;0.4.1rc4&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;b&#34;)) def test_beta(self): self.assertEqual(&#34;0.4.1b&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;a&#34;)) def test_alpha(self): self.assertEqual(&#34;0.4.1a&#34;, get_version())  @patch(&#34;hl7.version.VERSION&#34;, new=(0, 4, 1, &#34;dev&#34;)) def test_dev(self): self.assertEqual(&#34;0.4.1.dev&#34;, get_version())"
                }
            },
            {
                "id": 393,
                "attributes": {
                    "id": 393.0,
                    "label": "hl7.tests.test_version.GetVersionTest.test_no_modifier",
                    "type": "function",
                    "code": "def test_no_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())",
                    "signature": "def test_no_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())"
                }
            },
            {
                "id": 394,
                "attributes": {
                    "id": 394.0,
                    "label": "hl7.tests.test_version.GetVersionTest.test_empty_modifier",
                    "type": "function",
                    "code": "def test_empty_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())",
                    "signature": "def test_empty_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())"
                }
            },
            {
                "id": 395,
                "attributes": {
                    "id": 395.0,
                    "label": "hl7.tests.test_version.GetVersionTest.test_none_modifier",
                    "type": "function",
                    "code": "def test_none_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())",
                    "signature": "def test_none_modifier(self): self.assertEqual(&#34;0.4.1&#34;, get_version())"
                }
            },
            {
                "id": 396,
                "attributes": {
                    "id": 396.0,
                    "label": "hl7.tests.test_version.GetVersionTest.test_final",
                    "type": "function",
                    "code": "def test_final(self): self.assertEqual(&#34;0.4.1&#34;, get_version())",
                    "signature": "def test_final(self): self.assertEqual(&#34;0.4.1&#34;, get_version())"
                }
            },
            {
                "id": 397,
                "attributes": {
                    "id": 397.0,
                    "label": "hl7.tests.test_version.GetVersionTest.test_rc",
                    "type": "function",
                    "code": "def test_rc(self): self.assertEqual(&#34;0.4.1rc&#34;, get_version())",
                    "signature": "def test_rc(self): self.assertEqual(&#34;0.4.1rc&#34;, get_version())"
                }
            },
            {
                "id": 398,
                "attributes": {
                    "id": 398.0,
                    "label": "hl7.tests.test_version.GetVersionTest.test_rc_num",
                    "type": "function",
                    "code": "def test_rc_num(self): self.assertEqual(&#34;0.4.1rc4&#34;, get_version())",
                    "signature": "def test_rc_num(self): self.assertEqual(&#34;0.4.1rc4&#34;, get_version())"
                }
            },
            {
                "id": 399,
                "attributes": {
                    "id": 399.0,
                    "label": "hl7.tests.test_version.GetVersionTest.test_beta",
                    "type": "function",
                    "code": "def test_beta(self): self.assertEqual(&#34;0.4.1b&#34;, get_version())",
                    "signature": "def test_beta(self): self.assertEqual(&#34;0.4.1b&#34;, get_version())"
                }
            },
            {
                "id": 400,
                "attributes": {
                    "id": 400.0,
                    "label": "hl7.tests.test_version.GetVersionTest.test_alpha",
                    "type": "function",
                    "code": "def test_alpha(self): self.assertEqual(&#34;0.4.1a&#34;, get_version())",
                    "signature": "def test_alpha(self): self.assertEqual(&#34;0.4.1a&#34;, get_version())"
                }
            },
            {
                "id": 401,
                "attributes": {
                    "id": 401.0,
                    "label": "hl7.tests.test_version.GetVersionTest.test_dev",
                    "type": "function",
                    "code": "def test_dev(self): self.assertEqual(&#34;0.4.1.dev&#34;, get_version())",
                    "signature": "def test_dev(self): self.assertEqual(&#34;0.4.1.dev&#34;, get_version())"
                }
            },
            {
                "id": 447,
                "attributes": {
                    "id": 447.0,
                    "label": "hl7.setup",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            }
        ]
    },
    "9": {
        "nodes": [
            {
                "id": 191,
                "attributes": {
                    "id": 191.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.__init__",
                    "type": "function",
                    "code": "def __init__(self, methodName=&#34;runTest&#34;): &#34;&#34;&#34;Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name. &#34;&#34;&#34; self._testMethodName = methodName self._outcome = None self._testMethodDoc = &#34;No test&#34; try: testMethod = getattr(self, methodName) except AttributeError: if methodName != &#34;runTest&#34;: # we allow instantiation with no explicit method name # but not an *incorrect* or missing method name raise ValueError( &#34;no such test method in %s: %s&#34; % (self.__class__, methodName) ) else: self._testMethodDoc = testMethod.__doc__ self._cleanups = [] self._subtest = None  # Map types to custom assertEqual functions that will compare # instances of said type in more detail to generate a more useful # error message. self._type_equality_funcs = {} self.addTypeEqualityFunc(dict, &#34;assertDictEqual&#34;) self.addTypeEqualityFunc(list, &#34;assertListEqual&#34;) self.addTypeEqualityFunc(tuple, &#34;assertTupleEqual&#34;) self.addTypeEqualityFunc(set, &#34;assertSetEqual&#34;) self.addTypeEqualityFunc(frozenset, &#34;assertSetEqual&#34;) self.addTypeEqualityFunc(str, &#34;assertMultiLineEqual&#34;)",
                    "signature": "def __init__(self, methodName=&#34;runTest&#34;): &#34;&#34;&#34;Create an instance of the class that will use the named test method when executed. Raises a ValueError if the instance does not have a method with the specified name. &#34;&#34;&#34; self._testMethodName = methodName self._outcome = None self._testMethodDoc = &#34;No test&#34; try: testMethod = getattr(self, methodName) except AttributeError: if methodName != &#34;runTest&#34;: # we allow instantiation with no explicit method name # but not an *incorrect* or missing method name raise ValueError( &#34;no such test method in %s: %s&#34; % (self.__class__, methodName) ) else: self._testMethodDoc = testMethod.__doc__ self._cleanups = [] self._subtest = None  # Map types to custom assertEqual functions that will compare # instances of said type in more detail to generate a more useful # error message. self._type_equality_funcs = {} self.addTypeEqualityFunc(dict, &#34;assertDictEqual&#34;) self.addTypeEqualityFunc(list, &#34;assertListEqual&#34;) self.addTypeEqualityFunc(tuple, &#34;assertTupleEqual&#34;) self.addTypeEqualityFunc(set, &#34;assertSetEqual&#34;) self.addTypeEqualityFunc(frozenset, &#34;assertSetEqual&#34;) self.addTypeEqualityFunc(str, &#34;assertMultiLineEqual&#34;)"
                }
            },
            {
                "id": 192,
                "attributes": {
                    "id": 192.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.addTypeEqualityFunc",
                    "type": "function",
                    "code": "def addTypeEqualityFunc(self, typeobj, function): &#34;&#34;&#34;Add a type specific assertEqual style function to compare a type.  This method is for use by TestCase subclasses that need to register their own type equality functions to provide nicer error messages.  Args: typeobj: The data type to call this function on when both values are of the same type in assertEqual(). function: The callable taking two arguments and an optional msg= argument that raises self.failureException with a useful error message when the two arguments are not equal. &#34;&#34;&#34; self._type_equality_funcs[typeobj] = function",
                    "signature": "def addTypeEqualityFunc(self, typeobj, function): &#34;&#34;&#34;Add a type specific assertEqual style function to compare a type.  This method is for use by TestCase subclasses that need to register their own type equality functions to provide nicer error messages.  Args: typeobj: The data type to call this function on when both values are of the same type in assertEqual(). function: The callable taking two arguments and an optional msg= argument that raises self.failureException with a useful error message when the two arguments are not equal. &#34;&#34;&#34; self._type_equality_funcs[typeobj] = function"
                }
            },
            {
                "id": 201,
                "attributes": {
                    "id": 201.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.shortDescription",
                    "type": "function",
                    "code": "def shortDescription(self): &#34;&#34;&#34;Returns a one-line description of the test, or None if no description has been provided.  The default implementation of this method returns the first line of the specified test method's docstring. &#34;&#34;&#34; doc = self._testMethodDoc return doc.strip().split(&#34;\\n&#34;)[0].strip() if doc else None",
                    "signature": "def shortDescription(self): &#34;&#34;&#34;Returns a one-line description of the test, or None if no description has been provided.  The default implementation of this method returns the first line of the specified test method's docstring. &#34;&#34;&#34; doc = self._testMethodDoc return doc.strip().split(&#34;\\n&#34;)[0].strip() if doc else None"
                }
            },
            {
                "id": 202,
                "attributes": {
                    "id": 202.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.id",
                    "type": "function",
                    "code": "def id(self): return &#34;%s.%s&#34; % (strclass(self.__class__), self._testMethodName)",
                    "signature": "def id(self): return &#34;%s.%s&#34; % (strclass(self.__class__), self._testMethodName)"
                }
            },
            {
                "id": 262,
                "attributes": {
                    "id": 262.0,
                    "label": "hl7.tests.backports.unittest.case.FunctionTestCase",
                    "type": "class",
                    "code": "class FunctionTestCase(TestCase): &#34;&#34;&#34;A test case that wraps a test function.  This is useful for slipping pre-existing test functions into the unittest framework. Optionally, set-up and tidy-up functions can be supplied. As with TestCase, the tidy-up ('tearDown') function will always be called if the set-up ('setUp') function ran successfully. &#34;&#34;&#34;  def __init__(self, testFunc, setUp=None, tearDown=None, description=None): super(FunctionTestCase, self).__init__() self._setUpFunc = setUp self._tearDownFunc = tearDown self._testFunc = testFunc self._description = description  def setUp(self): if self._setUpFunc is not None: self._setUpFunc()  def tearDown(self): if self._tearDownFunc is not None: self._tearDownFunc()  def runTest(self): self._testFunc()  def id(self): return self._testFunc.__name__  def __eq__(self, other): if not isinstance(other, self.__class__): return NotImplemented  return ( self._setUpFunc == other._setUpFunc and self._tearDownFunc == other._tearDownFunc and self._testFunc == other._testFunc and self._description == other._description )  def __hash__(self): return hash( ( type(self), self._setUpFunc, self._tearDownFunc, self._testFunc, self._description, ) )  def __str__(self): return &#34;%s (%s)&#34; % (strclass(self.__class__), self._testFunc.__name__)  def __repr__(self): return &#34;<%s tec=%s>&#34; % (strclass(self.__class__), self._testFunc)  def shortDescription(self): if self._description is not None: return self._description doc = self._testFunc.__doc__ return doc and doc.split(&#34;\\n&#34;)[0].strip() or None",
                    "signature": "class FunctionTestCase(TestCase): &#34;&#34;&#34;A test case that wraps a test function.  This is useful for slipping pre-existing test functions into the unittest framework. Optionally, set-up and tidy-up functions can be supplied. As with TestCase, the tidy-up ('tearDown') function will always be called if the set-up ('setUp') function ran successfully. &#34;&#34;&#34;  def __init__(self, testFunc, setUp=None, tearDown=None, description=None): super(FunctionTestCase, self).__init__() self._setUpFunc = setUp self._tearDownFunc = tearDown self._testFunc = testFunc self._description = description  def setUp(self): if self._setUpFunc is not None: self._setUpFunc()  def tearDown(self): if self._tearDownFunc is not None: self._tearDownFunc()  def runTest(self): self._testFunc()  def id(self): return self._testFunc.__name__  def __eq__(self, other): if not isinstance(other, self.__class__): return NotImplemented  return ( self._setUpFunc == other._setUpFunc and self._tearDownFunc == other._tearDownFunc and self._testFunc == other._testFunc and self._description == other._description )  def __hash__(self): return hash( ( type(self), self._setUpFunc, self._tearDownFunc, self._testFunc, self._description, ) )  def __str__(self): return &#34;%s (%s)&#34; % (strclass(self.__class__), self._testFunc.__name__)  def __repr__(self): return &#34;<%s tec=%s>&#34; % (strclass(self.__class__), self._testFunc)  def shortDescription(self): if self._description is not None: return self._description doc = self._testFunc.__doc__ return doc and doc.split(&#34;\\n&#34;)[0].strip() or None"
                }
            },
            {
                "id": 263,
                "attributes": {
                    "id": 263.0,
                    "label": "hl7.tests.backports.unittest.case.FunctionTestCase.__init__",
                    "type": "function",
                    "code": "def __init__(self, testFunc, setUp=None, tearDown=None, description=None): super(FunctionTestCase, self).__init__() self._setUpFunc = setUp self._tearDownFunc = tearDown self._testFunc = testFunc self._description = description",
                    "signature": "def __init__(self, testFunc, setUp=None, tearDown=None, description=None): super(FunctionTestCase, self).__init__() self._setUpFunc = setUp self._tearDownFunc = tearDown self._testFunc = testFunc self._description = description"
                }
            },
            {
                "id": 264,
                "attributes": {
                    "id": 264.0,
                    "label": "hl7.tests.backports.unittest.case.FunctionTestCase.setUp",
                    "type": "function",
                    "code": "def setUp(self): if self._setUpFunc is not None: self._setUpFunc()",
                    "signature": "def setUp(self): if self._setUpFunc is not None: self._setUpFunc()"
                }
            },
            {
                "id": 265,
                "attributes": {
                    "id": 265.0,
                    "label": "hl7.tests.backports.unittest.case.FunctionTestCase.tearDown",
                    "type": "function",
                    "code": "def tearDown(self): if self._tearDownFunc is not None: self._tearDownFunc()",
                    "signature": "def tearDown(self): if self._tearDownFunc is not None: self._tearDownFunc()"
                }
            },
            {
                "id": 266,
                "attributes": {
                    "id": 266.0,
                    "label": "hl7.tests.backports.unittest.case.FunctionTestCase.runTest",
                    "type": "function",
                    "code": "def runTest(self): self._testFunc()",
                    "signature": "def runTest(self): self._testFunc()"
                }
            },
            {
                "id": 267,
                "attributes": {
                    "id": 267.0,
                    "label": "hl7.tests.backports.unittest.case.FunctionTestCase.id",
                    "type": "function",
                    "code": "def id(self): return self._testFunc.__name__",
                    "signature": "def id(self): return self._testFunc.__name__"
                }
            },
            {
                "id": 268,
                "attributes": {
                    "id": 268.0,
                    "label": "hl7.tests.backports.unittest.case.FunctionTestCase.__eq__",
                    "type": "function",
                    "code": "def __eq__(self, other): if not isinstance(other, self.__class__): return NotImplemented  return ( self._setUpFunc == other._setUpFunc and self._tearDownFunc == other._tearDownFunc and self._testFunc == other._testFunc and self._description == other._description )",
                    "signature": "def __eq__(self, other): if not isinstance(other, self.__class__): return NotImplemented  return ( self._setUpFunc == other._setUpFunc and self._tearDownFunc == other._tearDownFunc and self._testFunc == other._testFunc and self._description == other._description )"
                }
            },
            {
                "id": 269,
                "attributes": {
                    "id": 269.0,
                    "label": "hl7.tests.backports.unittest.case.FunctionTestCase.__hash__",
                    "type": "function",
                    "code": "def __hash__(self): return hash( ( type(self), self._setUpFunc, self._tearDownFunc, self._testFunc, self._description, ) )",
                    "signature": "def __hash__(self): return hash( ( type(self), self._setUpFunc, self._tearDownFunc, self._testFunc, self._description, ) )"
                }
            },
            {
                "id": 270,
                "attributes": {
                    "id": 270.0,
                    "label": "hl7.tests.backports.unittest.case.FunctionTestCase.__str__",
                    "type": "function",
                    "code": "def __str__(self): return &#34;%s (%s)&#34; % (strclass(self.__class__), self._testFunc.__name__)",
                    "signature": "def __str__(self): return &#34;%s (%s)&#34; % (strclass(self.__class__), self._testFunc.__name__)"
                }
            },
            {
                "id": 271,
                "attributes": {
                    "id": 271.0,
                    "label": "hl7.tests.backports.unittest.case.FunctionTestCase.__repr__",
                    "type": "function",
                    "code": "def __repr__(self): return &#34;<%s tec=%s>&#34; % (strclass(self.__class__), self._testFunc)",
                    "signature": "def __repr__(self): return &#34;<%s tec=%s>&#34; % (strclass(self.__class__), self._testFunc)"
                }
            },
            {
                "id": 272,
                "attributes": {
                    "id": 272.0,
                    "label": "hl7.tests.backports.unittest.case.FunctionTestCase.shortDescription",
                    "type": "function",
                    "code": "def shortDescription(self): if self._description is not None: return self._description doc = self._testFunc.__doc__ return doc and doc.split(&#34;\\n&#34;)[0].strip() or None",
                    "signature": "def shortDescription(self): if self._description is not None: return self._description doc = self._testFunc.__doc__ return doc and doc.split(&#34;\\n&#34;)[0].strip() or None"
                }
            },
            {
                "id": 273,
                "attributes": {
                    "id": 273.0,
                    "label": "hl7.tests.backports.unittest.case._SubTest",
                    "type": "class",
                    "code": "class _SubTest(TestCase): def __init__(self, test_case, message, params): super().__init__() self._message = message self.test_case = test_case self.params = params self.failureException = test_case.failureException  def runTest(self): raise NotImplementedError(&#34;subtests cannot be run directly&#34;)  def _subDescription(self): parts = [] if self._message is not _subtest_msg_sentinel: parts.append(&#34;[{}]&#34;.format(self._message)) if self.params: params_desc = &#34;, &#34;.join( &#34;{}={!r}&#34;.format(k, v) for (k, v) in self.params.items() ) parts.append(&#34;({})&#34;.format(params_desc)) return &#34; &#34;.join(parts) or &#34;(<subtest>)&#34;  def id(self): return &#34;{} {}&#34;.format(self.test_case.id(), self._subDescription())  def shortDescription(self): &#34;&#34;&#34;Returns a one-line description of the subtest, or None if no description has been provided. &#34;&#34;&#34; return self.test_case.shortDescription()  def __str__(self): return &#34;{} {}&#34;.format(self.test_case, self._subDescription())",
                    "signature": "class _SubTest(TestCase): def __init__(self, test_case, message, params): super().__init__() self._message = message self.test_case = test_case self.params = params self.failureException = test_case.failureException  def runTest(self): raise NotImplementedError(&#34;subtests cannot be run directly&#34;)  def _subDescription(self): parts = [] if self._message is not _subtest_msg_sentinel: parts.append(&#34;[{}]&#34;.format(self._message)) if self.params: params_desc = &#34;, &#34;.join( &#34;{}={!r}&#34;.format(k, v) for (k, v) in self.params.items() ) parts.append(&#34;({})&#34;.format(params_desc)) return &#34; &#34;.join(parts) or &#34;(<subtest>)&#34;  def id(self): return &#34;{} {}&#34;.format(self.test_case.id(), self._subDescription())  def shortDescription(self): &#34;&#34;&#34;Returns a one-line description of the subtest, or None if no description has been provided. &#34;&#34;&#34; return self.test_case.shortDescription()  def __str__(self): return &#34;{} {}&#34;.format(self.test_case, self._subDescription())"
                }
            },
            {
                "id": 274,
                "attributes": {
                    "id": 274.0,
                    "label": "hl7.tests.backports.unittest.case._SubTest.__init__",
                    "type": "function",
                    "code": "def __init__(self, test_case, message, params): super().__init__() self._message = message self.test_case = test_case self.params = params self.failureException = test_case.failureException",
                    "signature": "def __init__(self, test_case, message, params): super().__init__() self._message = message self.test_case = test_case self.params = params self.failureException = test_case.failureException"
                }
            },
            {
                "id": 275,
                "attributes": {
                    "id": 275.0,
                    "label": "hl7.tests.backports.unittest.case._SubTest.runTest",
                    "type": "function",
                    "code": "def runTest(self): raise NotImplementedError(&#34;subtests cannot be run directly&#34;)",
                    "signature": "def runTest(self): raise NotImplementedError(&#34;subtests cannot be run directly&#34;)"
                }
            },
            {
                "id": 276,
                "attributes": {
                    "id": 276.0,
                    "label": "hl7.tests.backports.unittest.case._SubTest._subDescription",
                    "type": "function",
                    "code": "def _subDescription(self): parts = [] if self._message is not _subtest_msg_sentinel: parts.append(&#34;[{}]&#34;.format(self._message)) if self.params: params_desc = &#34;, &#34;.join( &#34;{}={!r}&#34;.format(k, v) for (k, v) in self.params.items() ) parts.append(&#34;({})&#34;.format(params_desc)) return &#34; &#34;.join(parts) or &#34;(<subtest>)&#34;",
                    "signature": "def _subDescription(self): parts = [] if self._message is not _subtest_msg_sentinel: parts.append(&#34;[{}]&#34;.format(self._message)) if self.params: params_desc = &#34;, &#34;.join( &#34;{}={!r}&#34;.format(k, v) for (k, v) in self.params.items() ) parts.append(&#34;({})&#34;.format(params_desc)) return &#34; &#34;.join(parts) or &#34;(<subtest>)&#34;"
                }
            },
            {
                "id": 277,
                "attributes": {
                    "id": 277.0,
                    "label": "hl7.tests.backports.unittest.case._SubTest.id",
                    "type": "function",
                    "code": "def id(self): return &#34;{} {}&#34;.format(self.test_case.id(), self._subDescription())",
                    "signature": "def id(self): return &#34;{} {}&#34;.format(self.test_case.id(), self._subDescription())"
                }
            },
            {
                "id": 278,
                "attributes": {
                    "id": 278.0,
                    "label": "hl7.tests.backports.unittest.case._SubTest.shortDescription",
                    "type": "function",
                    "code": "def shortDescription(self): &#34;&#34;&#34;Returns a one-line description of the subtest, or None if no description has been provided. &#34;&#34;&#34; return self.test_case.shortDescription()",
                    "signature": "def shortDescription(self): &#34;&#34;&#34;Returns a one-line description of the subtest, or None if no description has been provided. &#34;&#34;&#34; return self.test_case.shortDescription()"
                }
            },
            {
                "id": 279,
                "attributes": {
                    "id": 279.0,
                    "label": "hl7.tests.backports.unittest.case._SubTest.__str__",
                    "type": "function",
                    "code": "def __str__(self): return &#34;{} {}&#34;.format(self.test_case, self._subDescription())",
                    "signature": "def __str__(self): return &#34;{} {}&#34;.format(self.test_case, self._subDescription())"
                }
            }
        ]
    },
    "10": {
        "nodes": [
            {
                "id": 5,
                "attributes": {
                    "id": 5.0,
                    "label": "hl7.hl7.util",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 6,
                "attributes": {
                    "id": 6.0,
                    "label": "hl7.hl7.util.ishl7",
                    "type": "function",
                    "code": "def ishl7(line): &#34;&#34;&#34;Determines whether a *line* looks like an HL7 message. This method only does a cursory check and does not fully validate the message.  :rtype: bool &#34;&#34;&#34; # Prevent issues if the line is empty if not line: return False msh = line.strip()[:4] if len(msh) != 4: return False return msh[:3] == &#34;MSH&#34; and line.count(&#34;\\rMSH&#34; + msh[3]) == 0",
                    "signature": "def ishl7(line): &#34;&#34;&#34;Determines whether a *line* looks like an HL7 message. This method only does a cursory check and does not fully validate the message.  :rtype: bool &#34;&#34;&#34; # Prevent issues if the line is empty if not line: return False msh = line.strip()[:4] if len(msh) != 4: return False return msh[:3] == &#34;MSH&#34; and line.count(&#34;\\rMSH&#34; + msh[3]) == 0"
                }
            },
            {
                "id": 7,
                "attributes": {
                    "id": 7.0,
                    "label": "hl7.hl7.util.isbatch",
                    "type": "function",
                    "code": "def isbatch(line): &#34;&#34;&#34; Batches are wrapped in BHS / BTS or have more than one message BHS = batch header segment BTS = batch trailer segment &#34;&#34;&#34; return line and ( line.strip()[:3] == &#34;BHS&#34; or (line.count(&#34;MSH&#34;) > 1 and line.strip()[:3] != &#34;FHS&#34;) )",
                    "signature": "def isbatch(line): &#34;&#34;&#34; Batches are wrapped in BHS / BTS or have more than one message BHS = batch header segment BTS = batch trailer segment &#34;&#34;&#34; return line and ( line.strip()[:3] == &#34;BHS&#34; or (line.count(&#34;MSH&#34;) > 1 and line.strip()[:3] != &#34;FHS&#34;) )"
                }
            },
            {
                "id": 8,
                "attributes": {
                    "id": 8.0,
                    "label": "hl7.hl7.util.isfile",
                    "type": "function",
                    "code": "def isfile(line): &#34;&#34;&#34; Files are wrapped in FHS / FTS, or may be a batch FHS = file header segment FTS = file trailer segment &#34;&#34;&#34; return line and (line.strip()[:3] == &#34;FHS&#34; or isbatch(line))",
                    "signature": "def isfile(line): &#34;&#34;&#34; Files are wrapped in FHS / FTS, or may be a batch FHS = file header segment FTS = file trailer segment &#34;&#34;&#34; return line and (line.strip()[:3] == &#34;FHS&#34; or isbatch(line))"
                }
            },
            {
                "id": 9,
                "attributes": {
                    "id": 9.0,
                    "label": "hl7.hl7.util.split_file",
                    "type": "function",
                    "code": "def split_file(hl7file): &#34;&#34;&#34; Given a file, split out the messages. Does not do any validation on the message. Throws away batch and file segments. &#34;&#34;&#34; rv = [] for line in hl7file.split(&#34;\\r&#34;): line = line.strip() if line[:3] in [&#34;FHS&#34;, &#34;BHS&#34;, &#34;FTS&#34;, &#34;BTS&#34;]: continue if line[:3] == &#34;MSH&#34;: newmsg = [line] rv.append(newmsg) else: if len(rv) == 0: logger.error(&#34;Segment received before message header [%s]&#34;, line) continue rv[-1].append(line) rv = [&#34;\\r&#34;.join(msg) for msg in rv] for i, msg in enumerate(rv): if not msg[-1] == &#34;\\r&#34;: rv[i] = msg + &#34;\\r&#34; return rv",
                    "signature": "def split_file(hl7file): &#34;&#34;&#34; Given a file, split out the messages. Does not do any validation on the message. Throws away batch and file segments. &#34;&#34;&#34; rv = [] for line in hl7file.split(&#34;\\r&#34;): line = line.strip() if line[:3] in [&#34;FHS&#34;, &#34;BHS&#34;, &#34;FTS&#34;, &#34;BTS&#34;]: continue if line[:3] == &#34;MSH&#34;: newmsg = [line] rv.append(newmsg) else: if len(rv) == 0: logger.error(&#34;Segment received before message header [%s]&#34;, line) continue rv[-1].append(line) rv = [&#34;\\r&#34;.join(msg) for msg in rv] for i, msg in enumerate(rv): if not msg[-1] == &#34;\\r&#34;: rv[i] = msg + &#34;\\r&#34; return rv"
                }
            },
            {
                "id": 10,
                "attributes": {
                    "id": 10.0,
                    "label": "hl7.hl7.util.generate_message_control_id",
                    "type": "function",
                    "code": "def generate_message_control_id(): &#34;&#34;&#34;Generate a unique 20 character message id.  See http://www.hl7resources.com/Public/index.html?a55433.htm &#34;&#34;&#34; d = datetime.datetime.utcnow() # Strip off the decade, ID only has to be unique for 3 years. # So now we have a 16 char timestamp. timestamp = d.strftime(&#34;%y%j%H%M%S%f&#34;)[1:] # Add 4 chars of uniqueness unique = &#34;&#34;.join(random.sample(alphanumerics, 4)) return timestamp + unique",
                    "signature": "def generate_message_control_id(): &#34;&#34;&#34;Generate a unique 20 character message id.  See http://www.hl7resources.com/Public/index.html?a55433.htm &#34;&#34;&#34; d = datetime.datetime.utcnow() # Strip off the decade, ID only has to be unique for 3 years. # So now we have a 16 char timestamp. timestamp = d.strftime(&#34;%y%j%H%M%S%f&#34;)[1:] # Add 4 chars of uniqueness unique = &#34;&#34;.join(random.sample(alphanumerics, 4)) return timestamp + unique"
                }
            },
            {
                "id": 11,
                "attributes": {
                    "id": 11.0,
                    "label": "hl7.hl7.util.escape",
                    "type": "function",
                    "code": "def escape(container, field, app_map=None): &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  Pass through the message. Replace recognised characters with their escaped version. Return an ascii encoded string.  Functionality:  *   Replace separator characters (2.10.4) *   replace application defined characters (2.10.7) *   Replace non-ascii values with hex versions using HL7 conventions.  Incomplete:  *   replace highlight characters (2.10.3) *   How to handle the rich text substitutions. *   Merge contiguous hex values &#34;&#34;&#34; if not field: return field  esc = str(container.esc)  DEFAULT_MAP = { container.separators[1]: &#34;F&#34;,  # 2.10.4 container.separators[2]: &#34;R&#34;, container.separators[3]: &#34;S&#34;, container.separators[4]: &#34;T&#34;, container.esc: &#34;E&#34;, &#34;\\r&#34;: &#34;.br&#34;,  # 2.10.6 }  rv = [] for offset, c in enumerate(field): if app_map and c in app_map: rv.append(esc + app_map[c] + esc) elif c in DEFAULT_MAP: rv.append(esc + DEFAULT_MAP[c] + esc) elif ord(c) >= 0x20 and ord(c) <= 0x7E: rv.append(c) else: rv.append(&#34;%sX%2x%s&#34; % (esc, ord(c), esc))  return &#34;&#34;.join(rv)",
                    "signature": "def escape(container, field, app_map=None): &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  Pass through the message. Replace recognised characters with their escaped version. Return an ascii encoded string.  Functionality:  *   Replace separator characters (2.10.4) *   replace application defined characters (2.10.7) *   Replace non-ascii values with hex versions using HL7 conventions.  Incomplete:  *   replace highlight characters (2.10.3) *   How to handle the rich text substitutions. *   Merge contiguous hex values &#34;&#34;&#34; if not field: return field  esc = str(container.esc)  DEFAULT_MAP = { container.separators[1]: &#34;F&#34;,  # 2.10.4 container.separators[2]: &#34;R&#34;, container.separators[3]: &#34;S&#34;, container.separators[4]: &#34;T&#34;, container.esc: &#34;E&#34;, &#34;\\r&#34;: &#34;.br&#34;,  # 2.10.6 }  rv = [] for offset, c in enumerate(field): if app_map and c in app_map: rv.append(esc + app_map[c] + esc) elif c in DEFAULT_MAP: rv.append(esc + DEFAULT_MAP[c] + esc) elif ord(c) >= 0x20 and ord(c) <= 0x7E: rv.append(c) else: rv.append(&#34;%sX%2x%s&#34; % (esc, ord(c), esc))  return &#34;&#34;.join(rv)"
                }
            },
            {
                "id": 47,
                "attributes": {
                    "id": 47.0,
                    "label": "hl7.hl7.parser.parse_hl7",
                    "type": "function",
                    "code": "def parse_hl7(line, encoding=&#34;utf-8&#34;, factory=Factory): &#34;&#34;&#34;Returns a instance of the :py:class:`hl7.Message`, :py:class:`hl7.Batch` or :py:class:`hl7.File` that allows indexed access to the data elements or messages or batches respectively.  A custom :py:class:`hl7.Factory` subclass can be passed in to be used when constructing the message/batch/file and it's components.  .. note::  HL7 usually contains only ASCII, but can use other character sets (HL7 Standards Document, Section 1.7.1), however as of v2.8, UTF-8 is the preferred character set [#]_.  python-hl7 works on Python unicode strings. :py:func:`hl7.parse_hl7` will accept unicode string or will attempt to convert bytestrings into unicode strings using the optional ``encoding`` parameter. ``encoding`` defaults to UTF-8, so no work is needed for bytestrings in UTF-8, but for other character sets like 'cp1252' or 'latin1', ``encoding`` must be set appropriately.  >>> h = hl7.parse_hl7(message)  To decode a non-UTF-8 byte string::  hl7.parse_hl7(message, encoding='latin1')  :rtype: :py:class:`hl7.Message` | :py:class:`hl7.Batch` | :py:class:`hl7.File`  .. [#] http://wiki.hl7.org/index.php?title=Character_Set_used_in_v2_messages  &#34;&#34;&#34; # Ensure we are working with unicode data, decode the bytestring # if needed if isinstance(line, bytes): line = line.decode(encoding) # If it is an HL7 message, parse as normal if ishl7(line): return parse(line, encoding=encoding, factory=factory) # If we have a batch, then parse the batch elif isbatch(line): return parse_batch(line, encoding=encoding, factory=factory) # If we have a file, parse the HL7 file elif isfile(line): return parse_file(line, encoding=encoding, factory=factory) # Not an HL7 message raise ValueError(&#34;line is not HL7&#34;)",
                    "signature": "def parse_hl7(line, encoding=&#34;utf-8&#34;, factory=Factory): &#34;&#34;&#34;Returns a instance of the :py:class:`hl7.Message`, :py:class:`hl7.Batch` or :py:class:`hl7.File` that allows indexed access to the data elements or messages or batches respectively.  A custom :py:class:`hl7.Factory` subclass can be passed in to be used when constructing the message/batch/file and it's components.  .. note::  HL7 usually contains only ASCII, but can use other character sets (HL7 Standards Document, Section 1.7.1), however as of v2.8, UTF-8 is the preferred character set [#]_.  python-hl7 works on Python unicode strings. :py:func:`hl7.parse_hl7` will accept unicode string or will attempt to convert bytestrings into unicode strings using the optional ``encoding`` parameter. ``encoding`` defaults to UTF-8, so no work is needed for bytestrings in UTF-8, but for other character sets like 'cp1252' or 'latin1', ``encoding`` must be set appropriately.  >>> h = hl7.parse_hl7(message)  To decode a non-UTF-8 byte string::  hl7.parse_hl7(message, encoding='latin1')  :rtype: :py:class:`hl7.Message` | :py:class:`hl7.Batch` | :py:class:`hl7.File`  .. [#] http://wiki.hl7.org/index.php?title=Character_Set_used_in_v2_messages  &#34;&#34;&#34; # Ensure we are working with unicode data, decode the bytestring # if needed if isinstance(line, bytes): line = line.decode(encoding) # If it is an HL7 message, parse as normal if ishl7(line): return parse(line, encoding=encoding, factory=factory) # If we have a batch, then parse the batch elif isbatch(line): return parse_batch(line, encoding=encoding, factory=factory) # If we have a file, parse the HL7 file elif isfile(line): return parse_file(line, encoding=encoding, factory=factory) # Not an HL7 message raise ValueError(&#34;line is not HL7&#34;)"
                }
            },
            {
                "id": 123,
                "attributes": {
                    "id": 123.0,
                    "label": "hl7.hl7.containers.Message.escape",
                    "type": "function",
                    "code": "def escape(self, field, app_map=None): &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  Pass through the message. Replace recognised characters with their escaped version. Return an ascii encoded string.  Functionality:  *   Replace separator characters (2.10.4) *   replace application defined characters (2.10.7) *   Replace non-ascii values with hex versions using HL7 conventions.  Incomplete:  *   replace highlight characters (2.10.3) *   How to handle the rich text substitutions. *   Merge contiguous hex values &#34;&#34;&#34; return escape(self, field, app_map)",
                    "signature": "def escape(self, field, app_map=None): &#34;&#34;&#34; See: http://www.hl7standards.com/blog/2006/11/02/hl7-escape-sequences/  To process this correctly, the full set of separators (MSH.1/MSH.2) needs to be known.  Pass through the message. Replace recognised characters with their escaped version. Return an ascii encoded string.  Functionality:  *   Replace separator characters (2.10.4) *   replace application defined characters (2.10.7) *   Replace non-ascii values with hex versions using HL7 conventions.  Incomplete:  *   replace highlight characters (2.10.3) *   How to handle the rich text substitutions. *   Merge contiguous hex values &#34;&#34;&#34; return escape(self, field, app_map)"
                }
            },
            {
                "id": 223,
                "attributes": {
                    "id": 223.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertFalse",
                    "type": "function",
                    "code": "def assertFalse(self, expr, msg=None): &#34;&#34;&#34;Check that the expression is false.&#34;&#34;&#34; if expr: msg = self._formatMessage(msg, &#34;%s is not false&#34; % safe_repr(expr)) raise self.failureException(msg)",
                    "signature": "def assertFalse(self, expr, msg=None): &#34;&#34;&#34;Check that the expression is false.&#34;&#34;&#34; if expr: msg = self._formatMessage(msg, &#34;%s is not false&#34; % safe_repr(expr)) raise self.failureException(msg)"
                }
            },
            {
                "id": 224,
                "attributes": {
                    "id": 224.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.assertTrue",
                    "type": "function",
                    "code": "def assertTrue(self, expr, msg=None): &#34;&#34;&#34;Check that the expression is true.&#34;&#34;&#34; if not expr: msg = self._formatMessage(msg, &#34;%s is not true&#34; % safe_repr(expr)) raise self.failureException(msg)",
                    "signature": "def assertTrue(self, expr, msg=None): &#34;&#34;&#34;Check that the expression is true.&#34;&#34;&#34; if not expr: msg = self._formatMessage(msg, &#34;%s is not true&#34; % safe_repr(expr)) raise self.failureException(msg)"
                }
            },
            {
                "id": 385,
                "attributes": {
                    "id": 385.0,
                    "label": "hl7.tests.test_parse.ParseTest.test_file",
                    "type": "function",
                    "code": "def test_file(self): # Extract message from file self.assertTrue(hl7.isfile(sample_file)) messages = hl7.split_file(sample_file) self.assertEqual(len(messages), 1)  # message can be parsed msg = hl7.parse(messages[0])  # message has expected content self.assertEqual( [s[0][0] for s in msg], [&#34;MSH&#34;, &#34;EVN&#34;, &#34;PID&#34;, &#34;PD1&#34;, &#34;NK1&#34;, &#34;PV1&#34;] )",
                    "signature": "def test_file(self): # Extract message from file self.assertTrue(hl7.isfile(sample_file)) messages = hl7.split_file(sample_file) self.assertEqual(len(messages), 1)  # message can be parsed msg = hl7.parse(messages[0])  # message has expected content self.assertEqual( [s[0][0] for s in msg], [&#34;MSH&#34;, &#34;EVN&#34;, &#34;PID&#34;, &#34;PD1&#34;, &#34;NK1&#34;, &#34;PV1&#34;] )"
                }
            },
            {
                "id": 411,
                "attributes": {
                    "id": 411.0,
                    "label": "hl7.tests.test_util.IsHL7Test",
                    "type": "class",
                    "code": "class IsHL7Test(TestCase): def test_ishl7(self): self.assertTrue(hl7.ishl7(sample_hl7)) self.assertFalse(hl7.ishl7(sample_batch)) self.assertFalse(hl7.ishl7(sample_batch1)) self.assertFalse(hl7.ishl7(sample_batch2)) self.assertFalse(hl7.ishl7(sample_file)) self.assertFalse(hl7.ishl7(sample_file1)) self.assertFalse(hl7.ishl7(sample_file2)) self.assertTrue(hl7.ishl7(sample_msh))  def test_ishl7_empty(self): self.assertFalse(hl7.ishl7(&#34;&#34;))  def test_ishl7_None(self): self.assertFalse(hl7.ishl7(None))  def test_ishl7_wrongsegment(self): message = &#34;OBX|1|SN|1554-5^GLUCOSE^POST 12H CFST:MCNC:PT:SER/PLAS:QN||^182|mg/dl|70_105|H|||F\\r&#34; self.assertFalse(hl7.ishl7(message))  def test_isbatch(self): self.assertFalse(hl7.ishl7(sample_batch)) self.assertFalse(hl7.ishl7(sample_batch1)) self.assertFalse(hl7.ishl7(sample_batch2)) self.assertTrue(hl7.isbatch(sample_batch)) self.assertTrue(hl7.isbatch(sample_batch1)) self.assertTrue(hl7.isbatch(sample_batch2))  def test_isfile(self): self.assertFalse(hl7.ishl7(sample_file)) self.assertFalse(hl7.ishl7(sample_file1)) self.assertFalse(hl7.ishl7(sample_file2)) self.assertFalse(hl7.isbatch(sample_file)) self.assertFalse(hl7.isbatch(sample_file1)) self.assertFalse(hl7.isbatch(sample_file2)) self.assertTrue(hl7.isfile(sample_file)) self.assertTrue(hl7.isfile(sample_file1)) self.assertTrue(hl7.isfile(sample_file2)) self.assertTrue(hl7.isfile(sample_batch)) self.assertTrue(hl7.isfile(sample_batch1)) self.assertTrue(hl7.isfile(sample_batch2))",
                    "signature": "class IsHL7Test(TestCase): def test_ishl7(self): self.assertTrue(hl7.ishl7(sample_hl7)) self.assertFalse(hl7.ishl7(sample_batch)) self.assertFalse(hl7.ishl7(sample_batch1)) self.assertFalse(hl7.ishl7(sample_batch2)) self.assertFalse(hl7.ishl7(sample_file)) self.assertFalse(hl7.ishl7(sample_file1)) self.assertFalse(hl7.ishl7(sample_file2)) self.assertTrue(hl7.ishl7(sample_msh))  def test_ishl7_empty(self): self.assertFalse(hl7.ishl7(&#34;&#34;))  def test_ishl7_None(self): self.assertFalse(hl7.ishl7(None))  def test_ishl7_wrongsegment(self): message = &#34;OBX|1|SN|1554-5^GLUCOSE^POST 12H CFST:MCNC:PT:SER/PLAS:QN||^182|mg/dl|70_105|H|||F\\r&#34; self.assertFalse(hl7.ishl7(message))  def test_isbatch(self): self.assertFalse(hl7.ishl7(sample_batch)) self.assertFalse(hl7.ishl7(sample_batch1)) self.assertFalse(hl7.ishl7(sample_batch2)) self.assertTrue(hl7.isbatch(sample_batch)) self.assertTrue(hl7.isbatch(sample_batch1)) self.assertTrue(hl7.isbatch(sample_batch2))  def test_isfile(self): self.assertFalse(hl7.ishl7(sample_file)) self.assertFalse(hl7.ishl7(sample_file1)) self.assertFalse(hl7.ishl7(sample_file2)) self.assertFalse(hl7.isbatch(sample_file)) self.assertFalse(hl7.isbatch(sample_file1)) self.assertFalse(hl7.isbatch(sample_file2)) self.assertTrue(hl7.isfile(sample_file)) self.assertTrue(hl7.isfile(sample_file1)) self.assertTrue(hl7.isfile(sample_file2)) self.assertTrue(hl7.isfile(sample_batch)) self.assertTrue(hl7.isfile(sample_batch1)) self.assertTrue(hl7.isfile(sample_batch2))"
                }
            },
            {
                "id": 412,
                "attributes": {
                    "id": 412.0,
                    "label": "hl7.tests.test_util.IsHL7Test.test_ishl7",
                    "type": "function",
                    "code": "def test_ishl7(self): self.assertTrue(hl7.ishl7(sample_hl7)) self.assertFalse(hl7.ishl7(sample_batch)) self.assertFalse(hl7.ishl7(sample_batch1)) self.assertFalse(hl7.ishl7(sample_batch2)) self.assertFalse(hl7.ishl7(sample_file)) self.assertFalse(hl7.ishl7(sample_file1)) self.assertFalse(hl7.ishl7(sample_file2)) self.assertTrue(hl7.ishl7(sample_msh))",
                    "signature": "def test_ishl7(self): self.assertTrue(hl7.ishl7(sample_hl7)) self.assertFalse(hl7.ishl7(sample_batch)) self.assertFalse(hl7.ishl7(sample_batch1)) self.assertFalse(hl7.ishl7(sample_batch2)) self.assertFalse(hl7.ishl7(sample_file)) self.assertFalse(hl7.ishl7(sample_file1)) self.assertFalse(hl7.ishl7(sample_file2)) self.assertTrue(hl7.ishl7(sample_msh))"
                }
            },
            {
                "id": 413,
                "attributes": {
                    "id": 413.0,
                    "label": "hl7.tests.test_util.IsHL7Test.test_ishl7_empty",
                    "type": "function",
                    "code": "def test_ishl7_empty(self): self.assertFalse(hl7.ishl7(&#34;&#34;))",
                    "signature": "def test_ishl7_empty(self): self.assertFalse(hl7.ishl7(&#34;&#34;))"
                }
            },
            {
                "id": 414,
                "attributes": {
                    "id": 414.0,
                    "label": "hl7.tests.test_util.IsHL7Test.test_ishl7_None",
                    "type": "function",
                    "code": "def test_ishl7_None(self): self.assertFalse(hl7.ishl7(None))",
                    "signature": "def test_ishl7_None(self): self.assertFalse(hl7.ishl7(None))"
                }
            },
            {
                "id": 415,
                "attributes": {
                    "id": 415.0,
                    "label": "hl7.tests.test_util.IsHL7Test.test_ishl7_wrongsegment",
                    "type": "function",
                    "code": "def test_ishl7_wrongsegment(self): message = &#34;OBX|1|SN|1554-5^GLUCOSE^POST 12H CFST:MCNC:PT:SER/PLAS:QN||^182|mg/dl|70_105|H|||F\\r&#34; self.assertFalse(hl7.ishl7(message))",
                    "signature": "def test_ishl7_wrongsegment(self): message = &#34;OBX|1|SN|1554-5^GLUCOSE^POST 12H CFST:MCNC:PT:SER/PLAS:QN||^182|mg/dl|70_105|H|||F\\r&#34; self.assertFalse(hl7.ishl7(message))"
                }
            },
            {
                "id": 416,
                "attributes": {
                    "id": 416.0,
                    "label": "hl7.tests.test_util.IsHL7Test.test_isbatch",
                    "type": "function",
                    "code": "def test_isbatch(self): self.assertFalse(hl7.ishl7(sample_batch)) self.assertFalse(hl7.ishl7(sample_batch1)) self.assertFalse(hl7.ishl7(sample_batch2)) self.assertTrue(hl7.isbatch(sample_batch)) self.assertTrue(hl7.isbatch(sample_batch1)) self.assertTrue(hl7.isbatch(sample_batch2))",
                    "signature": "def test_isbatch(self): self.assertFalse(hl7.ishl7(sample_batch)) self.assertFalse(hl7.ishl7(sample_batch1)) self.assertFalse(hl7.ishl7(sample_batch2)) self.assertTrue(hl7.isbatch(sample_batch)) self.assertTrue(hl7.isbatch(sample_batch1)) self.assertTrue(hl7.isbatch(sample_batch2))"
                }
            },
            {
                "id": 417,
                "attributes": {
                    "id": 417.0,
                    "label": "hl7.tests.test_util.IsHL7Test.test_isfile",
                    "type": "function",
                    "code": "def test_isfile(self): self.assertFalse(hl7.ishl7(sample_file)) self.assertFalse(hl7.ishl7(sample_file1)) self.assertFalse(hl7.ishl7(sample_file2)) self.assertFalse(hl7.isbatch(sample_file)) self.assertFalse(hl7.isbatch(sample_file1)) self.assertFalse(hl7.isbatch(sample_file2)) self.assertTrue(hl7.isfile(sample_file)) self.assertTrue(hl7.isfile(sample_file1)) self.assertTrue(hl7.isfile(sample_file2)) self.assertTrue(hl7.isfile(sample_batch)) self.assertTrue(hl7.isfile(sample_batch1)) self.assertTrue(hl7.isfile(sample_batch2))",
                    "signature": "def test_isfile(self): self.assertFalse(hl7.ishl7(sample_file)) self.assertFalse(hl7.ishl7(sample_file1)) self.assertFalse(hl7.ishl7(sample_file2)) self.assertFalse(hl7.isbatch(sample_file)) self.assertFalse(hl7.isbatch(sample_file1)) self.assertFalse(hl7.isbatch(sample_file2)) self.assertTrue(hl7.isfile(sample_file)) self.assertTrue(hl7.isfile(sample_file1)) self.assertTrue(hl7.isfile(sample_file2)) self.assertTrue(hl7.isfile(sample_batch)) self.assertTrue(hl7.isfile(sample_batch1)) self.assertTrue(hl7.isfile(sample_batch2))"
                }
            },
            {
                "id": 456,
                "attributes": {
                    "id": 456.0,
                    "label": "logging",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 457,
                "attributes": {
                    "id": 457.0,
                    "label": "random",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 458,
                "attributes": {
                    "id": 458.0,
                    "label": "string",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            }
        ]
    },
    "11": {
        "nodes": [
            {
                "id": 72,
                "attributes": {
                    "id": 72.0,
                    "label": "hl7.hl7.client.MLLPClient",
                    "type": "class",
                    "code": "class MLLPClient(object): &#34;&#34;&#34; A basic, blocking, HL7 MLLP client based upon :py:mod:`socket`.  MLLPClient implements two methods for sending data to the server.  * :py:meth:`MLLPClient.send` for raw data that already is wrapped in the appropriate MLLP container (e.g. *<SB>message<EB><CR>*). * :py:meth:`MLLPClient.send_message` will wrap the message in the MLLP container  Can be used by the ``with`` statement to ensure :py:meth:`MLLPClient.close` is called::  with MLLPClient(host, port) as client: client.send_message('MSH|...')  MLLPClient takes an optional ``encoding`` parameter, defaults to UTF-8, for encoding unicode messages [#]_.  .. [#] http://wiki.hl7.org/index.php?title=Character_Set_used_in_v2_messages &#34;&#34;&#34;  def __init__(self, host, port, encoding=&#34;utf-8&#34;): self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.socket.connect((host, port)) self.encoding = encoding  def __enter__(self): return self  def __exit__(self, exc_type, exc_val, trackeback): self.close()  def close(self): &#34;&#34;&#34;Release the socket connection&#34;&#34;&#34; self.socket.close()  def send_message(self, message): &#34;&#34;&#34;Wraps a byte string, unicode string, or :py:class:`hl7.Message` in a MLLP container and send the message to the server  If message is a byte string, we assume it is already encoded properly. If message is unicode or  :py:class:`hl7.Message`, it will be encoded according to  :py:attr:`hl7.client.MLLPClient.encoding`  &#34;&#34;&#34; if isinstance(message, bytes): # Assume we have the correct encoding binary = message else: # Encode the unicode message into a bytestring if isinstance(message, hl7.Message): message = str(message) binary = message.encode(self.encoding)  # wrap in MLLP message container data = SB + binary + EB + CR return self.send(data)  def send(self, data): &#34;&#34;&#34;Low-level, direct access to the socket.send (data must be already wrapped in an MLLP container).  Blocks until the server returns. &#34;&#34;&#34; # upload the data self.socket.send(data) # wait for the ACK/NACK return self.socket.recv(RECV_BUFFER)",
                    "signature": "class MLLPClient(object): &#34;&#34;&#34; A basic, blocking, HL7 MLLP client based upon :py:mod:`socket`.  MLLPClient implements two methods for sending data to the server.  * :py:meth:`MLLPClient.send` for raw data that already is wrapped in the appropriate MLLP container (e.g. *<SB>message<EB><CR>*). * :py:meth:`MLLPClient.send_message` will wrap the message in the MLLP container  Can be used by the ``with`` statement to ensure :py:meth:`MLLPClient.close` is called::  with MLLPClient(host, port) as client: client.send_message('MSH|...')  MLLPClient takes an optional ``encoding`` parameter, defaults to UTF-8, for encoding unicode messages [#]_.  .. [#] http://wiki.hl7.org/index.php?title=Character_Set_used_in_v2_messages &#34;&#34;&#34;  def __init__(self, host, port, encoding=&#34;utf-8&#34;): self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.socket.connect((host, port)) self.encoding = encoding  def __enter__(self): return self  def __exit__(self, exc_type, exc_val, trackeback): self.close()  def close(self): &#34;&#34;&#34;Release the socket connection&#34;&#34;&#34; self.socket.close()  def send_message(self, message): &#34;&#34;&#34;Wraps a byte string, unicode string, or :py:class:`hl7.Message` in a MLLP container and send the message to the server  If message is a byte string, we assume it is already encoded properly. If message is unicode or  :py:class:`hl7.Message`, it will be encoded according to  :py:attr:`hl7.client.MLLPClient.encoding`  &#34;&#34;&#34; if isinstance(message, bytes): # Assume we have the correct encoding binary = message else: # Encode the unicode message into a bytestring if isinstance(message, hl7.Message): message = str(message) binary = message.encode(self.encoding)  # wrap in MLLP message container data = SB + binary + EB + CR return self.send(data)  def send(self, data): &#34;&#34;&#34;Low-level, direct access to the socket.send (data must be already wrapped in an MLLP container).  Blocks until the server returns. &#34;&#34;&#34; # upload the data self.socket.send(data) # wait for the ACK/NACK return self.socket.recv(RECV_BUFFER)"
                }
            },
            {
                "id": 73,
                "attributes": {
                    "id": 73.0,
                    "label": "hl7.hl7.client.MLLPClient.__init__",
                    "type": "function",
                    "code": "def __init__(self, host, port, encoding=&#34;utf-8&#34;): self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.socket.connect((host, port)) self.encoding = encoding",
                    "signature": "def __init__(self, host, port, encoding=&#34;utf-8&#34;): self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.socket.connect((host, port)) self.encoding = encoding"
                }
            },
            {
                "id": 74,
                "attributes": {
                    "id": 74.0,
                    "label": "hl7.hl7.client.MLLPClient.__enter__",
                    "type": "function",
                    "code": "def __enter__(self): return self",
                    "signature": "def __enter__(self): return self"
                }
            },
            {
                "id": 75,
                "attributes": {
                    "id": 75.0,
                    "label": "hl7.hl7.client.MLLPClient.__exit__",
                    "type": "function",
                    "code": "def __exit__(self, exc_type, exc_val, trackeback): self.close()",
                    "signature": "def __exit__(self, exc_type, exc_val, trackeback): self.close()"
                }
            },
            {
                "id": 76,
                "attributes": {
                    "id": 76.0,
                    "label": "hl7.hl7.client.MLLPClient.close",
                    "type": "function",
                    "code": "def close(self): &#34;&#34;&#34;Release the socket connection&#34;&#34;&#34; self.socket.close()",
                    "signature": "def close(self): &#34;&#34;&#34;Release the socket connection&#34;&#34;&#34; self.socket.close()"
                }
            },
            {
                "id": 77,
                "attributes": {
                    "id": 77.0,
                    "label": "hl7.hl7.client.MLLPClient.send_message",
                    "type": "function",
                    "code": "def send_message(self, message): &#34;&#34;&#34;Wraps a byte string, unicode string, or :py:class:`hl7.Message` in a MLLP container and send the message to the server  If message is a byte string, we assume it is already encoded properly. If message is unicode or  :py:class:`hl7.Message`, it will be encoded according to  :py:attr:`hl7.client.MLLPClient.encoding`  &#34;&#34;&#34; if isinstance(message, bytes): # Assume we have the correct encoding binary = message else: # Encode the unicode message into a bytestring if isinstance(message, hl7.Message): message = str(message) binary = message.encode(self.encoding)  # wrap in MLLP message container data = SB + binary + EB + CR return self.send(data)",
                    "signature": "def send_message(self, message): &#34;&#34;&#34;Wraps a byte string, unicode string, or :py:class:`hl7.Message` in a MLLP container and send the message to the server  If message is a byte string, we assume it is already encoded properly. If message is unicode or  :py:class:`hl7.Message`, it will be encoded according to  :py:attr:`hl7.client.MLLPClient.encoding`  &#34;&#34;&#34; if isinstance(message, bytes): # Assume we have the correct encoding binary = message else: # Encode the unicode message into a bytestring if isinstance(message, hl7.Message): message = str(message) binary = message.encode(self.encoding)  # wrap in MLLP message container data = SB + binary + EB + CR return self.send(data)"
                }
            },
            {
                "id": 78,
                "attributes": {
                    "id": 78.0,
                    "label": "hl7.hl7.client.MLLPClient.send",
                    "type": "function",
                    "code": "def send(self, data): &#34;&#34;&#34;Low-level, direct access to the socket.send (data must be already wrapped in an MLLP container).  Blocks until the server returns. &#34;&#34;&#34; # upload the data self.socket.send(data) # wait for the ACK/NACK return self.socket.recv(RECV_BUFFER)",
                    "signature": "def send(self, data): &#34;&#34;&#34;Low-level, direct access to the socket.send (data must be already wrapped in an MLLP container).  Blocks until the server returns. &#34;&#34;&#34; # upload the data self.socket.send(data) # wait for the ACK/NACK return self.socket.recv(RECV_BUFFER)"
                }
            },
            {
                "id": 305,
                "attributes": {
                    "id": 305.0,
                    "label": "hl7.tests.test_client.MLLPClientTest",
                    "type": "class",
                    "code": "class MLLPClientTest(TestCase): def setUp(self): # use a mock version of socket self.socket_patch = patch(&#34;hl7.client.socket.socket&#34;) self.mock_socket = self.socket_patch.start()  self.client = MLLPClient(&#34;localhost&#34;, 6666)  def tearDown(self): # unpatch socket self.socket_patch.stop()  def test_connect(self): self.mock_socket.assert_called_once_with(socket.AF_INET, socket.SOCK_STREAM) self.client.socket.connect.assert_called_once_with((&#34;localhost&#34;, 6666))  def test_close(self): self.client.close() self.client.socket.close.assert_called_once_with()  def test_send(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send(&#34;foobar\\n&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(&#34;foobar\\n&#34;) self.client.socket.recv.assert_called_once_with(4096)  def test_send_message_unicode(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send_message(&#34;foobar&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(b&#34;\\x0bfoobar\\x1c\\x0d&#34;)  def test_send_message_bytestring(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send_message(b&#34;foobar&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(b&#34;\\x0bfoobar\\x1c\\x0d&#34;)  def test_send_message_hl7_message(self): self.client.socket.recv.return_value = &#34;thanks&#34;  message = hl7.parse(r&#34;MSH|^~\\&#38;|GHH LAB|ELAB&#34;)  result = self.client.send_message(message) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with( b&#34;\\x0bMSH|^~\\\\&#38;|GHH LAB|ELAB\\r\\x1c\\x0d&#34; )  def test_context_manager(self): with MLLPClient(&#34;localhost&#34;, 6666) as client: client.send(&#34;hello world&#34;)  self.client.socket.send.assert_called_once_with(&#34;hello world&#34;) self.client.socket.close.assert_called_once_with()  def test_context_manager_exception(self): with self.assertRaises(Exception): with MLLPClient(&#34;localhost&#34;, 6666): raise Exception()  # socket.close should be called via the with statement self.client.socket.close.assert_called_once_with()",
                    "signature": "class MLLPClientTest(TestCase): def setUp(self): # use a mock version of socket self.socket_patch = patch(&#34;hl7.client.socket.socket&#34;) self.mock_socket = self.socket_patch.start()  self.client = MLLPClient(&#34;localhost&#34;, 6666)  def tearDown(self): # unpatch socket self.socket_patch.stop()  def test_connect(self): self.mock_socket.assert_called_once_with(socket.AF_INET, socket.SOCK_STREAM) self.client.socket.connect.assert_called_once_with((&#34;localhost&#34;, 6666))  def test_close(self): self.client.close() self.client.socket.close.assert_called_once_with()  def test_send(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send(&#34;foobar\\n&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(&#34;foobar\\n&#34;) self.client.socket.recv.assert_called_once_with(4096)  def test_send_message_unicode(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send_message(&#34;foobar&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(b&#34;\\x0bfoobar\\x1c\\x0d&#34;)  def test_send_message_bytestring(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send_message(b&#34;foobar&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(b&#34;\\x0bfoobar\\x1c\\x0d&#34;)  def test_send_message_hl7_message(self): self.client.socket.recv.return_value = &#34;thanks&#34;  message = hl7.parse(r&#34;MSH|^~\\&#38;|GHH LAB|ELAB&#34;)  result = self.client.send_message(message) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with( b&#34;\\x0bMSH|^~\\\\&#38;|GHH LAB|ELAB\\r\\x1c\\x0d&#34; )  def test_context_manager(self): with MLLPClient(&#34;localhost&#34;, 6666) as client: client.send(&#34;hello world&#34;)  self.client.socket.send.assert_called_once_with(&#34;hello world&#34;) self.client.socket.close.assert_called_once_with()  def test_context_manager_exception(self): with self.assertRaises(Exception): with MLLPClient(&#34;localhost&#34;, 6666): raise Exception()  # socket.close should be called via the with statement self.client.socket.close.assert_called_once_with()"
                }
            },
            {
                "id": 306,
                "attributes": {
                    "id": 306.0,
                    "label": "hl7.tests.test_client.MLLPClientTest.setUp",
                    "type": "function",
                    "code": "def setUp(self): # use a mock version of socket self.socket_patch = patch(&#34;hl7.client.socket.socket&#34;) self.mock_socket = self.socket_patch.start()  self.client = MLLPClient(&#34;localhost&#34;, 6666)",
                    "signature": "def setUp(self): # use a mock version of socket self.socket_patch = patch(&#34;hl7.client.socket.socket&#34;) self.mock_socket = self.socket_patch.start()  self.client = MLLPClient(&#34;localhost&#34;, 6666)"
                }
            },
            {
                "id": 307,
                "attributes": {
                    "id": 307.0,
                    "label": "hl7.tests.test_client.MLLPClientTest.tearDown",
                    "type": "function",
                    "code": "def tearDown(self): # unpatch socket self.socket_patch.stop()",
                    "signature": "def tearDown(self): # unpatch socket self.socket_patch.stop()"
                }
            },
            {
                "id": 308,
                "attributes": {
                    "id": 308.0,
                    "label": "hl7.tests.test_client.MLLPClientTest.test_connect",
                    "type": "function",
                    "code": "def test_connect(self): self.mock_socket.assert_called_once_with(socket.AF_INET, socket.SOCK_STREAM) self.client.socket.connect.assert_called_once_with((&#34;localhost&#34;, 6666))",
                    "signature": "def test_connect(self): self.mock_socket.assert_called_once_with(socket.AF_INET, socket.SOCK_STREAM) self.client.socket.connect.assert_called_once_with((&#34;localhost&#34;, 6666))"
                }
            },
            {
                "id": 309,
                "attributes": {
                    "id": 309.0,
                    "label": "hl7.tests.test_client.MLLPClientTest.test_close",
                    "type": "function",
                    "code": "def test_close(self): self.client.close() self.client.socket.close.assert_called_once_with()",
                    "signature": "def test_close(self): self.client.close() self.client.socket.close.assert_called_once_with()"
                }
            },
            {
                "id": 310,
                "attributes": {
                    "id": 310.0,
                    "label": "hl7.tests.test_client.MLLPClientTest.test_send",
                    "type": "function",
                    "code": "def test_send(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send(&#34;foobar\\n&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(&#34;foobar\\n&#34;) self.client.socket.recv.assert_called_once_with(4096)",
                    "signature": "def test_send(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send(&#34;foobar\\n&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(&#34;foobar\\n&#34;) self.client.socket.recv.assert_called_once_with(4096)"
                }
            },
            {
                "id": 311,
                "attributes": {
                    "id": 311.0,
                    "label": "hl7.tests.test_client.MLLPClientTest.test_send_message_unicode",
                    "type": "function",
                    "code": "def test_send_message_unicode(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send_message(&#34;foobar&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(b&#34;\\x0bfoobar\\x1c\\x0d&#34;)",
                    "signature": "def test_send_message_unicode(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send_message(&#34;foobar&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(b&#34;\\x0bfoobar\\x1c\\x0d&#34;)"
                }
            },
            {
                "id": 312,
                "attributes": {
                    "id": 312.0,
                    "label": "hl7.tests.test_client.MLLPClientTest.test_send_message_bytestring",
                    "type": "function",
                    "code": "def test_send_message_bytestring(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send_message(b&#34;foobar&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(b&#34;\\x0bfoobar\\x1c\\x0d&#34;)",
                    "signature": "def test_send_message_bytestring(self): self.client.socket.recv.return_value = &#34;thanks&#34;  result = self.client.send_message(b&#34;foobar&#34;) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with(b&#34;\\x0bfoobar\\x1c\\x0d&#34;)"
                }
            },
            {
                "id": 313,
                "attributes": {
                    "id": 313.0,
                    "label": "hl7.tests.test_client.MLLPClientTest.test_send_message_hl7_message",
                    "type": "function",
                    "code": "def test_send_message_hl7_message(self): self.client.socket.recv.return_value = &#34;thanks&#34;  message = hl7.parse(r&#34;MSH|^~\\&#38;|GHH LAB|ELAB&#34;)  result = self.client.send_message(message) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with( b&#34;\\x0bMSH|^~\\\\&#38;|GHH LAB|ELAB\\r\\x1c\\x0d&#34; )",
                    "signature": "def test_send_message_hl7_message(self): self.client.socket.recv.return_value = &#34;thanks&#34;  message = hl7.parse(r&#34;MSH|^~\\&#38;|GHH LAB|ELAB&#34;)  result = self.client.send_message(message) self.assertEqual(result, &#34;thanks&#34;)  self.client.socket.send.assert_called_once_with( b&#34;\\x0bMSH|^~\\\\&#38;|GHH LAB|ELAB\\r\\x1c\\x0d&#34; )"
                }
            },
            {
                "id": 314,
                "attributes": {
                    "id": 314.0,
                    "label": "hl7.tests.test_client.MLLPClientTest.test_context_manager",
                    "type": "function",
                    "code": "def test_context_manager(self): with MLLPClient(&#34;localhost&#34;, 6666) as client: client.send(&#34;hello world&#34;)  self.client.socket.send.assert_called_once_with(&#34;hello world&#34;) self.client.socket.close.assert_called_once_with()",
                    "signature": "def test_context_manager(self): with MLLPClient(&#34;localhost&#34;, 6666) as client: client.send(&#34;hello world&#34;)  self.client.socket.send.assert_called_once_with(&#34;hello world&#34;) self.client.socket.close.assert_called_once_with()"
                }
            },
            {
                "id": 315,
                "attributes": {
                    "id": 315.0,
                    "label": "hl7.tests.test_client.MLLPClientTest.test_context_manager_exception",
                    "type": "function",
                    "code": "def test_context_manager_exception(self): with self.assertRaises(Exception): with MLLPClient(&#34;localhost&#34;, 6666): raise Exception()  # socket.close should be called via the with statement self.client.socket.close.assert_called_once_with()",
                    "signature": "def test_context_manager_exception(self): with self.assertRaises(Exception): with MLLPClient(&#34;localhost&#34;, 6666): raise Exception()  # socket.close should be called via the with statement self.client.socket.close.assert_called_once_with()"
                }
            }
        ]
    },
    "12": {
        "nodes": [
            {
                "id": 62,
                "attributes": {
                    "id": 62.0,
                    "label": "hl7.hl7.datatypes",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 63,
                "attributes": {
                    "id": 63.0,
                    "label": "hl7.hl7.datatypes._UTCOffset",
                    "type": "class",
                    "code": "class _UTCOffset(datetime.tzinfo): &#34;&#34;&#34;Fixed offset timezone from UTC.&#34;&#34;&#34;  def __init__(self, minutes): &#34;&#34;&#34;``minutes`` is a offset from UTC, negative for west of UTC&#34;&#34;&#34; self.minutes = minutes  def utcoffset(self, dt): return datetime.timedelta(minutes=self.minutes)  def tzname(self, dt): minutes = abs(self.minutes) return &#34;{0}{1:02}{2:02}&#34;.format( &#34;-&#34; if self.minutes < 0 else &#34;+&#34;, minutes // 60, minutes % 60 )  def dst(self, dt): return datetime.timedelta(0)",
                    "signature": "class _UTCOffset(datetime.tzinfo): &#34;&#34;&#34;Fixed offset timezone from UTC.&#34;&#34;&#34;  def __init__(self, minutes): &#34;&#34;&#34;``minutes`` is a offset from UTC, negative for west of UTC&#34;&#34;&#34; self.minutes = minutes  def utcoffset(self, dt): return datetime.timedelta(minutes=self.minutes)  def tzname(self, dt): minutes = abs(self.minutes) return &#34;{0}{1:02}{2:02}&#34;.format( &#34;-&#34; if self.minutes < 0 else &#34;+&#34;, minutes // 60, minutes % 60 )  def dst(self, dt): return datetime.timedelta(0)"
                }
            },
            {
                "id": 64,
                "attributes": {
                    "id": 64.0,
                    "label": "hl7.hl7.datatypes._UTCOffset.__init__",
                    "type": "function",
                    "code": "def __init__(self, minutes): &#34;&#34;&#34;``minutes`` is a offset from UTC, negative for west of UTC&#34;&#34;&#34; self.minutes = minutes",
                    "signature": "def __init__(self, minutes): &#34;&#34;&#34;``minutes`` is a offset from UTC, negative for west of UTC&#34;&#34;&#34; self.minutes = minutes"
                }
            },
            {
                "id": 65,
                "attributes": {
                    "id": 65.0,
                    "label": "hl7.hl7.datatypes._UTCOffset.utcoffset",
                    "type": "function",
                    "code": "def utcoffset(self, dt): return datetime.timedelta(minutes=self.minutes)",
                    "signature": "def utcoffset(self, dt): return datetime.timedelta(minutes=self.minutes)"
                }
            },
            {
                "id": 66,
                "attributes": {
                    "id": 66.0,
                    "label": "hl7.hl7.datatypes._UTCOffset.tzname",
                    "type": "function",
                    "code": "def tzname(self, dt): minutes = abs(self.minutes) return &#34;{0}{1:02}{2:02}&#34;.format( &#34;-&#34; if self.minutes < 0 else &#34;+&#34;, minutes // 60, minutes % 60 )",
                    "signature": "def tzname(self, dt): minutes = abs(self.minutes) return &#34;{0}{1:02}{2:02}&#34;.format( &#34;-&#34; if self.minutes < 0 else &#34;+&#34;, minutes // 60, minutes % 60 )"
                }
            },
            {
                "id": 67,
                "attributes": {
                    "id": 67.0,
                    "label": "hl7.hl7.datatypes._UTCOffset.dst",
                    "type": "function",
                    "code": "def dst(self, dt): return datetime.timedelta(0)",
                    "signature": "def dst(self, dt): return datetime.timedelta(0)"
                }
            },
            {
                "id": 68,
                "attributes": {
                    "id": 68.0,
                    "label": "hl7.hl7.datatypes.parse_datetime",
                    "type": "function",
                    "code": "def parse_datetime(value): &#34;&#34;&#34;Parse hl7 DTM string ``value`` :py:class:`datetime.datetime`.  ``value`` is of the format YYYY[MM[DD[HH[MM[SS[.S[S[S[S]]]]]]]]][+/-HHMM] or a ValueError will be raised.  :rtype: :py:;class:`datetime.datetime` &#34;&#34;&#34; if not value: return None  # Split off optional timezone dt_match = DTM_TZ_RE.match(value) if not dt_match: raise ValueError(&#34;Malformed HL7 datetime {0}&#34;.format(value)) dtm = dt_match.group(1) tzh = dt_match.group(2) tzm = dt_match.group(3) if tzh and tzm: minutes = int(tzh) * 60 minutes += math.copysign(int(tzm), minutes) tzinfo = _UTCOffset(minutes) else: tzinfo = None  precision = len(dtm)  if precision >= 4: year = int(dtm[0:4]) else: raise ValueError(&#34;Malformed HL7 datetime {0}&#34;.format(value))  if precision >= 6: month = int(dtm[4:6]) else: month = 1  if precision >= 8: day = int(dtm[6:8]) else: day = 1  if precision >= 10: hour = int(dtm[8:10]) else: hour = 0  if precision >= 12: minute = int(dtm[10:12]) else: minute = 0  if precision >= 14: delta = datetime.timedelta(seconds=float(dtm[12:])) second = delta.seconds microsecond = delta.microseconds else: second = 0 microsecond = 0  return datetime.datetime( year, month, day, hour, minute, second, microsecond, tzinfo=tzinfo )",
                    "signature": "def parse_datetime(value): &#34;&#34;&#34;Parse hl7 DTM string ``value`` :py:class:`datetime.datetime`.  ``value`` is of the format YYYY[MM[DD[HH[MM[SS[.S[S[S[S]]]]]]]]][+/-HHMM] or a ValueError will be raised.  :rtype: :py:;class:`datetime.datetime` &#34;&#34;&#34; if not value: return None  # Split off optional timezone dt_match = DTM_TZ_RE.match(value) if not dt_match: raise ValueError(&#34;Malformed HL7 datetime {0}&#34;.format(value)) dtm = dt_match.group(1) tzh = dt_match.group(2) tzm = dt_match.group(3) if tzh and tzm: minutes = int(tzh) * 60 minutes += math.copysign(int(tzm), minutes) tzinfo = _UTCOffset(minutes) else: tzinfo = None  precision = len(dtm)  if precision >= 4: year = int(dtm[0:4]) else: raise ValueError(&#34;Malformed HL7 datetime {0}&#34;.format(value))  if precision >= 6: month = int(dtm[4:6]) else: month = 1  if precision >= 8: day = int(dtm[6:8]) else: day = 1  if precision >= 10: hour = int(dtm[8:10]) else: hour = 0  if precision >= 12: minute = int(dtm[10:12]) else: minute = 0  if precision >= 14: delta = datetime.timedelta(seconds=float(dtm[12:])) second = delta.seconds microsecond = delta.microseconds else: second = 0 microsecond = 0  return datetime.datetime( year, month, day, hour, minute, second, microsecond, tzinfo=tzinfo )"
                }
            },
            {
                "id": 403,
                "attributes": {
                    "id": 403.0,
                    "label": "hl7.tests.test_datetime",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 404,
                "attributes": {
                    "id": 404.0,
                    "label": "hl7.tests.test_datetime.DatetimeTest",
                    "type": "class",
                    "code": "class DatetimeTest(TestCase): def test_parse_date(self): self.assertEqual(datetime(1901, 2, 13), parse_datetime(&#34;19010213&#34;))  def test_parse_datetime(self): self.assertEqual( datetime(2014, 3, 11, 14, 25, 33), parse_datetime(&#34;20140311142533&#34;) )  def test_parse_datetime_frac(self): self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 100000), parse_datetime(&#34;20140311142533.1&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 10000), parse_datetime(&#34;20140311142533.01&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 1000), parse_datetime(&#34;20140311142533.001&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 100), parse_datetime(&#34;20140311142533.0001&#34;), )  def test_parse_tz(self): self.assertEqual( datetime(2014, 3, 11, 14, 12, tzinfo=_UTCOffset(330)), parse_datetime(&#34;201403111412+0530&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 12, 20, tzinfo=_UTCOffset(-300)), parse_datetime(&#34;20140311141220-0500&#34;), )  def test_tz(self): self.assertEqual(&#34;+0205&#34;, _UTCOffset(125).tzname(datetime.utcnow())) self.assertEqual(&#34;-0410&#34;, _UTCOffset(-250).tzname(datetime.utcnow()))",
                    "signature": "class DatetimeTest(TestCase): def test_parse_date(self): self.assertEqual(datetime(1901, 2, 13), parse_datetime(&#34;19010213&#34;))  def test_parse_datetime(self): self.assertEqual( datetime(2014, 3, 11, 14, 25, 33), parse_datetime(&#34;20140311142533&#34;) )  def test_parse_datetime_frac(self): self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 100000), parse_datetime(&#34;20140311142533.1&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 10000), parse_datetime(&#34;20140311142533.01&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 1000), parse_datetime(&#34;20140311142533.001&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 100), parse_datetime(&#34;20140311142533.0001&#34;), )  def test_parse_tz(self): self.assertEqual( datetime(2014, 3, 11, 14, 12, tzinfo=_UTCOffset(330)), parse_datetime(&#34;201403111412+0530&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 12, 20, tzinfo=_UTCOffset(-300)), parse_datetime(&#34;20140311141220-0500&#34;), )  def test_tz(self): self.assertEqual(&#34;+0205&#34;, _UTCOffset(125).tzname(datetime.utcnow())) self.assertEqual(&#34;-0410&#34;, _UTCOffset(-250).tzname(datetime.utcnow()))"
                }
            },
            {
                "id": 405,
                "attributes": {
                    "id": 405.0,
                    "label": "hl7.tests.test_datetime.DatetimeTest.test_parse_date",
                    "type": "function",
                    "code": "def test_parse_date(self): self.assertEqual(datetime(1901, 2, 13), parse_datetime(&#34;19010213&#34;))",
                    "signature": "def test_parse_date(self): self.assertEqual(datetime(1901, 2, 13), parse_datetime(&#34;19010213&#34;))"
                }
            },
            {
                "id": 406,
                "attributes": {
                    "id": 406.0,
                    "label": "hl7.tests.test_datetime.DatetimeTest.test_parse_datetime",
                    "type": "function",
                    "code": "def test_parse_datetime(self): self.assertEqual( datetime(2014, 3, 11, 14, 25, 33), parse_datetime(&#34;20140311142533&#34;) )",
                    "signature": "def test_parse_datetime(self): self.assertEqual( datetime(2014, 3, 11, 14, 25, 33), parse_datetime(&#34;20140311142533&#34;) )"
                }
            },
            {
                "id": 407,
                "attributes": {
                    "id": 407.0,
                    "label": "hl7.tests.test_datetime.DatetimeTest.test_parse_datetime_frac",
                    "type": "function",
                    "code": "def test_parse_datetime_frac(self): self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 100000), parse_datetime(&#34;20140311142533.1&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 10000), parse_datetime(&#34;20140311142533.01&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 1000), parse_datetime(&#34;20140311142533.001&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 100), parse_datetime(&#34;20140311142533.0001&#34;), )",
                    "signature": "def test_parse_datetime_frac(self): self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 100000), parse_datetime(&#34;20140311142533.1&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 10000), parse_datetime(&#34;20140311142533.01&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 1000), parse_datetime(&#34;20140311142533.001&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 25, 33, 100), parse_datetime(&#34;20140311142533.0001&#34;), )"
                }
            },
            {
                "id": 408,
                "attributes": {
                    "id": 408.0,
                    "label": "hl7.tests.test_datetime.DatetimeTest.test_parse_tz",
                    "type": "function",
                    "code": "def test_parse_tz(self): self.assertEqual( datetime(2014, 3, 11, 14, 12, tzinfo=_UTCOffset(330)), parse_datetime(&#34;201403111412+0530&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 12, 20, tzinfo=_UTCOffset(-300)), parse_datetime(&#34;20140311141220-0500&#34;), )",
                    "signature": "def test_parse_tz(self): self.assertEqual( datetime(2014, 3, 11, 14, 12, tzinfo=_UTCOffset(330)), parse_datetime(&#34;201403111412+0530&#34;), ) self.assertEqual( datetime(2014, 3, 11, 14, 12, 20, tzinfo=_UTCOffset(-300)), parse_datetime(&#34;20140311141220-0500&#34;), )"
                }
            },
            {
                "id": 409,
                "attributes": {
                    "id": 409.0,
                    "label": "hl7.tests.test_datetime.DatetimeTest.test_tz",
                    "type": "function",
                    "code": "def test_tz(self): self.assertEqual(&#34;+0205&#34;, _UTCOffset(125).tzname(datetime.utcnow())) self.assertEqual(&#34;-0410&#34;, _UTCOffset(-250).tzname(datetime.utcnow()))",
                    "signature": "def test_tz(self): self.assertEqual(&#34;+0205&#34;, _UTCOffset(125).tzname(datetime.utcnow())) self.assertEqual(&#34;-0410&#34;, _UTCOffset(-250).tzname(datetime.utcnow()))"
                }
            },
            {
                "id": 455,
                "attributes": {
                    "id": 455.0,
                    "label": "datetime",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 459,
                "attributes": {
                    "id": 459.0,
                    "label": "math",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 460,
                "attributes": {
                    "id": 460.0,
                    "label": "re",
                    "type": "local_module",
                    "code": "None",
                    "signature": "None"
                }
            }
        ]
    },
    "13": {
        "nodes": [
            {
                "id": 193,
                "attributes": {
                    "id": 193.0,
                    "label": "hl7.tests.backports.unittest.case.TestCase.addCleanup",
                    "type": "function",
                    "code": "def addCleanup(*args, **kwargs): &#34;&#34;&#34;Add a function, with arguments, to be called when the test is completed. Functions added are called on a LIFO basis and are called after tearDown on test failure or success.  Cleanup items are called even if setUp fails (unlike tearDown).&#34;&#34;&#34; if len(args) >= 2: self, function, *args = args elif not args: raise TypeError( &#34;descriptor 'addCleanup' of 'TestCase' object &#34; &#34;needs an argument&#34; ) elif &#34;function&#34; in kwargs: function = kwargs.pop(&#34;function&#34;) self, *args = args import warnings  warnings.warn( &#34;Passing 'function' as keyword argument is deprecated&#34;, DeprecationWarning, stacklevel=2, ) else: raise TypeError( &#34;addCleanup expected at least 1 positional &#34; &#34;argument, got %d&#34; % (len(args) - 1) ) args = tuple(args)  self._cleanups.append((function, args, kwargs))",
                    "signature": "def addCleanup(*args, **kwargs): &#34;&#34;&#34;Add a function, with arguments, to be called when the test is completed. Functions added are called on a LIFO basis and are called after tearDown on test failure or success.  Cleanup items are called even if setUp fails (unlike tearDown).&#34;&#34;&#34; if len(args) >= 2: self, function, *args = args elif not args: raise TypeError( &#34;descriptor 'addCleanup' of 'TestCase' object &#34; &#34;needs an argument&#34; ) elif &#34;function&#34; in kwargs: function = kwargs.pop(&#34;function&#34;) self, *args = args import warnings  warnings.warn( &#34;Passing 'function' as keyword argument is deprecated&#34;, DeprecationWarning, stacklevel=2, ) else: raise TypeError( &#34;addCleanup expected at least 1 positional &#34; &#34;argument, got %d&#34; % (len(args) - 1) ) args = tuple(args)  self._cleanups.append((function, args, kwargs))"
                }
            },
            {
                "id": 281,
                "attributes": {
                    "id": 281.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase",
                    "type": "class",
                    "code": "class IsolatedAsyncioTestCase(TestCase): # Names intentionally have a long prefix # to reduce a chance of clashing with user-defined attributes # from inherited test case # # The class doesn't call loop.run_until_complete(self.setUp()) and family # but uses a different approach: # 1. create a long-running task that reads self.setUp() #    awaitable from queue along with a future # 2. await the awaitable object passing in and set the result #    into the future object # 3. Outer code puts the awaitable and the future object into a queue #    with waiting for the future # The trick is necessary because every run_until_complete() call # creates a new task with embedded ContextVar context. # To share contextvars between setUp(), test and tearDown() we need to execute # them inside the same task.  # Note: the test case modifies event loop policy if the policy was not instantiated # yet. # asyncio.get_event_loop_policy() creates a default policy on demand but never # returns None # I believe this is not an issue in user level tests but python itself for testing # should reset a policy in every test module # by calling asyncio.set_event_loop_policy(None) in tearDownModule()  def __init__(self, methodName=&#34;runTest&#34;): super().__init__(methodName) self._asyncioTestLoop = None self._asyncioCallsQueue = None  async def asyncSetUp(self): pass  async def asyncTearDown(self): pass  def addAsyncCleanup(self, func, *args, **kwargs): # A trivial trampoline to addCleanup() # the function exists because it has a different semantics # and signature: # addCleanup() accepts regular functions # but addAsyncCleanup() accepts coroutines # # We intentionally don't add inspect.iscoroutinefunction() check # for func argument because there is no way # to check for async function reliably: # 1. It can be &#34;async def func()&#34; itself # 2. Class can implement &#34;async def __call__()&#34; method # 3. Regular &#34;def func()&#34; that returns awaitable object self.addCleanup(*(func, *args), **kwargs)  def _callSetUp(self): self.setUp() self._callAsync(self.asyncSetUp)  def _callTestMethod(self, method): self._callMaybeAsync(method)  def _callTearDown(self): self._callAsync(self.asyncTearDown) self.tearDown()  def _callCleanup(self, function, *args, **kwargs): self._callMaybeAsync(function, *args, **kwargs)  def _callAsync(self, func, *args, **kwargs): assert self._asyncioTestLoop is not None ret = func(*args, **kwargs) assert inspect.isawaitable(ret) fut = self._asyncioTestLoop.create_future() self._asyncioCallsQueue.put_nowait((fut, ret)) return self._asyncioTestLoop.run_until_complete(fut)  def _callMaybeAsync(self, func, *args, **kwargs): assert self._asyncioTestLoop is not None ret = func(*args, **kwargs) if inspect.isawaitable(ret): fut = self._asyncioTestLoop.create_future() self._asyncioCallsQueue.put_nowait((fut, ret)) return self._asyncioTestLoop.run_until_complete(fut) else: return ret  async def _asyncioLoopRunner(self, fut): self._asyncioCallsQueue = queue = asyncio.Queue() fut.set_result(None) while True: query = await queue.get() queue.task_done() if query is None: return fut, awaitable = query try: ret = await awaitable if not fut.cancelled(): fut.set_result(ret) except asyncio.CancelledError: raise except Exception as ex: if not fut.cancelled(): fut.set_exception(ex)  def _setupAsyncioLoop(self): assert self._asyncioTestLoop is None loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) loop.set_debug(True) self._asyncioTestLoop = loop fut = loop.create_future() self._asyncioCallsTask = loop.create_task(self._asyncioLoopRunner(fut)) loop.run_until_complete(fut)  def _tearDownAsyncioLoop(self): assert self._asyncioTestLoop is not None loop = self._asyncioTestLoop self._asyncioTestLoop = None self._asyncioCallsQueue.put_nowait(None) loop.run_until_complete(self._asyncioCallsQueue.join())  try: # cancel all tasks to_cancel = all_tasks(loop) if not to_cancel: return  for task in to_cancel: task.cancel()  loop.run_until_complete( asyncio.gather(*to_cancel, loop=loop, return_exceptions=True) )  for task in to_cancel: if task.cancelled(): continue if task.exception() is not None: loop.call_exception_handler( { &#34;message&#34;: &#34;unhandled exception during test shutdown&#34;, &#34;exception&#34;: task.exception(), &#34;task&#34;: task, } ) # shutdown asyncgens loop.run_until_complete(loop.shutdown_asyncgens()) finally: asyncio.set_event_loop(None) loop.close()  def run(self, result=None): self._setupAsyncioLoop() try: return super().run(result) finally: self._tearDownAsyncioLoop()",
                    "signature": "class IsolatedAsyncioTestCase(TestCase): # Names intentionally have a long prefix # to reduce a chance of clashing with user-defined attributes # from inherited test case # # The class doesn't call loop.run_until_complete(self.setUp()) and family # but uses a different approach: # 1. create a long-running task that reads self.setUp() #    awaitable from queue along with a future # 2. await the awaitable object passing in and set the result #    into the future object # 3. Outer code puts the awaitable and the future object into a queue #    with waiting for the future # The trick is necessary because every run_until_complete() call # creates a new task with embedded ContextVar context. # To share contextvars between setUp(), test and tearDown() we need to execute # them inside the same task.  # Note: the test case modifies event loop policy if the policy was not instantiated # yet. # asyncio.get_event_loop_policy() creates a default policy on demand but never # returns None # I believe this is not an issue in user level tests but python itself for testing # should reset a policy in every test module # by calling asyncio.set_event_loop_policy(None) in tearDownModule()  def __init__(self, methodName=&#34;runTest&#34;): super().__init__(methodName) self._asyncioTestLoop = None self._asyncioCallsQueue = None  async def asyncSetUp(self): pass  async def asyncTearDown(self): pass  def addAsyncCleanup(self, func, *args, **kwargs): # A trivial trampoline to addCleanup() # the function exists because it has a different semantics # and signature: # addCleanup() accepts regular functions # but addAsyncCleanup() accepts coroutines # # We intentionally don't add inspect.iscoroutinefunction() check # for func argument because there is no way # to check for async function reliably: # 1. It can be &#34;async def func()&#34; itself # 2. Class can implement &#34;async def __call__()&#34; method # 3. Regular &#34;def func()&#34; that returns awaitable object self.addCleanup(*(func, *args), **kwargs)  def _callSetUp(self): self.setUp() self._callAsync(self.asyncSetUp)  def _callTestMethod(self, method): self._callMaybeAsync(method)  def _callTearDown(self): self._callAsync(self.asyncTearDown) self.tearDown()  def _callCleanup(self, function, *args, **kwargs): self._callMaybeAsync(function, *args, **kwargs)  def _callAsync(self, func, *args, **kwargs): assert self._asyncioTestLoop is not None ret = func(*args, **kwargs) assert inspect.isawaitable(ret) fut = self._asyncioTestLoop.create_future() self._asyncioCallsQueue.put_nowait((fut, ret)) return self._asyncioTestLoop.run_until_complete(fut)  def _callMaybeAsync(self, func, *args, **kwargs): assert self._asyncioTestLoop is not None ret = func(*args, **kwargs) if inspect.isawaitable(ret): fut = self._asyncioTestLoop.create_future() self._asyncioCallsQueue.put_nowait((fut, ret)) return self._asyncioTestLoop.run_until_complete(fut) else: return ret  async def _asyncioLoopRunner(self, fut): self._asyncioCallsQueue = queue = asyncio.Queue() fut.set_result(None) while True: query = await queue.get() queue.task_done() if query is None: return fut, awaitable = query try: ret = await awaitable if not fut.cancelled(): fut.set_result(ret) except asyncio.CancelledError: raise except Exception as ex: if not fut.cancelled(): fut.set_exception(ex)  def _setupAsyncioLoop(self): assert self._asyncioTestLoop is None loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) loop.set_debug(True) self._asyncioTestLoop = loop fut = loop.create_future() self._asyncioCallsTask = loop.create_task(self._asyncioLoopRunner(fut)) loop.run_until_complete(fut)  def _tearDownAsyncioLoop(self): assert self._asyncioTestLoop is not None loop = self._asyncioTestLoop self._asyncioTestLoop = None self._asyncioCallsQueue.put_nowait(None) loop.run_until_complete(self._asyncioCallsQueue.join())  try: # cancel all tasks to_cancel = all_tasks(loop) if not to_cancel: return  for task in to_cancel: task.cancel()  loop.run_until_complete( asyncio.gather(*to_cancel, loop=loop, return_exceptions=True) )  for task in to_cancel: if task.cancelled(): continue if task.exception() is not None: loop.call_exception_handler( { &#34;message&#34;: &#34;unhandled exception during test shutdown&#34;, &#34;exception&#34;: task.exception(), &#34;task&#34;: task, } ) # shutdown asyncgens loop.run_until_complete(loop.shutdown_asyncgens()) finally: asyncio.set_event_loop(None) loop.close()  def run(self, result=None): self._setupAsyncioLoop() try: return super().run(result) finally: self._tearDownAsyncioLoop()"
                }
            },
            {
                "id": 282,
                "attributes": {
                    "id": 282.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase.__init__",
                    "type": "function",
                    "code": "def __init__(self, methodName=&#34;runTest&#34;): super().__init__(methodName) self._asyncioTestLoop = None self._asyncioCallsQueue = None",
                    "signature": "def __init__(self, methodName=&#34;runTest&#34;): super().__init__(methodName) self._asyncioTestLoop = None self._asyncioCallsQueue = None"
                }
            },
            {
                "id": 283,
                "attributes": {
                    "id": 283.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase.asyncSetUp",
                    "type": "function",
                    "code": "async def asyncSetUp(self): pass",
                    "signature": "async def asyncSetUp(self): pass"
                }
            },
            {
                "id": 284,
                "attributes": {
                    "id": 284.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase.asyncTearDown",
                    "type": "function",
                    "code": "async def asyncTearDown(self): pass",
                    "signature": "async def asyncTearDown(self): pass"
                }
            },
            {
                "id": 285,
                "attributes": {
                    "id": 285.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase.addAsyncCleanup",
                    "type": "function",
                    "code": "def addAsyncCleanup(self, func, *args, **kwargs): # A trivial trampoline to addCleanup() # the function exists because it has a different semantics # and signature: # addCleanup() accepts regular functions # but addAsyncCleanup() accepts coroutines # # We intentionally don't add inspect.iscoroutinefunction() check # for func argument because there is no way # to check for async function reliably: # 1. It can be &#34;async def func()&#34; itself # 2. Class can implement &#34;async def __call__()&#34; method # 3. Regular &#34;def func()&#34; that returns awaitable object self.addCleanup(*(func, *args), **kwargs)",
                    "signature": "def addAsyncCleanup(self, func, *args, **kwargs): # A trivial trampoline to addCleanup() # the function exists because it has a different semantics # and signature: # addCleanup() accepts regular functions # but addAsyncCleanup() accepts coroutines # # We intentionally don't add inspect.iscoroutinefunction() check # for func argument because there is no way # to check for async function reliably: # 1. It can be &#34;async def func()&#34; itself # 2. Class can implement &#34;async def __call__()&#34; method # 3. Regular &#34;def func()&#34; that returns awaitable object self.addCleanup(*(func, *args), **kwargs)"
                }
            },
            {
                "id": 286,
                "attributes": {
                    "id": 286.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase._callSetUp",
                    "type": "function",
                    "code": "def _callSetUp(self): self.setUp() self._callAsync(self.asyncSetUp)",
                    "signature": "def _callSetUp(self): self.setUp() self._callAsync(self.asyncSetUp)"
                }
            },
            {
                "id": 287,
                "attributes": {
                    "id": 287.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase._callTestMethod",
                    "type": "function",
                    "code": "def _callTestMethod(self, method): self._callMaybeAsync(method)",
                    "signature": "def _callTestMethod(self, method): self._callMaybeAsync(method)"
                }
            },
            {
                "id": 288,
                "attributes": {
                    "id": 288.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase._callTearDown",
                    "type": "function",
                    "code": "def _callTearDown(self): self._callAsync(self.asyncTearDown) self.tearDown()",
                    "signature": "def _callTearDown(self): self._callAsync(self.asyncTearDown) self.tearDown()"
                }
            },
            {
                "id": 289,
                "attributes": {
                    "id": 289.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase._callCleanup",
                    "type": "function",
                    "code": "def _callCleanup(self, function, *args, **kwargs): self._callMaybeAsync(function, *args, **kwargs)",
                    "signature": "def _callCleanup(self, function, *args, **kwargs): self._callMaybeAsync(function, *args, **kwargs)"
                }
            },
            {
                "id": 290,
                "attributes": {
                    "id": 290.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase._callAsync",
                    "type": "function",
                    "code": "def _callAsync(self, func, *args, **kwargs): assert self._asyncioTestLoop is not None ret = func(*args, **kwargs) assert inspect.isawaitable(ret) fut = self._asyncioTestLoop.create_future() self._asyncioCallsQueue.put_nowait((fut, ret)) return self._asyncioTestLoop.run_until_complete(fut)",
                    "signature": "def _callAsync(self, func, *args, **kwargs): assert self._asyncioTestLoop is not None ret = func(*args, **kwargs) assert inspect.isawaitable(ret) fut = self._asyncioTestLoop.create_future() self._asyncioCallsQueue.put_nowait((fut, ret)) return self._asyncioTestLoop.run_until_complete(fut)"
                }
            },
            {
                "id": 291,
                "attributes": {
                    "id": 291.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase._callMaybeAsync",
                    "type": "function",
                    "code": "def _callMaybeAsync(self, func, *args, **kwargs): assert self._asyncioTestLoop is not None ret = func(*args, **kwargs) if inspect.isawaitable(ret): fut = self._asyncioTestLoop.create_future() self._asyncioCallsQueue.put_nowait((fut, ret)) return self._asyncioTestLoop.run_until_complete(fut) else: return ret",
                    "signature": "def _callMaybeAsync(self, func, *args, **kwargs): assert self._asyncioTestLoop is not None ret = func(*args, **kwargs) if inspect.isawaitable(ret): fut = self._asyncioTestLoop.create_future() self._asyncioCallsQueue.put_nowait((fut, ret)) return self._asyncioTestLoop.run_until_complete(fut) else: return ret"
                }
            },
            {
                "id": 292,
                "attributes": {
                    "id": 292.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase._asyncioLoopRunner",
                    "type": "function",
                    "code": "async def _asyncioLoopRunner(self, fut): self._asyncioCallsQueue = queue = asyncio.Queue() fut.set_result(None) while True: query = await queue.get() queue.task_done() if query is None: return fut, awaitable = query try: ret = await awaitable if not fut.cancelled(): fut.set_result(ret) except asyncio.CancelledError: raise except Exception as ex: if not fut.cancelled(): fut.set_exception(ex)",
                    "signature": "async def _asyncioLoopRunner(self, fut): self._asyncioCallsQueue = queue = asyncio.Queue() fut.set_result(None) while True: query = await queue.get() queue.task_done() if query is None: return fut, awaitable = query try: ret = await awaitable if not fut.cancelled(): fut.set_result(ret) except asyncio.CancelledError: raise except Exception as ex: if not fut.cancelled(): fut.set_exception(ex)"
                }
            },
            {
                "id": 293,
                "attributes": {
                    "id": 293.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase._setupAsyncioLoop",
                    "type": "function",
                    "code": "def _setupAsyncioLoop(self): assert self._asyncioTestLoop is None loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) loop.set_debug(True) self._asyncioTestLoop = loop fut = loop.create_future() self._asyncioCallsTask = loop.create_task(self._asyncioLoopRunner(fut)) loop.run_until_complete(fut)",
                    "signature": "def _setupAsyncioLoop(self): assert self._asyncioTestLoop is None loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) loop.set_debug(True) self._asyncioTestLoop = loop fut = loop.create_future() self._asyncioCallsTask = loop.create_task(self._asyncioLoopRunner(fut)) loop.run_until_complete(fut)"
                }
            },
            {
                "id": 294,
                "attributes": {
                    "id": 294.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase._tearDownAsyncioLoop",
                    "type": "function",
                    "code": "def _tearDownAsyncioLoop(self): assert self._asyncioTestLoop is not None loop = self._asyncioTestLoop self._asyncioTestLoop = None self._asyncioCallsQueue.put_nowait(None) loop.run_until_complete(self._asyncioCallsQueue.join())  try: # cancel all tasks to_cancel = all_tasks(loop) if not to_cancel: return  for task in to_cancel: task.cancel()  loop.run_until_complete( asyncio.gather(*to_cancel, loop=loop, return_exceptions=True) )  for task in to_cancel: if task.cancelled(): continue if task.exception() is not None: loop.call_exception_handler( { &#34;message&#34;: &#34;unhandled exception during test shutdown&#34;, &#34;exception&#34;: task.exception(), &#34;task&#34;: task, } ) # shutdown asyncgens loop.run_until_complete(loop.shutdown_asyncgens()) finally: asyncio.set_event_loop(None) loop.close()",
                    "signature": "def _tearDownAsyncioLoop(self): assert self._asyncioTestLoop is not None loop = self._asyncioTestLoop self._asyncioTestLoop = None self._asyncioCallsQueue.put_nowait(None) loop.run_until_complete(self._asyncioCallsQueue.join())  try: # cancel all tasks to_cancel = all_tasks(loop) if not to_cancel: return  for task in to_cancel: task.cancel()  loop.run_until_complete( asyncio.gather(*to_cancel, loop=loop, return_exceptions=True) )  for task in to_cancel: if task.cancelled(): continue if task.exception() is not None: loop.call_exception_handler( { &#34;message&#34;: &#34;unhandled exception during test shutdown&#34;, &#34;exception&#34;: task.exception(), &#34;task&#34;: task, } ) # shutdown asyncgens loop.run_until_complete(loop.shutdown_asyncgens()) finally: asyncio.set_event_loop(None) loop.close()"
                }
            },
            {
                "id": 295,
                "attributes": {
                    "id": 295.0,
                    "label": "hl7.tests.backports.unittest.async_case.IsolatedAsyncioTestCase.run",
                    "type": "function",
                    "code": "def run(self, result=None): self._setupAsyncioLoop() try: return super().run(result) finally: self._tearDownAsyncioLoop()",
                    "signature": "def run(self, result=None): self._setupAsyncioLoop() try: return super().run(result) finally: self._tearDownAsyncioLoop()"
                }
            }
        ]
    },
    "14": {
        "nodes": [
            {
                "id": 46,
                "attributes": {
                    "id": 46.0,
                    "label": "hl7.hl7.parser",
                    "type": "module",
                    "code": "None",
                    "signature": "None"
                }
            },
            {
                "id": 53,
                "attributes": {
                    "id": 53.0,
                    "label": "hl7.hl7.parser._split",
                    "type": "function",
                    "code": "def _split(text, plan): &#34;&#34;&#34;Recursive function to split the *text* into an n-deep list, according to the :py:class:`hl7._ParsePlan`. &#34;&#34;&#34; # Base condition, if we have used up all the plans if not plan: return text  if not plan.applies(text): return plan.container([text])  # Parsing of the first segment is awkward because it contains # the separator characters in a field if plan.containers[0] == plan.factory.create_segment and text[:3] in [ &#34;MSH&#34;, &#34;BHS&#34;, &#34;FHS&#34;, ]: seg = text[:3] sep0 = text[3] sep_end_off = text.find(sep0, 4) seps = text[4:sep_end_off] text = text[sep_end_off + 1 :] data = [ plan.factory.create_field( sequence=[seg], esc=plan.esc, separators=plan.separators ), plan.factory.create_field( sequence=[sep0], esc=plan.esc, separators=plan.separators ), plan.factory.create_field( sequence=[seps], esc=plan.esc, separators=plan.separators ), ] else: data = []  if text: data = data + [_split(x, plan.next()) for x in text.split(plan.separator)] # Return the instance of the current message part according # to the plan return plan.container(data)",
                    "signature": "def _split(text, plan): &#34;&#34;&#34;Recursive function to split the *text* into an n-deep list, according to the :py:class:`hl7._ParsePlan`. &#34;&#34;&#34; # Base condition, if we have used up all the plans if not plan: return text  if not plan.applies(text): return plan.container([text])  # Parsing of the first segment is awkward because it contains # the separator characters in a field if plan.containers[0] == plan.factory.create_segment and text[:3] in [ &#34;MSH&#34;, &#34;BHS&#34;, &#34;FHS&#34;, ]: seg = text[:3] sep0 = text[3] sep_end_off = text.find(sep0, 4) seps = text[4:sep_end_off] text = text[sep_end_off + 1 :] data = [ plan.factory.create_field( sequence=[seg], esc=plan.esc, separators=plan.separators ), plan.factory.create_field( sequence=[sep0], esc=plan.esc, separators=plan.separators ), plan.factory.create_field( sequence=[seps], esc=plan.esc, separators=plan.separators ), ] else: data = []  if text: data = data + [_split(x, plan.next()) for x in text.split(plan.separator)] # Return the instance of the current message part according # to the plan return plan.container(data)"
                }
            },
            {
                "id": 54,
                "attributes": {
                    "id": 54.0,
                    "label": "hl7.hl7.parser.create_parse_plan",
                    "type": "function",
                    "code": "def create_parse_plan(strmsg, factory=Factory): &#34;&#34;&#34;Creates a plan on how to parse the HL7 message according to the details stored within the message. &#34;&#34;&#34; # We will always use a carriage return to separate segments separators = &#34;\\r&#34;  # Extract the rest of the separators. Defaults used if not present. if strmsg[:3] not in (&#34;MSH&#34;, &#34;FHS&#34;, &#34;BHS&#34;): raise ParseException( &#34;First segment is {}, must be one of MHS, FHS or BHS&#34;.format(strmsg[:3]) ) sep0 = strmsg[3] seps = list(strmsg[3 : strmsg.find(sep0, 4)])  separators += seps[0] if len(seps) > 2: separators += seps[2]  # repetition separator else: separators += &#34;~&#34;  # repetition separator if len(seps) > 1: separators += seps[1]  # component separator else: separators += &#34;^&#34;  # component separator if len(seps) > 4: separators += seps[4]  # sub-component separator else: separators += &#34;&#38;&#34;  # sub-component separator if len(seps) > 3: esc = seps[3] else: esc = &#34;\\\\&#34;  # The ordered list of containers to create containers = [ factory.create_message, factory.create_segment, factory.create_field, factory.create_repetition, factory.create_component, ] return _ParsePlan(separators[0], separators, containers, esc, factory)",
                    "signature": "def create_parse_plan(strmsg, factory=Factory): &#34;&#34;&#34;Creates a plan on how to parse the HL7 message according to the details stored within the message. &#34;&#34;&#34; # We will always use a carriage return to separate segments separators = &#34;\\r&#34;  # Extract the rest of the separators. Defaults used if not present. if strmsg[:3] not in (&#34;MSH&#34;, &#34;FHS&#34;, &#34;BHS&#34;): raise ParseException( &#34;First segment is {}, must be one of MHS, FHS or BHS&#34;.format(strmsg[:3]) ) sep0 = strmsg[3] seps = list(strmsg[3 : strmsg.find(sep0, 4)])  separators += seps[0] if len(seps) > 2: separators += seps[2]  # repetition separator else: separators += &#34;~&#34;  # repetition separator if len(seps) > 1: separators += seps[1]  # component separator else: separators += &#34;^&#34;  # component separator if len(seps) > 4: separators += seps[4]  # sub-component separator else: separators += &#34;&#38;&#34;  # sub-component separator if len(seps) > 3: esc = seps[3] else: esc = &#34;\\\\&#34;  # The ordered list of containers to create containers = [ factory.create_message, factory.create_segment, factory.create_field, factory.create_repetition, factory.create_component, ] return _ParsePlan(separators[0], separators, containers, esc, factory)"
                }
            },
            {
                "id": 55,
                "attributes": {
                    "id": 55.0,
                    "label": "hl7.hl7.parser._ParsePlan",
                    "type": "class",
                    "code": "class _ParsePlan(object): &#34;&#34;&#34;Details on how to parse an HL7 message. Typically this object should be created via :func:`hl7.create_parse_plan` &#34;&#34;&#34;  # field, component, repetition, escape, subcomponent  def __init__(self, seperator, separators, containers, esc, factory): # TODO test to see performance implications of the assertion # since we generate the ParsePlan, this should never be in # invalid state assert len(containers) == len(separators[separators.find(seperator) :]) self.separator = seperator self.separators = separators self.containers = containers self.esc = esc self.factory = factory  def container(self, data): &#34;&#34;&#34;Return an instance of the appropriate container for the *data* as specified by the current plan. &#34;&#34;&#34; return self.containers[0]( sequence=data, esc=self.esc, separators=self.separators, factory=self.factory, )  def next(self): &#34;&#34;&#34;Generate the next level of the plan (essentially generates a copy of this plan with the level of the container and the seperator starting at the next index. &#34;&#34;&#34; if len(self.containers) > 1: # Return a new instance of this class using the tails of # the separators and containers lists. Use self.__class__() # in case :class:`hl7.ParsePlan` is subclassed return self.__class__( self.separators[self.separators.find(self.separator) + 1], self.separators, self.containers[1:], self.esc, self.factory, ) # When we have no separators and containers left, return None, # which indicates that we have nothing further. return None  def applies(self, text): &#34;&#34;&#34;return True if the separator or those if the children are in the text&#34;&#34;&#34; for s in self.separators[self.separators.find(self.separator) :]: if text.find(s) >= 0: return True return False",
                    "signature": "class _ParsePlan(object): &#34;&#34;&#34;Details on how to parse an HL7 message. Typically this object should be created via :func:`hl7.create_parse_plan` &#34;&#34;&#34;  # field, component, repetition, escape, subcomponent  def __init__(self, seperator, separators, containers, esc, factory): # TODO test to see performance implications of the assertion # since we generate the ParsePlan, this should never be in # invalid state assert len(containers) == len(separators[separators.find(seperator) :]) self.separator = seperator self.separators = separators self.containers = containers self.esc = esc self.factory = factory  def container(self, data): &#34;&#34;&#34;Return an instance of the appropriate container for the *data* as specified by the current plan. &#34;&#34;&#34; return self.containers[0]( sequence=data, esc=self.esc, separators=self.separators, factory=self.factory, )  def next(self): &#34;&#34;&#34;Generate the next level of the plan (essentially generates a copy of this plan with the level of the container and the seperator starting at the next index. &#34;&#34;&#34; if len(self.containers) > 1: # Return a new instance of this class using the tails of # the separators and containers lists. Use self.__class__() # in case :class:`hl7.ParsePlan` is subclassed return self.__class__( self.separators[self.separators.find(self.separator) + 1], self.separators, self.containers[1:], self.esc, self.factory, ) # When we have no separators and containers left, return None, # which indicates that we have nothing further. return None  def applies(self, text): &#34;&#34;&#34;return True if the separator or those if the children are in the text&#34;&#34;&#34; for s in self.separators[self.separators.find(self.separator) :]: if text.find(s) >= 0: return True return False"
                }
            },
            {
                "id": 56,
                "attributes": {
                    "id": 56.0,
                    "label": "hl7.hl7.parser._ParsePlan.__init__",
                    "type": "function",
                    "code": "def __init__(self, seperator, separators, containers, esc, factory): # TODO test to see performance implications of the assertion # since we generate the ParsePlan, this should never be in # invalid state assert len(containers) == len(separators[separators.find(seperator) :]) self.separator = seperator self.separators = separators self.containers = containers self.esc = esc self.factory = factory",
                    "signature": "def __init__(self, seperator, separators, containers, esc, factory): # TODO test to see performance implications of the assertion # since we generate the ParsePlan, this should never be in # invalid state assert len(containers) == len(separators[separators.find(seperator) :]) self.separator = seperator self.separators = separators self.containers = containers self.esc = esc self.factory = factory"
                }
            },
            {
                "id": 57,
                "attributes": {
                    "id": 57.0,
                    "label": "hl7.hl7.parser._ParsePlan.container",
                    "type": "function",
                    "code": "def container(self, data): &#34;&#34;&#34;Return an instance of the appropriate container for the *data* as specified by the current plan. &#34;&#34;&#34; return self.containers[0]( sequence=data, esc=self.esc, separators=self.separators, factory=self.factory, )",
                    "signature": "def container(self, data): &#34;&#34;&#34;Return an instance of the appropriate container for the *data* as specified by the current plan. &#34;&#34;&#34; return self.containers[0]( sequence=data, esc=self.esc, separators=self.separators, factory=self.factory, )"
                }
            },
            {
                "id": 58,
                "attributes": {
                    "id": 58.0,
                    "label": "hl7.hl7.parser._ParsePlan.next",
                    "type": "function",
                    "code": "def next(self): &#34;&#34;&#34;Generate the next level of the plan (essentially generates a copy of this plan with the level of the container and the seperator starting at the next index. &#34;&#34;&#34; if len(self.containers) > 1: # Return a new instance of this class using the tails of # the separators and containers lists. Use self.__class__() # in case :class:`hl7.ParsePlan` is subclassed return self.__class__( self.separators[self.separators.find(self.separator) + 1], self.separators, self.containers[1:], self.esc, self.factory, ) # When we have no separators and containers left, return None, # which indicates that we have nothing further. return None",
                    "signature": "def next(self): &#34;&#34;&#34;Generate the next level of the plan (essentially generates a copy of this plan with the level of the container and the seperator starting at the next index. &#34;&#34;&#34; if len(self.containers) > 1: # Return a new instance of this class using the tails of # the separators and containers lists. Use self.__class__() # in case :class:`hl7.ParsePlan` is subclassed return self.__class__( self.separators[self.separators.find(self.separator) + 1], self.separators, self.containers[1:], self.esc, self.factory, ) # When we have no separators and containers left, return None, # which indicates that we have nothing further. return None"
                }
            },
            {
                "id": 59,
                "attributes": {
                    "id": 59.0,
                    "label": "hl7.hl7.parser._ParsePlan.applies",
                    "type": "function",
                    "code": "def applies(self, text): &#34;&#34;&#34;return True if the separator or those if the children are in the text&#34;&#34;&#34; for s in self.separators[self.separators.find(self.separator) :]: if text.find(s) >= 0: return True return False",
                    "signature": "def applies(self, text): &#34;&#34;&#34;return True if the separator or those if the children are in the text&#34;&#34;&#34; for s in self.separators[self.separators.find(self.separator) :]: if text.find(s) >= 0: return True return False"
                }
            },
            {
                "id": 386,
                "attributes": {
                    "id": 386.0,
                    "label": "hl7.tests.test_parse.ParsePlanTest",
                    "type": "class",
                    "code": "class ParsePlanTest(TestCase): def test_create_parse_plan(self): plan = hl7.parser.create_parse_plan(sample_hl7)  self.assertEqual(plan.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual( plan.containers, [Message, Segment, Field, Repetition, Component] )  def test_parse_plan(self): plan = hl7.parser.create_parse_plan(sample_hl7)  self.assertEqual(plan.separator, &#34;\\r&#34;) con = plan.container([1, 2]) self.assertIsInstance(con, Message) self.assertEqual(con, [1, 2]) self.assertEqual(con.separator, &#34;\\r&#34;)  def test_parse_plan_next(self): plan = hl7.parser.create_parse_plan(sample_hl7)  n1 = plan.next() self.assertEqual(n1.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n1.separator, &#34;|&#34;) self.assertEqual(n1.containers, [Segment, Field, Repetition, Component])  n2 = n1.next() self.assertEqual(n2.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n2.separator, &#34;~&#34;) self.assertEqual(n2.containers, [Field, Repetition, Component])  n3 = n2.next() self.assertEqual(n3.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n3.separator, &#34;^&#34;) self.assertEqual(n3.containers, [Repetition, Component])  n4 = n3.next() self.assertEqual(n4.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n4.separator, &#34;&#38;&#34;) self.assertEqual(n4.containers, [Component])  n5 = n4.next() self.assertTrue(n5 is None)",
                    "signature": "class ParsePlanTest(TestCase): def test_create_parse_plan(self): plan = hl7.parser.create_parse_plan(sample_hl7)  self.assertEqual(plan.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual( plan.containers, [Message, Segment, Field, Repetition, Component] )  def test_parse_plan(self): plan = hl7.parser.create_parse_plan(sample_hl7)  self.assertEqual(plan.separator, &#34;\\r&#34;) con = plan.container([1, 2]) self.assertIsInstance(con, Message) self.assertEqual(con, [1, 2]) self.assertEqual(con.separator, &#34;\\r&#34;)  def test_parse_plan_next(self): plan = hl7.parser.create_parse_plan(sample_hl7)  n1 = plan.next() self.assertEqual(n1.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n1.separator, &#34;|&#34;) self.assertEqual(n1.containers, [Segment, Field, Repetition, Component])  n2 = n1.next() self.assertEqual(n2.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n2.separator, &#34;~&#34;) self.assertEqual(n2.containers, [Field, Repetition, Component])  n3 = n2.next() self.assertEqual(n3.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n3.separator, &#34;^&#34;) self.assertEqual(n3.containers, [Repetition, Component])  n4 = n3.next() self.assertEqual(n4.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n4.separator, &#34;&#38;&#34;) self.assertEqual(n4.containers, [Component])  n5 = n4.next() self.assertTrue(n5 is None)"
                }
            },
            {
                "id": 387,
                "attributes": {
                    "id": 387.0,
                    "label": "hl7.tests.test_parse.ParsePlanTest.test_create_parse_plan",
                    "type": "function",
                    "code": "def test_create_parse_plan(self): plan = hl7.parser.create_parse_plan(sample_hl7)  self.assertEqual(plan.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual( plan.containers, [Message, Segment, Field, Repetition, Component] )",
                    "signature": "def test_create_parse_plan(self): plan = hl7.parser.create_parse_plan(sample_hl7)  self.assertEqual(plan.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual( plan.containers, [Message, Segment, Field, Repetition, Component] )"
                }
            },
            {
                "id": 388,
                "attributes": {
                    "id": 388.0,
                    "label": "hl7.tests.test_parse.ParsePlanTest.test_parse_plan",
                    "type": "function",
                    "code": "def test_parse_plan(self): plan = hl7.parser.create_parse_plan(sample_hl7)  self.assertEqual(plan.separator, &#34;\\r&#34;) con = plan.container([1, 2]) self.assertIsInstance(con, Message) self.assertEqual(con, [1, 2]) self.assertEqual(con.separator, &#34;\\r&#34;)",
                    "signature": "def test_parse_plan(self): plan = hl7.parser.create_parse_plan(sample_hl7)  self.assertEqual(plan.separator, &#34;\\r&#34;) con = plan.container([1, 2]) self.assertIsInstance(con, Message) self.assertEqual(con, [1, 2]) self.assertEqual(con.separator, &#34;\\r&#34;)"
                }
            },
            {
                "id": 389,
                "attributes": {
                    "id": 389.0,
                    "label": "hl7.tests.test_parse.ParsePlanTest.test_parse_plan_next",
                    "type": "function",
                    "code": "def test_parse_plan_next(self): plan = hl7.parser.create_parse_plan(sample_hl7)  n1 = plan.next() self.assertEqual(n1.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n1.separator, &#34;|&#34;) self.assertEqual(n1.containers, [Segment, Field, Repetition, Component])  n2 = n1.next() self.assertEqual(n2.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n2.separator, &#34;~&#34;) self.assertEqual(n2.containers, [Field, Repetition, Component])  n3 = n2.next() self.assertEqual(n3.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n3.separator, &#34;^&#34;) self.assertEqual(n3.containers, [Repetition, Component])  n4 = n3.next() self.assertEqual(n4.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n4.separator, &#34;&#38;&#34;) self.assertEqual(n4.containers, [Component])  n5 = n4.next() self.assertTrue(n5 is None)",
                    "signature": "def test_parse_plan_next(self): plan = hl7.parser.create_parse_plan(sample_hl7)  n1 = plan.next() self.assertEqual(n1.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n1.separator, &#34;|&#34;) self.assertEqual(n1.containers, [Segment, Field, Repetition, Component])  n2 = n1.next() self.assertEqual(n2.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n2.separator, &#34;~&#34;) self.assertEqual(n2.containers, [Field, Repetition, Component])  n3 = n2.next() self.assertEqual(n3.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n3.separator, &#34;^&#34;) self.assertEqual(n3.containers, [Repetition, Component])  n4 = n3.next() self.assertEqual(n4.separators, &#34;\\r|~^&#38;&#34;) self.assertEqual(n4.separator, &#34;&#38;&#34;) self.assertEqual(n4.containers, [Component])  n5 = n4.next() self.assertTrue(n5 is None)"
                }
            }
        ]
    }
}