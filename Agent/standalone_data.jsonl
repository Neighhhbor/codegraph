{"namespace": "benedict.utils.type_util.is_json_serializable", "type": "function", "project_path": "Text-Processing/python-benedict", "completion_path": "Text-Processing/python-benedict/benedict/utils/type_util.py", "signature_position": [53, 53], "body_position": [54, 55], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the input value is JSON serializable. It checks if the input value is of the JSON serializable types.", "Arguments": ":param val: Any. The input value to be checked for JSON serializability.\n:return: Bool. True if the input value is JSON serializable, False otherwise."}, "tests": ["tests/utils/test_type_util.py::type_util_test_case::test_is_json_serializable"], "indent": 4}
{"namespace": "feedparser.urls.convert_to_idn", "type": "function", "project_path": "Text-Processing/feedparser", "completion_path": "Text-Processing/feedparser/feedparser/urls.py", "signature_position": [61, 61], "body_position": [66, 83], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert a URL to IDN notation. It checks if the host can be encoded in ASCII. If not, it converts the host to IDN form.", "Arguments": ":param url: String. The URL to be converted to IDN notation.\n:return: String. The URL in IDN notation."}, "tests": ["tests/runtests.py::TestConvertToIdn::test_port", "tests/runtests.py::TestConvertToIdn::test_idn", "tests/runtests.py::TestConvertToIdn::test_control"], "indent": 4}
{"namespace": "mistune.toc.add_toc_hook", "type": "function", "project_path": "Text-Processing/mistune", "completion_path": "Text-Processing/mistune/src/mistune/toc.py", "signature_position": [4, 4], "body_position": [23, 44], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function adds a hook to save table of contents (TOC) items into the state.env. It is usually helpful for doc generator.", "Arguments": ":param md: Markdown instance. The instance of the Markdown class.\n:param min_level: Integer. The minimum heading level to include in the TOC.\n:param max_level: Integer. The maximum heading level to include in the TOC.\n:param heading_id: Function. A function to generate heading_id.\n:return: No return values."}, "tests": ["tests/test_hooks.py::TestTocHook::test_customize_heading_id_func"], "indent": 4}
{"namespace": "mistune.plugins.table.table_in_quote", "type": "function", "project_path": "Text-Processing/mistune", "completion_path": "Text-Processing/mistune/src/mistune/plugins/table.py", "signature_position": [170, 170], "body_position": [172, 173], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function enables the table plugin in block quotes by inserting rules for table and nptable before the paragraph in the block quote rules.", "Arguments": ":param md: Markdown. The Markdown instance.\n:return: No return values."}, "tests": ["tests/test_plugins.py::TestExtraPlugins::test_table_in_quote"], "indent": 4}
{"namespace": "mistune.plugins.table.table_in_list", "type": "function", "project_path": "Text-Processing/mistune", "completion_path": "Text-Processing/mistune/src/mistune/plugins/table.py", "signature_position": [176, 176], "body_position": [178, 179], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function enables the table plugin in the list. It inserts the table and nptable rules before the paragraph rule in the list.", "Arguments": ":param md: Markdown. The Markdown instance to enable the table plugin in the list.\n:return: No return values."}, "tests": ["tests/test_plugins.py::TestExtraPlugins::test_table_in_list"], "indent": 4}
{"namespace": "xmnlp.utils.parallel_handler", "type": "function", "project_path": "Text-Processing/xmnlp", "completion_path": "Text-Processing/xmnlp/xmnlp/utils/__init__.py", "signature_position": [90, 92], "body_position": [101, 107], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a parallel handler that takes a callback function and a list of texts as input. It then processes the texts using the callback function in parallel using a thread pool executor. If the input `texts` is not a list, raise a ValueError(\"You should pass a list of texts\").", "Arguments": ":param callback: Callable. The callback function to be applied to the list of texts.\n:param texts: List[str]. The list of texts to be processed.\n:param n_jobs: int. The pool size of threads. Defaults to 2.\n:param kwargs: Any additional keyword arguments to be passed to the callback function.\n:return: Generator[List[Any], None, None]. A generator that yields the results of applying the callback function to the texts in parallel."}, "tests": ["tests/test_xmnlp.py::test_radical_parallel", "tests/test_xmnlp.py::test_pinyin_parallel"], "indent": 4}
{"namespace": "parsel.utils.shorten", "type": "function", "project_path": "Text-Processing/parsel", "completion_path": "Text-Processing/parsel/parsel/utils.py", "signature_position": [87, 87], "body_position": [89, 95], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Shorten the given text to fit in the given width. If the length of the text is less than or equal to the width, the original text is returned. If the width is greater than the length of the suffix, the text is truncated to fit the width and the suffix is added. If the width is greater than or equal to 0, the suffix is returned based on the width. Otherwise, a ValueError(\"width must be equal or greater than 0\") is raised.", "Arguments": ":param text: String. The input text to be shortened.\n:param width: Integer. The width to which the text should be shortened.\n:param suffix: String. The suffix to be added at the end of the shortened text. Defaults to \"...\".\n:return: String. The shortened text."}, "tests": ["tests/test_utils.py::test_shorten"], "indent": 4}
{"namespace": "parsel.xpathfuncs.set_xpathfunc", "type": "function", "project_path": "Text-Processing/parsel", "completion_path": "Text-Processing/parsel/parsel/xpathfuncs.py", "signature_position": [13, 13], "body_position": [27, 31], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function registers a custom extension function to use in XPath expressions. The function registered under the fname identifier will be called for every matching node, being passed a context parameter as well as any parameters passed from the corresponding XPath expression.", "Arguments": ":param fname: String. The identifier under which the function will be registered.\n:param func: Callable. The function to be registered. If None, the extension function will be removed.\n:return: No return values."}, "tests": ["tests/test_xpathfuncs.py::XPathFuncsTestCase::test_set_xpathfunc"], "indent": 4}
{"namespace": "dominate.dom_tag._get_thread_context", "type": "function", "project_path": "Text-Processing/dominate", "completion_path": "Text-Processing/dominate/dominate/dom_tag.py", "signature_position": [47, 47], "body_position": [48, 51], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the hash value of the current thread context. It first creates a list of the current thread and greenlet (if available) and then returns the hash value of the tuple of the context list.", "Arguments": ":param: No input parameters.\n:return: Integer. The hash value of the current thread context."}, "tests": ["tests/test_dom_tag.py::test___get_thread_context"], "indent": 2}
{"namespace": "dominate.util.system", "type": "function", "project_path": "Text-Processing/dominate", "completion_path": "Text-Processing/dominate/dominate/util.py", "signature_position": [45, 45], "body_position": [49, 52], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function runs a system command and returns the output as a string. It uses the subprocess module to run the command and capture the output.", "Arguments": ":param cmd: String. The system command to be executed.\n:param data: Bytes. Optional input data to be passed to the command.\n:return: String. The output of the system command as a decoded string."}, "tests": ["tests/test_utils.py::test_system"], "indent": 2}
{"namespace": "dominate.util.url_unescape", "type": "function", "project_path": "Text-Processing/dominate", "completion_path": "Text-Processing/dominate/dominate/util.py", "signature_position": [118, 118], "body_position": [119, 120], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes a string as input and unescapes any URL-encoded characters in the string.", "Arguments": ":param data: String. The URL-encoded string to be unescaped.\n:return: String. The unescaped string."}, "tests": ["tests/test_utils.py::test_url"], "indent": 2}
{"namespace": "rows.fields.DatetimeField.serialize", "type": "method", "project_path": "Text-Processing/rows", "completion_path": "Text-Processing/rows/rows/fields.py", "signature_position": [390, 390], "body_position": [391, 394], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Serialize the given datetime value into a string in ISO 8601 format.", "Arguments": ":param cls: Class. The class instance.\n:param value: Datetime. The datetime value to be serialized.\n:param *args: Additional positional arguments.\n:param **kwargs: Additional keyword arguments.\n:return: String. The serialized datetime value in ISO 8601 format."}, "tests": ["tests/tests_fields.py::FieldsTestCase::test_DatetimeField"], "indent": 8}
{"namespace": "rows.fields.Field.serialize", "type": "method", "project_path": "Text-Processing/rows", "completion_path": "Text-Processing/rows/rows/fields.py", "signature_position": [77, 77], "body_position": [84, 86], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function serializes a value to be exported. It should always return a unicode value, except for BinaryField.", "Arguments": ":param cls: Class. The class instance.\n:param value: Any. The value to be serialized.\n:param *args: Tuple. Additional positional arguments.\n:param **kwargs: Dictionary. Additional keyword arguments.\n:return: Any. The serialized value."}, "tests": ["tests/tests_fields.py::FieldsTestCase::test_Field", "tests/tests_fields.py::FieldsTestCase::test_TextField"], "indent": 8}
{"namespace": "rows.fields.EmailField.serialize", "type": "method", "project_path": "Text-Processing/rows", "completion_path": "Text-Processing/rows/rows/fields.py", "signature_position": [438, 438], "body_position": [439, 442], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Serialize the value of the email field. If the value is None, it returns an empty string. Otherwise, it returns the string representation of the value.", "Arguments": ":param cls: Class. The class itself.\n:param value: Any. The value to be serialized.\n:param *args: Tuple. Additional positional arguments.\n:param **kwargs: Dictionary. Additional keyword arguments.\n:return: String. The serialized value."}, "tests": ["tests/tests_fields.py::FieldsTestCase::test_EmailField"], "indent": 8}
{"namespace": "rows.fields.as_string", "type": "function", "project_path": "Text-Processing/rows", "completion_path": "Text-Processing/rows/rows/fields.py", "signature_position": [478, 478], "body_position": [479, 484], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the input value to a string. If the input value is already a string, it returns the input value. If the input value is a binary type, it raises a ValueError.", "Arguments": ":param value: Any. The input value to be converted to a string.\n:return: String. The input value converted to a string."}, "tests": ["tests/tests_fields.py::FieldsFunctionsTestCase::test_as_string"], "indent": 4}
{"namespace": "rows.fields.get_items", "type": "function", "project_path": "Text-Processing/rows", "completion_path": "Text-Processing/rows/rows/fields.py", "signature_position": [506, 506], "body_position": [513, 515], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a callable that fetches the given indexes of an object. It always returns a tuple even when len(indexes) == 1. It is similar to `operator.itemgetter`, but will insert `None` when the object does not have the desired index (instead of raising IndexError).", "Arguments": ":param indexes: Tuple. The indexes of the object to be fetched.\n:return: Lambda function. A callable that fetches the given indexes of an object."}, "tests": ["tests/tests_fields.py::FieldsFunctionsTestCase::test_get_items"], "indent": 4}
{"namespace": "pycorrector.proper_corrector.load_dict_file", "type": "function", "project_path": "Text-Processing/pycorrector", "completion_path": "Text-Processing/pycorrector/pycorrector/proper_corrector.py", "signature_position": [31, 31], "body_position": [37, 52], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Load a dictionary from the given file path. It reads the file line by line and creates a dictionary with the key-value pairs from the file. If the file is not found, an empty dictionary is returned.", "Arguments": ":param path: String. The file path from which the dictionary is to be loaded.\n:return: Dictionary. The loaded dictionary from the file. If the file is not found, an empty dictionary is returned."}, "tests": ["tests/ner_error_test.py::test_common_error"], "indent": 4}
{"namespace": "natasha.span.envelop_spans", "type": "function", "project_path": "Text-Processing/natasha", "completion_path": "Text-Processing/natasha/natasha/span.py", "signature_position": [23, 23], "body_position": [24, 37], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function envelops the spans based on the given envelopes. It iterates through the spans and envelopes and yields the chunk of spans that are enveloped by each envelope.", "Arguments": ":param spans: List of spans. The spans to be enveloped.\n:param envelopes: List of envelopes. The envelopes used to envelop the spans.\n:return: Yield the chunk of spans for each envelope."}, "tests": ["tests/test_span.py::test_envelope_spans"], "indent": 4}
{"namespace": "googleapiclient._helpers.parse_unique_urlencoded", "type": "function", "project_path": "Internet/google-api-python-client", "completion_path": "Internet/google-api-python-client/googleapiclient/_helpers.py", "signature_position": [141, 141], "body_position": [153, 163], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function parses unique key-value parameters from URL-encoded content. It first parses the URL-encoded content and then checks for repeated keys. If a repeated key is found, it raises a ValueError.", "Arguments": ":param content: string. URL-encoded key-value pairs.\n:return: dict. The key-value pairs from the input content.\nRaises:\nValueError: if one of the keys is repeated."}, "tests": ["tests/test__helpers.py::Test_parse_unique_urlencoded::test_without_repeats", "tests/test__helpers.py::Test_parse_unique_urlencoded::test_with_repeats"], "indent": 4}
{"namespace": "jinja2.async_utils.auto_aiter", "type": "function", "project_path": "Internet/Jinja2", "completion_path": "Internet/Jinja2/src/jinja2/async_utils.py", "signature_position": [70, 72], "body_position": [73, 78], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function creates an asynchronous iterator from the given iterable. It checks if the iterable has an __aiter__ attribute and if so, it yields items asynchronously, otherwise, it yields items synchronously.", "Arguments": ":param iterable: Union of AsyncIterable and Iterable. The input iterable from which the iterator is created.\n:return: AsyncIterator. The created asynchronous iterator."}, "tests": ["tests/test_async.py::test_async_iteration_in_templates_extended"], "indent": 4}
{"namespace": "jinja2.utils.consume", "type": "function", "project_path": "Internet/Jinja2", "completion_path": "Internet/Jinja2/src/jinja2/utils.py", "signature_position": [112, 112], "body_position": [114, 115], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function consumes an iterable without doing anything with it. It iterates through the given iterable and does nothing with the elements.", "Arguments": ":param iterable: Iterable. The iterable to be consumed.\n:return: No return values."}, "tests": ["tests/test_utils.py::test_consume"], "indent": 4}
{"namespace": "pycorrector.utils.tokenizer.segment", "type": "function", "project_path": "Text-Processing/pycorrector", "completion_path": "Text-Processing/pycorrector/pycorrector/utils/tokenizer.py", "signature_position": [101, 101], "body_position": [109, 128], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function segments the input sentence into words or characters based on the given cut type. It also provides the option to enable POS tagging.", "Arguments": ":param sentence: String. The input sentence to be segmented.\n:param cut_type: String. The type of segmentation to be used. It defaults to 'word' if not specified.\n:param pos: Bool. Whether to enable POS tagging. It defaults to False if not specified.\n:return: List. The segmented words or characters along with their POS tags if enabled."}, "tests": ["tests/ner_error_test.py::test_ner"], "indent": 4}
{"namespace": "jinja2.utils.object_type_repr", "type": "function", "project_path": "Internet/Jinja2", "completion_path": "Internet/Jinja2/src/jinja2/utils.py", "signature_position": [165, 165], "body_position": [170, 180], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the name of the object's type. For some recognized singletons, the name of the object is returned instead. (For example for `None` and `Ellipsis`). If the object is built-in, the output format is \"{object's name} object\". Otherwise, the output format is \"{object's module} {object's name} object\".", "Arguments": ":param obj: Any. The object for which the type name is to be returned.\n:return: str. The name of the object's type or the name of the object if it is a recognized singleton."}, "tests": ["tests/test_utils.py::TestHelpers::test_object_type_repr"], "indent": 4}
{"namespace": "jinja2.utils.LRUCache.setdefault", "type": "method", "project_path": "Internet/Jinja2", "completion_path": "Internet/Jinja2/src/jinja2/utils.py", "signature_position": [470, 470], "body_position": [474, 478], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Set the default value for a key if it is not already in the cache. If the key is already in the cache, the value remains unchanged. It then returns the value of the key.", "Arguments": ":param self: LRUCache. An instance of the LRUCache class.\n:param key: Any. The key to be checked and set in the cache.\n:param default: Any. The default value to be set for the key if it is not already in the cache. Defaults to None.\n:return: Any. The value of the key."}, "tests": ["tests/test_utils.py::TestLRUCache::test_setdefault"], "indent": 8}
{"namespace": "sumy.summarizers.sum_basic.SumBasicSummarizer._compute_word_freq", "type": "method", "project_path": "Internet/sumy", "completion_path": "Internet/sumy/sumy/summarizers/sum_basic.py", "signature_position": [49, 49], "body_position": [50, 53], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function computes the frequency of each word in the given list of words and returns a dictionary containing the word frequencies.", "Arguments": ":param list_of_words: List of strings. The list of words for which the frequency needs to be computed.\n:return: Dictionary. A dictionary containing the frequency of each word in the input list."}, "tests": ["tests/test_summarizers/test_sum_basic.py::test_compute_word_freq"], "indent": 8}
{"namespace": "sumy.summarizers.sum_basic.SumBasicSummarizer._compute_average_probability_of_words", "type": "method", "project_path": "Internet/sumy", "completion_path": "Internet/sumy/sumy/summarizers/sum_basic.py", "signature_position": [72, 72], "body_position": [73, 79], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function computes the average probability of words in a document based on the frequency of words in the document and the content words in a sentence.", "Arguments": ":param word_freq_in_doc: Dictionary. The frequency of words in the document.\n:param content_words_in_sentence: List. The content words in a sentence.\n:return: Float. The average probability of words in the document. If the content words count is 0, it returns 0."}, "tests": ["tests/test_summarizers/test_sum_basic.py::test_compute_average_probability_of_words"], "indent": 8}
{"namespace": "sumy.summarizers.lex_rank.LexRankSummarizer._compute_idf", "type": "method", "project_path": "Internet/sumy", "completion_path": "Internet/sumy/sumy/summarizers/lex_rank.py", "signature_position": [78, 78], "body_position": [79, 88], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function computes the inverse document frequency (IDF) for each term in the sentences.", "Arguments": ":param sentences: List of strings. The sentences to compute IDF.\n:return: Dictionary. The IDF metrics for each term in the sentences."}, "tests": ["tests/test_summarizers/test_lex_rank.py::test_idf_metrics"], "indent": 8}
{"namespace": "sumy.summarizers.lex_rank.LexRankSummarizer.cosine_similarity", "type": "method", "project_path": "Internet/sumy", "completion_path": "Internet/sumy/sumy/summarizers/lex_rank.py", "signature_position": [119, 119], "body_position": [142, 156], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Compute the cosine similarity between two sentences based on the TF*IDF metrics. It calculates the cosine similarity of two sentences represented as vectors A and B, computed as cos(x, y) = A . B / (|A| . |B|).", "Arguments": ":param sentence1: Iterable object. Every item represents a word of the 1st sentence.\n:param sentence2: Iterable object. Every item represents a word of the 2nd sentence.\n:param tf1: Dict. Term frequencies of words from the 1st sentence.\n:param tf2: Dict. Term frequencies of words from the 2nd sentence.\n:param idf_metrics: Dict. Inverted document metrics of the sentences. Every sentence is treated as a document for this algorithm.\n:return: Float. Returns -1.0 for opposite similarity, 1.0 for the same sentence, and zero for no similarity between sentences."}, "tests": ["tests/test_summarizers/test_lex_rank.py::test_cosine_similarity_for_the_same_sentence_with_duplicate_words_should_be_one", "tests/test_summarizers/test_lex_rank.py::test_cosine_similarity_sentences_with_no_common_word_should_be_zero"], "indent": 8}
{"namespace": "sumy.evaluation.rouge._get_ngrams", "type": "function", "project_path": "Internet/sumy", "completion_path": "Internet/sumy/sumy/evaluation/rouge.py", "signature_position": [9, 9], "body_position": [10, 15], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function generates n-grams from the given text.", "Arguments": ":param n: Integer. The size of the n-grams.\n:param text: String. The input text from which n-grams are generated.\n:return: Set. A set of n-grams generated from the input text."}, "tests": ["tests/test_evaluation/test_evaluation_rouge.py::test_get_ngrams"], "indent": 4}
{"namespace": "sumy.evaluation.rouge._split_into_words", "type": "function", "project_path": "Internet/sumy", "completion_path": "Internet/sumy/sumy/evaluation/rouge.py", "signature_position": [18, 18], "body_position": [19, 24], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function splits the input sentences into words and returns a list of words. If there exists a element in the input sentences that is not a Sentence instance, it raises a ValueError(\"Object in collection must be of type Sentence\").", "Arguments": ":param sentences: List of Sentence instances. The input sentences to be split into words.\n:return: List of String. The list of words obtained after splitting the sentences."}, "tests": ["tests/test_evaluation/test_evaluation_rouge.py::test_split_into_words"], "indent": 4}
{"namespace": "falcon.inspect.register_router", "type": "function", "project_path": "Internet/falcon", "completion_path": "Internet/falcon/falcon/inspect.py", "signature_position": [71, 71], "body_position": [89, 98], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a decorator that registers a new function for a custom router class. It takes the router class as input and returns a new function that can be used to inspect the router. If the router class is already registered, raise a ValueError.", "Arguments": ":param router_class: Type. The router class to register. If already registered, an error will be raised.\n:return: The new function that inspects the router."}, "tests": ["tests/test_inspect.py::TestRouter::test_register_other_router", "tests/test_inspect.py::TestRouter::test_register_router_multiple_time"], "indent": 4}
{"namespace": "falcon.inspect.inspect_compiled_router", "type": "function", "project_path": "Internet/falcon", "completion_path": "Internet/falcon/falcon/inspect.py", "signature_position": [204, 204], "body_position": [216, 245], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function inspects a compiled router to return a list of defined routes. It walks through the compiled router and extracts information about the defined routes.", "Arguments": ":param router: CompiledRouter. The router to inspect.\n:return: List[RouteInfo]. A list of RouteInfo objects representing the defined routes."}, "tests": ["tests/test_inspect.py::TestRouter::test_compiled_partial", "tests/test_inspect.py::TestRouter::test_compiled_no_method_map"], "indent": 4}
{"namespace": "falcon.inspect._is_internal", "type": "function", "project_path": "Internet/falcon", "completion_path": "Internet/falcon/falcon/inspect.py", "signature_position": [787, 787], "body_position": [789, 792], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if the module of the object is a falcon module.", "Arguments": ":param obj: Object. The object to be checked.\n:return: Bool. True if the module of the object is a falcon module, False otherwise."}, "tests": ["tests/test_inspect.py::test_is_internal"], "indent": 4}
{"namespace": "falcon.cmd.inspect_app.load_app", "type": "function", "project_path": "Internet/falcon", "completion_path": "Internet/falcon/falcon/cmd/inspect_app.py", "signature_position": [61, 62], "body_position": [63, 86], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function loads the app based on the given parser and args. It first splits the app_module into module and instance. Then, it tries to get the app instance from the module. If the app is not an instance of falcon.App, it tries to create an instance from the callable app. If the app is still not an instance of falcon.App, it raises an error.", "Arguments": ":param parser: The parser object.\n:param args: The arguments object.\n:return: falcon.App. The loaded falcon app instance."}, "tests": ["tests/test_cmd_inspect_app.py::TestLoadApp::test_load_app_module_error", "tests/test_cmd_inspect_app.py::TestLoadApp::test_load_app", "tests/test_cmd_inspect_app.py::TestLoadApp::test_load_app_error"], "indent": 4}
{"namespace": "falcon.cmd.inspect_app.make_parser", "type": "function", "project_path": "Internet/falcon", "completion_path": "Internet/falcon/falcon/cmd/inspect_app.py", "signature_position": [31, 31], "body_position": [33, 58], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Create a parser for the application with the specified arguments and options. The arguments contains \"-r (--router)\", \"-v (--verbose)\", \"-i (--internal)\", and \"app_module\".", "Arguments": ":param: No input parameters.\n:return: ArgumentParser. The created parser instance."}, "tests": ["tests/test_cmd_inspect_app.py::TestLoadApp::test_load_app_module_error", "tests/test_cmd_inspect_app.py::TestMakeParser::test_make_parser_error", "tests/test_cmd_inspect_app.py::TestMakeParser::test_make_parser", "tests/test_cmd_inspect_app.py::TestLoadApp::test_load_app_error"], "indent": 4}
{"namespace": "falcon.util.uri.unquote_string", "type": "function", "project_path": "Internet/falcon", "completion_path": "Internet/falcon/falcon/util/uri.py", "signature_position": [505, 505], "body_position": [518, 534], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function unquotes an RFC 7320 \"quoted-string\" by removing the quotes and escaping characters.", "Arguments": ":param quoted: str. Original quoted string.\n:return: str. Unquoted string.\n:raises: TypeError: If the input is not a string."}, "tests": ["tests/test_utils.py::TestFalconUtils::test_unquote_string"], "indent": 4}
{"namespace": "falcon.util.misc.get_argnames", "type": "function", "project_path": "Internet/falcon", "completion_path": "Internet/falcon/falcon/util/misc.py", "signature_position": [287, 287], "body_position": [298, 313], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function introspects the arguments of a callable and returns a list of argument names, excluding *arg and **kwargs arguments.", "Arguments": ":param func: The callable to introspect.\n:return: A list of argument names, excluding *arg and **kwargs arguments."}, "tests": ["tests/test_utils.py::test_get_argnames"], "indent": 4}
{"namespace": "falcon.testing.client._is_asgi_app", "type": "function", "project_path": "Internet/falcon", "completion_path": "Internet/falcon/falcon/testing/client.py", "signature_position": [2161, 2161], "body_position": [2162, 2173], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if the given app is an ASGI app by inspecting the number of arguments it accepts. If the number of arguments is 3, it is considered an ASGI app. The \"self\" and \"cls\" arguments are ignored.", "Arguments": ":param app: The app to be checked.\n:return: Boolean. True if the app is an ASGI app, False otherwise."}, "tests": ["tests/asgi/test_testing_asgi.py::test_is_asgi_app_cls"], "indent": 4}
{"namespace": "falcon.routing.converters.UUIDConverter.convert", "type": "method", "project_path": "Internet/falcon", "completion_path": "Internet/falcon/falcon/routing/converters.py", "signature_position": [128, 128], "body_position": [129, 132], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the input value to a UUID. If the input value is not a valid UUID, return None.", "Arguments": ":param self: UUIDConverter. An instance of the UUIDConverter class.\n:param value: The value to be converted to a UUID.\n:return: UUID. The UUID value if the input is a valid UUID, otherwise None."}, "tests": ["tests/test_uri_converters.py::test_uuid_converter"], "indent": 8}
{"namespace": "rest_framework_simplejwt.utils.make_utc", "type": "function", "project_path": "Internet/djangorestframework-simplejwt", "completion_path": "Internet/djangorestframework-simplejwt/rest_framework_simplejwt/utils.py", "signature_position": [18, 18], "body_position": [19, 22], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "The function converts a naive datetime object to a UTC-aware datetime object if the USE_TZ setting is enabled.", "Arguments": ":param dt: datetime. The datetime object to be converted to UTC.\n:return: datetime. The UTC-aware datetime object."}, "tests": ["tests/test_utils.py::TestDatetimeFromEpoch::test_it_should_return_the_correct_values", "tests/test_utils.py::TestMakeUtc::test_it_should_return_the_correct_values"], "indent": 4}
{"namespace": "boto.sdb.db.sequence.fib", "type": "function", "project_path": "Internet/boto", "completion_path": "Internet/boto/boto/sdb/db/sequence.py", "signature_position": [91, 91], "body_position": [94, 98], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calculates the next number in the Fibonacci sequence based on the last two numbers.", "Arguments": ":param cv: int. The current value in the sequence. Defaults to 1.\n:param lv: int. The last value in the sequence. Defaults to 0.\n:return: int. The next number in the Fibonacci sequence."}, "tests": ["tests/db/test_sequence.py::TestDBHandler::test_fib"], "indent": 4}
{"namespace": "boto.s3.website.RoutingRules.add_rule", "type": "method", "project_path": "Internet/boto", "completion_path": "Internet/boto/boto/s3/website.py", "signature_position": [142, 142], "body_position": [152, 153], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Add a routing rule to the RoutingRules object and return the updated object. This function allows chaining of subsequent calls.", "Arguments": ":param rule: RoutingRule. A routing rule to be added.\n:return: RoutingRules. The updated RoutingRules object."}, "tests": ["tests/unit/s3/test_website.py::TestS3WebsiteConfiguration::test_routing_rules_to_host_on_404", "tests/unit/s3/test_website.py::TestS3WebsiteConfiguration::test_routing_rules_key_prefix", "tests/unit/s3/test_website.py::TestS3WebsiteConfiguration::test_key_prefix", "tests/unit/s3/test_website.py::TestS3WebsiteConfiguration::test_builders"], "indent": 8}
{"namespace": "boto.cloudfront.distribution.Distribution._canned_policy", "type": "method", "project_path": "Internet/boto", "completion_path": "Internet/boto/boto/cloudfront/distribution.py", "signature_position": [617, 617], "body_position": [621, 624], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function creates a canned policy string based on the given resource and expiration time '{\"Statement\":[{\"Resource\":\"%(resource)s\",\"Condition\":{\"DateLessThan\":{\"AWS:EpochTime\":%(expires)s}}}]}'.", "Arguments": ":param resource: String. The resource for which the policy is created.\n:param expires: String. The expiration time for the policy.\n:return: String. The created canned policy string."}, "tests": ["tests/unit/cloudfront/test_signed_urls.py::CloudfrontSignedUrlsTest::test_create_canned_policy"], "indent": 8}
{"namespace": "boto.cloudfront.invalidation.InvalidationBatch.escape", "type": "method", "project_path": "Internet/boto", "completion_path": "Internet/boto/boto/cloudfront/invalidation.py", "signature_position": [70, 70], "body_position": [72, 74], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function escapes a path. It prepends a slash if it does not start with one and then escapes the path but retaining '/' and '*'.", "Arguments": ":param self: InvalidationBatch. An instance of the InvalidationBatch class.\n:param p: str. The path to escape.\n:return: str. The escaped path."}, "tests": ["tests/unit/cloudfront/test_invalidation.py::CFInvalidationTest::test_wildcard_escape"], "indent": 8}
{"namespace": "proxybroker.utils.get_status_code", "type": "function", "project_path": "Internet/proxybroker", "completion_path": "Internet/proxybroker/proxybroker/utils.py", "signature_position": [59, 59], "body_position": [60, 65], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function extracts the status code from the response string and returns it. If the status code is not found, it returns 400.", "Arguments": ":param resp: String. The response string from which the status code is to be extracted.\n:param start: Integer. The starting index of the status code in the response string. Defaults to 9.\n:param stop: Integer. The ending index of the status code in the response string. Defaults to 12.\n:return: Integer. The extracted status code or 400 if not found."}, "tests": ["tests/test_utils.py::test_get_status_code"], "indent": 4}
{"namespace": "authlib.oauth2.rfc6749.util.scope_to_list", "type": "function", "project_path": "Internet/Authlib", "completion_path": "Internet/Authlib/authlib/oauth2/rfc6749/util.py", "signature_position": [15, 15], "body_position": [17, 21], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert a space separated string to a list of scopes. It checks if the input is a tuple, list, or set and converts each element to a unicode string. If the input is None, it returns None. Otherwise, it splits the input string by space and returns the list of scopes.", "Arguments": ":param scope: The space separated string of scopes or a tuple, list, or set of scopes or None.\n:return: list[str] or None. The list of scopes. If the input is None, it returns None."}, "tests": ["tests/core/test_oauth2/test_rfc6749_misc.py::OAuth2UtilTest::test_scope_to_list"], "indent": 4}
{"namespace": "authlib.common.encoding.to_unicode", "type": "function", "project_path": "Internet/Authlib", "completion_path": "Internet/Authlib/authlib/common/encoding.py", "signature_position": [18, 18], "body_position": [19, 23], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the input to a string. It first checks if the input is None or already a string, and returns it. If the input is a byte string, it decodes it using the specified charset and error handling. Otherwise, it converts the input to a string using the str() function.", "Arguments": ":param x: Any. The input to be converted to Unicode.\n:param charset: String. The character set to be used for decoding byte strings. Defaults to 'utf-8'.\n:param errors: String. The error handling scheme to be used for decoding byte strings. Defaults to 'strict'.\n:return: String. The Unicode representation of the input."}, "tests": ["tests/jose/test_jwe.py::JWETest::test_deserialize_json_fails_if_protected_header_contains_unknown_field_while_private_fields_restricted"], "indent": 4}
{"namespace": "authlib.common.encoding.to_bytes", "type": "function", "project_path": "Internet/Authlib", "completion_path": "Internet/Authlib/authlib/common/encoding.py", "signature_position": [6, 6], "body_position": [7, 15], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the input to bytes based on the given charset and error handling. It first checks if the input is None, bytes, string, int, or float and then converts it to bytes accordingly.", "Arguments": ":param x: Any. The input to be converted to bytes.\n:param charset: String. The character set to be used for encoding. Defaults to 'utf-8'.\n:param errors: String. The error handling scheme to be used. Defaults to 'strict'.\n:return: Bytes. The converted bytes. Or None if the input is None."}, "tests": ["tests/jose/test_ecdh_1pu.py::ECDH1PUTest::test_ecdh_1pu_key_agreement_computation_appx_b", "tests/jose/test_ecdh_1pu.py::ECDH1PUTest::test_ecdh_1pu_encryption_with_json_serialization", "tests/jose/test_jwe.py::JWETest::test_deserialize_json_fails_if_protected_header_contains_unknown_field_while_private_fields_restricted"], "indent": 4}
{"namespace": "authlib.common.encoding.urlsafe_b64decode", "type": "function", "project_path": "Internet/Authlib", "completion_path": "Internet/Authlib/authlib/common/encoding.py", "signature_position": [40, 40], "body_position": [41, 42], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Decode the URL-safe base64-encoded string. It pads the input string with '=' until the length is a multiple of 4 before decoding it.", "Arguments": ":param s: bytes. The URL-safe base64-encoded string to be decoded.\n:return: bytes. The decoded string."}, "tests": ["tests/jose/test_ecdh_1pu.py::ECDH1PUTest::test_ecdh_1pu_encryption_with_json_serialization"], "indent": 4}
{"namespace": "csvs_to_sqlite.utils.table_exists", "type": "function", "project_path": "Database/csvs-to-sqlite", "completion_path": "Database/csvs-to-sqlite/csvs_to_sqlite/utils.py", "signature_position": [257, 257], "body_position": [258, 264], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the table exists in the database.", "Arguments": ":param conn: Connection. The connection to the database.\n:param table: String. The name of the table to check.\n:return: Bool. True if the table exists, False otherwise."}, "tests": ["tests/test_utils.py::test_table_exists"], "indent": 4}
{"namespace": "sqlitedict.SqliteDict.get_tablenames", "type": "method", "project_path": "Database/sqlitedict", "completion_path": "Database/sqlitedict/sqlitedict.py", "signature_position": [359, 359], "body_position": [361, 368], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function retrieves the names of the tables in an SQLite database and returns them as a list. If the file does not exist, it raises an IOError 'file {} does not exist'.", "Arguments": ":param filename: String. The name of the SQLite database file.\n:return: List of strings. The names of the tables in the SQLite database."}, "tests": ["tests/test_core.py::TablenamesTest::test_tablenams_named", "tests/test_core.py::NamedSqliteDictCreateOrReuseTest::test_readonly_table", "tests/test_core.py::TablenamesTest::test_tablenames_unnamed"], "indent": 8}
{"namespace": "litecli.packages.parseutils.query_starts_with", "type": "function", "project_path": "Database/litecli", "completion_path": "Database/litecli/litecli/packages/parseutils.py", "signature_position": [204, 204], "body_position": [206, 208], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the query starts with any item from the given list of prefixes. It first converts all the prefixes to lowercase and then formats the query to lowercase and removes comments. It then checks if the formatted query is not empty and if the first word of the query is in the list of prefixes.", "Arguments": ":param query: String. The input query to be checked.\n:param prefixes: List of strings. The list of prefixes to check if the query starts with.\n:return: Bool. True if the query starts with any item from the prefixes, False otherwise."}, "tests": ["tests/test_parseutils.py::test_query_starts_with_comment", "tests/test_parseutils.py::test_query_starts_with"], "indent": 4}
{"namespace": "rest_framework.negotiation.DefaultContentNegotiation.filter_renderers", "type": "method", "project_path": "Internet/djangorestframework", "completion_path": "Internet/djangorestframework/rest_framework/negotiation.py", "signature_position": [80, 80], "body_position": [85, 89], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function filters the renderers based on the given format. It only keeps the renderers that accept the given format. If no renderer is found, it raises 404.", "Arguments": ":param renderers: List of Renderer. The list of renderers to be filtered.\n:param format: String. The format to be used for filtering the renderers.\n:return: List of Renderer. The filtered list of renderers."}, "tests": ["tests/test_negotiation.py::TestAcceptedMediaType::test_raise_error_if_no_suitable_renderers_found"], "indent": 8}
{"namespace": "rest_framework.templatetags.rest_framework.as_string", "type": "function", "project_path": "Internet/djangorestframework", "completion_path": "Internet/djangorestframework/rest_framework/templatetags/rest_framework.py", "signature_position": [159, 159], "body_position": [160, 162], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the input value to a string. If the input value is None, it returns an empty string.", "Arguments": ":param value: Any. The input value to be converted to a string.\n:return: String. The converted string value."}, "tests": ["tests/test_templatetags.py::TemplateTagTests::test_as_string_with_none"], "indent": 4}
{"namespace": "rest_framework.templatetags.rest_framework.add_nested_class", "type": "function", "project_path": "Internet/djangorestframework", "completion_path": "Internet/djangorestframework/rest_framework/templatetags/rest_framework.py", "signature_position": [286, 286], "body_position": [287, 291], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "The function checks if the input value is a dictionary or a list containing a dictionary or a list. If it is, it returns 'class=nested', otherwise, it returns an empty string.", "Arguments": ":param value: Any. The input value to be checked.\n:return: String. It returns 'class=nested' if the input value is a dictionary or a list containing a dictionary or a list. Otherwise, it returns an empty string."}, "tests": ["tests/test_templatetags.py::TemplateTagTests::test_add_nested_class"], "indent": 4}
{"namespace": "pyramid.session.PickleSerializer.loads", "type": "method", "project_path": "Internet/pyramid", "completion_path": "Internet/pyramid/src/pyramid/session.py", "signature_position": [67, 67], "body_position": [69, 74], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Deserialize a byte stream to a Python object using the pickle module. It raises a ValueError if there is any exception.", "Arguments": ":param self: PickleSerializer. An instance of the PickleSerializer class.\n:param bstruct: Bytes. The byte stream to be deserialized.\n:return: Python object. The deserialized Python object."}, "tests": ["tests/test_session.py::TestPickleSerializer::test_loads", "tests/test_session.py::TestPickleSerializer::test_loads_raises_ValueError_on_invalid_data", "tests/test_session.py::TestPickleSerializer::test_loads_raises_ValueError_on_bad_import"], "indent": 8}
{"namespace": "pyramid.testing.DummySession.flash", "type": "method", "project_path": "Internet/pyramid", "completion_path": "Internet/pyramid/src/pyramid/testing.py", "signature_position": [247, 247], "body_position": [248, 250], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function adds a message to the flash storage. It first checks if the message is already in the storage and if it is not, it appends the message to the storage.", "Arguments": ":param self: DummySession. An instance of the DummySession class.\n:param msg: The message to be added to the flash storage.\n:param queue: String. The queue to which the message is added. Defaults to an empty string.\n:param allow_duplicate: Bool. Whether to allow duplicate messages in the storage. Defaults to True.\n:return: No return values."}, "tests": ["tests/test_testing.py::TestDummySession::test_flash_mixed", "tests/test_testing.py::TestDummySession::test_flash_default"], "indent": 8}
{"namespace": "pyramid.testing.DummySession.pop_flash", "type": "method", "project_path": "Internet/pyramid", "completion_path": "Internet/pyramid/src/pyramid/testing.py", "signature_position": [252, 252], "body_position": [253, 254], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function removes and returns the flash message from the session storage. It removes the flash message from the session storage based on the queue and returns it.", "Arguments": ":param self: DummySession. An instance of the DummySession class.\n:param queue: String. The queue from which the flash message is to be removed. Defaults to an empty string.\n:return: List. The flash message storage."}, "tests": ["tests/test_testing.py::TestDummySession::test_pop_flash_nodefault_queue", "tests/test_testing.py::TestDummySession::test_pop_flash_default_queue"], "indent": 8}
{"namespace": "pyramid.testing.DummySession.peek_flash", "type": "method", "project_path": "Internet/pyramid", "completion_path": "Internet/pyramid/src/pyramid/testing.py", "signature_position": [256, 256], "body_position": [257, 258], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Return the flash messages from the session storage without removing them.", "Arguments": ":param self: DummySession. An instance of the DummySession class.\n:param queue: String. The queue name to retrieve the flash messages from. Defaults to an empty string.\n:return: List. The list of flash messages from the session storage."}, "tests": ["tests/test_testing.py::TestDummySession::test_peek_flash_default_queue", "tests/test_testing.py::TestDummySession::test_peek_flash_nodefault_queue"], "indent": 8}
{"namespace": "pyramid.testing.DummySession.new_csrf_token", "type": "method", "project_path": "Internet/pyramid", "completion_path": "Internet/pyramid/src/pyramid/testing.py", "signature_position": [260, 260], "body_position": [261, 263], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Generate a new CSRF token '0123456789012345678901234567890123456789' and store it in the DummySession instance. It then returns the generated token.", "Arguments": ":param self: DummySession. An instance of the DummySession class.\n:return: String. The generated CSRF token."}, "tests": ["tests/test_testing.py::TestDummySession::test_new_csrf_token"], "indent": 8}
{"namespace": "pyramid.view.view_defaults", "type": "function", "project_path": "Internet/pyramid", "completion_path": "Internet/pyramid/src/pyramid/view.py", "signature_position": [264, 264], "body_position": [273, 277], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a decorator that, when applied to a class, provides defaults for all view configurations that use the class. It accepts all the arguments accepted by pyramid.view.view_config and each has the same meaning. The settings is stored in the `__view_defaults__` attribute.", "Arguments": ":param **settings: Arbitrary keyword arguments. The settings to be applied as defaults for all view configurations that use the class.\n:return: A decorator function that sets the defaults for all view configurations that use the class."}, "tests": ["tests/test_view.py::Test_view_defaults::test_it_inheritance_overriden", "tests/test_view.py::Test_view_defaults::test_it_inheritance_not_overridden", "tests/test_view.py::Test_view_defaults::test_it", "tests/test_view.py::Test_view_defaults::test_it_inheritance_overriden_empty"], "indent": 4}
{"namespace": "pyramid.util.bytes_", "type": "function", "project_path": "Internet/pyramid", "completion_path": "Internet/pyramid/src/pyramid/util.py", "signature_position": [38, 38], "body_position": [41, 43], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes a string and encodes it using the specified encoding and error handling. If the input is not a string, it returns the input as is.", "Arguments": ":param s: String. The input string to be encoded.\n:param encoding: String. The encoding to be used for encoding the input string. Defaults to 'latin-1'.\n:param errors: String. The error handling scheme to use for encoding errors. Defaults to 'strict'.\n:return: Bytes. The encoded bytes if the input is a string, otherwise the input itself."}, "tests": ["tests/test_authentication.py::TestBasicAuthAuthenticationPolicy::test_unauthenticated_userid_invalid_payload", "tests/test_authentication.py::TestBasicAuthAuthenticationPolicy::test_authenticated_userid", "tests/test_authentication.py::TestExtractHTTPBasicCredentials::test_not_a_basic_auth_scheme", "tests/test_authentication.py::TestExtractHTTPBasicCredentials::test_invalid_payload", "tests/test_authentication.py::TestBasicAuthAuthenticationPolicy::test_unauthenticated_userid"], "indent": 4}
{"namespace": "pyramid.scripts.common.parse_vars", "type": "function", "project_path": "Internet/pyramid", "completion_path": "Internet/pyramid/src/pyramid/scripts/common.py", "signature_position": [4, 4], "body_position": [9, 15], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes a list of strings in the format 'a=b' and turns it into a dictionary with keys and values.", "Arguments": ":param args: List of strings. The list of strings in the format 'a=b'.\n:return: Dictionary. The dictionary with keys and values."}, "tests": ["tests/test_scripts/test_common.py::TestParseVars::test_parse_vars_good", "tests/test_scripts/test_common.py::TestParseVars::test_parse_vars_bad"], "indent": 4}
{"namespace": "pyramid.scripts.pviews.PViewsCommand._find_multi_routes", "type": "method", "project_path": "Internet/pyramid", "completion_path": "Internet/pyramid/src/pyramid/scripts/pviews.py", "signature_position": [70, 70], "body_position": [71, 79], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function finds all routes that match the path of the given request, regardless of predicates. It iterates through all routes in the mapper and checks if the path matches the route. If it does, it adds the route and the match to the list of infos.", "Arguments": ":param self: PViewsCommand. An instance of the PViewsCommand class.\n:param mapper: The mapper object that contains routes.\n:param request: The request object that contains the path information.\n:return: A list of dictionaries, each containing the 'match' and the 'route' that matches the given path."}, "tests": ["tests/test_scripts/test_pviews.py::TestPViewsCommand::test__find_multi_routes_some_match", "tests/test_scripts/test_pviews.py::TestPViewsCommand::test__find_multi_routes_all_match", "tests/test_scripts/test_pviews.py::TestPViewsCommand::test__find_multi_routes_none_match"], "indent": 8}
{"namespace": "pyramid.scripts.pserve.PServeCommand.guess_server_url", "type": "method", "project_path": "Internet/pyramid", "completion_path": "Internet/pyramid/src/pyramid/scripts/pserve.py", "signature_position": [174, 174], "body_position": [175, 178], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "It guesses the server URL based on the given server name and global configuration. The function first sets server_name to 'main' if the server_name parameter is empty. Then it load the configuration for the specified server, which is 'server:' + server_name, using the global_conf. If the port number is specified in the settings, the function will return the URL of the server, which is 'http://127.0.0.1:{port}', with the port number replaced by the value in the settings.", "Arguments": ":param self: PServeCommand. An instance of the PServeCommand class.\n:param loader: The loader to get the settings.\n:param server_name: The name of the server. Defaults to 'main'.\n:param global_conf: The global configuration settings. Defaults to None.\n:return: String. The guessed server URL."}, "tests": ["tests/test_scripts/test_pserve.py::TestPServeCommand::test_guess_server_url"], "indent": 8}
{"namespace": "aiohappybase._util.pep8_to_camel_case", "type": "function", "project_path": "Database/happybase", "completion_path": "Database/happybase/aiohappybase/_util.py", "signature_position": [27, 27], "body_position": [29, 34], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert a PEP8 style name to camel case. It splits the input name by underscore and capitalizes each chunk. If the initial flag is set to True, it returns the whole name in camel case. Otherwise, it returns the name in camel case starting with a lowercase letter.", "Arguments": ":param name: String. The PEP8 style name to be converted to camel case.\n:param initial: Bool. Whether to capitalize the first letter of the camel case name. Defaults to False.\n:return: String. The name in camel case."}, "tests": ["tests/test_util.py::TestUtil::test_camel_case_to_pep8"], "indent": 4}
{"namespace": "aiohappybase._util.bytes_increment", "type": "function", "project_path": "Database/happybase", "completion_path": "Database/happybase/aiohappybase/_util.py", "signature_position": [61, 61], "body_position": [72, 78], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function increments and truncates a byte string for sorting purposes. It returns the shortest string that sorts after the given string when compared using regular string comparison semantics. It increments the last byte that is smaller than 0xFF and drops everything after it. If the input string only contains 0xFF bytes, None is returned.", "Arguments": ":param b: bytes. The byte string to be incremented and truncated.\n:return: Optional[bytes]. The incremented and truncated byte string. If the string only contains ``0xFF`` bytes, `None` is returned."}, "tests": ["tests/test_util.py::TestUtil::test_bytes_increment"], "indent": 4}
{"namespace": "mssqlcli.config.ensure_dir_exists", "type": "function", "project_path": "Database/mssql-cli", "completion_path": "Database/mssql-cli/mssqlcli/config.py", "signature_position": [29, 29], "body_position": [30, 32], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function ensures that the directory of the given path exists. If the parent directory of the path does not exist, it creates the directory.", "Arguments": ":param path: String. The path for which the directory existence needs to be ensured.\n:return: No return values."}, "tests": ["tests/test_config.py::ConfigTests::test_ensure_existing_dir"], "indent": 4}
{"namespace": "mssqlcli.telemetry._user_id_file_is_old", "type": "function", "project_path": "Database/mssql-cli", "completion_path": "Database/mssql-cli/mssqlcli/telemetry.py", "signature_position": [188, 188], "body_position": [189, 194], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the user id file is older than 24 hours. It compares the modified time of the file with the current time and returns True if the file is older than 24 hours, otherwise False.", "Arguments": ":param id_file_path: String. The path to the user id file.\n:return: Bool. True if the file is older than 24 hours, otherwise False."}, "tests": ["tests/test_telemetry.py::TelemetryTests::test_file_time_check_rotation"], "indent": 4}
{"namespace": "mssqlcli.util.is_command_valid", "type": "function", "project_path": "Database/mssql-cli", "completion_path": "Database/mssql-cli/mssqlcli/util.py", "signature_position": [21, 21], "body_position": [26, 36], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the command is recognized on the machine. It is used to determine the installation of the 'less' pager. If the command is empty or if calling the command silently throws an OSError, the function returns False. Otherwise, it returns True.", "Arguments": ":param command: String. The command to be checked.\n:return: Bool. True if the command is recognized, False otherwise."}, "tests": ["tests/test_interactive_mode.py::TestInteractiveModeRun::test_valid_command"], "indent": 4}
{"namespace": "mssqlcli.packages.parseutils.utils.find_prev_keyword", "type": "function", "project_path": "Database/mssql-cli", "completion_path": "Database/mssql-cli/mssqlcli/packages/parseutils/utils.py", "signature_position": [65, 65], "body_position": [71, 99], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function finds the last SQL keyword in an SQL statement and returns the value of the last keyword and the text of the query with everything after the last keyword stripped.", "Arguments": ":param sql: String. The SQL statement to be processed.\n:param n_skip: Integer. The number of tokens to skip from the end of the SQL statement. Defaults to 0.\n:return: Tuple. The value of the last keyword and the text of the query with everything after the last keyword stripped."}, "tests": ["tests/parseutils/test_parseutils.py::test_find_prev_keyword_using", "tests/parseutils/test_parseutils.py::test_find_prev_keyword_where", "tests/parseutils/test_parseutils.py::test_find_prev_keyword_open_parens"], "indent": 4}
{"namespace": "pyramid.util.text_", "type": "function", "project_path": "Internet/pyramid", "completion_path": "Internet/pyramid/src/pyramid/util.py", "signature_position": [30, 30], "body_position": [33, 35], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if the input string is an instance of bytes. If it is, it decodes the bytes using the specified encoding and error handling. If not, it returns the input string as is.", "Arguments": ":param s: String or bytes. The input string to be checked and decoded if it is an instance of bytes.\n:param encoding: String. The encoding to be used for decoding the bytes. Defaults to 'latin-1'.\n:param errors: String. The error handling scheme to be used for decoding. Defaults to 'strict'.\n:return: String. The decoded string if the input is bytes, otherwise the input string as is."}, "tests": ["tests/test_urldispatch.py::TestCompileRoute::test_generate_with_mixedtype_values", "tests/test_urldispatch.py::TestCompileRoute::test_pattern_generate_with_high_order_dynamic", "tests/test_urldispatch.py::TestCompileRoute::test_pattern_with_high_order_literal", "tests/test_urldispatch.py::TestCompileRoute::test_docs_sample_generate", "tests/test_urldispatch.py::TestCompileRoute::test_generate_with_string_remainder_and_unicode_replacement"], "indent": 4}
{"namespace": "datasette.filters.where_filters", "type": "function", "project_path": "Database/datasette", "completion_path": "Database/datasette/datasette/filters.py", "signature_position": [10, 11], "body_position": [12, 40], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "The function is used to handle the \"_where=\" parameter in a request. If the \"_where\" parameter is present in the request parameters, it checks if the user has permission to execute SQL. If no permission is granted, it raises a 403 error. If permission is granted, it adds the values of the \"_where\" parameter to the where_clauses list and generates a separate UI element for each value, which is added to the extra_wheres_for_ui list. Finally, it passes the where_clauses and extra_wheres_for_ui as arguments to the FilterArguments class and returns an inner function.", "Arguments": ":param request: The request object.\n:param database: The database object.\n:param datasette: The datasette object.\n:return: A nested function that processes the \"_where\" query parameter and returns the filter arguments."}, "tests": ["tests/test_filters.py::test_where_filters_from_request"], "indent": 4}
{"namespace": "datasette.utils.path_with_added_args", "type": "function", "project_path": "Database/datasette", "completion_path": "Database/datasette/datasette/utils/__init__.py", "signature_position": [273, 273], "body_position": [274, 286], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a new path with added arguments. It first checks if the path is provided, if not, it uses the request path. Then, it processes the input arguments and adds them to the path.", "Arguments": ":param request: The request object.\n:param args: Dictionary. The arguments to be added to the path.\n:param path: String. The path to which the arguments are to be added. Defaults to None.\n:return: String. The new path with added arguments."}, "tests": ["tests/test_utils.py::test_path_with_added_args"], "indent": 4}
{"namespace": "datasette.utils.path_with_replaced_args", "type": "function", "project_path": "Database/datasette", "completion_path": "Database/datasette/datasette/utils/__init__.py", "signature_position": [318, 318], "body_position": [319, 331], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function replaces the query string in the given path with the provided arguments and returns the updated path. It takes a request object and a list of arguments as input, and replaces specific parameters in the request path based on the list of arguments. It returns the modified path. If the list of arguments is a dictionary, it is converted to a list of tuples. The function iterates through the query string of the request and adds the tuples from the list of arguments to a new list if the key is not in the set of keys to be replaced. It then appends the keys with non-null values from the list of arguments to the new list. The new list is then converted back to a query string form. Finally, the query string is appended to the path and the final path is returned.", "Arguments": ":param request: The request object.\n:param args: Dictionary or list of tuples. The arguments to replace in the query string.\n:param path: String. The path to be updated. Defaults to None, in which case the path from the request object is used.\n:return: String. The updated path with replaced arguments."}, "tests": ["tests/test_utils.py::test_path_with_replaced_args"], "indent": 4}
{"namespace": "datasette.utils.format_bytes", "type": "function", "project_path": "Database/datasette", "completion_path": "Database/datasette/datasette/utils/__init__.py", "signature_position": [870, 870], "body_position": [871, 879], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the input bytes to the largest possible unit (\"bytes\", \"KB\", \"MB\", \"GB\", and \"TB\") and return the formatted string.", "Arguments": ":param bytes: int. The number of bytes to be converted.\n:return: str. The formatted string of the converted bytes."}, "tests": ["tests/test_utils.py::test_format_bytes"], "indent": 4}
{"namespace": "datasette.utils.actor_matches_allow", "type": "function", "project_path": "Database/datasette", "completion_path": "Database/datasette/datasette/utils/__init__.py", "signature_position": [1013, 1013], "body_position": [1014, 1036], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if the actor matches the allow condition. It returns True if the actor matches the allow condition, otherwise False.", "Arguments": ":param actor: Any. The actor to be checked against the allow condition.\n:param allow: Any. The allow condition to be checked against the actor.\n:return: Bool. True if the actor matches the allow condition, otherwise False."}, "tests": ["tests/test_utils.py::test_actor_matches_allow"], "indent": 4}
{"namespace": "datasette.utils.resolve_env_secrets", "type": "function", "project_path": "Database/datasette", "completion_path": "Database/datasette/datasette/utils/__init__.py", "signature_position": [1039, 1039], "body_position": [1041, 1054], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Create a copy of the input config that recursively replaces {\"$env\": \"NAME\"} with values from the environ. It also replaces {\"$file\": \"NAME\"} with the content of the file with the name \"NAME\".", "Arguments": ":param config: Dictionary or List. The input configuration to be resolved.\n:param environ: Dictionary. The environment dictionary containing the values to be replaced.\n:return: Dictionary or List. The resolved configuration."}, "tests": ["tests/test_utils.py::test_resolve_env_secrets"], "indent": 4}
{"namespace": "datasette.utils.display_actor", "type": "function", "project_path": "Database/datasette", "completion_path": "Database/datasette/datasette/utils/__init__.py", "signature_position": [1057, 1057], "body_position": [1058, 1061], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Display the actor information based on the given priority. It first checks if the actor has a display name, then a name, username, login, and id. If none of these are found, it returns the string representation of the actor.", "Arguments": ":param actor: Dictionary. The actor information.\n:return: String. The displayed actor information based on the priority."}, "tests": ["tests/test_utils.py::test_display_actor"], "indent": 4}
{"namespace": "datasette.utils.initial_path_for_datasette", "type": "function", "project_path": "Database/datasette", "completion_path": "Database/datasette/datasette/utils/__init__.py", "signature_position": [1076, 1076], "body_position": [1078, 1089], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the suggested path for opening the given Datasette instance based on the number of databases and tables it contains. It first checks the number of databases and if there is only one database, it returns the path to that database. If the database contains only one table, it returns the path to that table. If there are multiple databases, it returns the path to the instance.", "Arguments": ":param datasette: Datasette. The Datasette instance for which the path is to be suggested.\n:return: String. The suggested path for opening the Datasette instance."}, "tests": ["tests/test_utils.py::test_initial_path_for_datasette"], "indent": 4}
{"namespace": "datasette.utils.tilde_decode", "type": "function", "project_path": "Database/datasette", "completion_path": "Database/datasette/datasette/utils/__init__.py", "signature_position": [1176, 1176], "body_position": [1179, 1182], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Decode a tilde-encoded string to its original form. It first replaces the % symbol with a temporary string to avoid accidental decoding of %2f style sequences. Then, it decodes the tilde-encoded string and replaces the temporary string with %.", "Arguments": ":param s: String. The tilde-encoded string to be decoded.\n:return: String. The decoded string.\n```"}, "tests": ["tests/test_utils.py::test_tilde_encoding"], "indent": 4}
{"namespace": "datasette.utils.resolve_routes", "type": "function", "project_path": "Database/datasette", "completion_path": "Database/datasette/datasette/utils/__init__.py", "signature_position": [1185, 1185], "body_position": [1186, 1190], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function resolves the routes based on the given path. It iterates through the routes and returns the first match found.", "Arguments": ":param routes: List of tuples. A list of tuples containing regex and view.\n:param path: String. The path to be resolved.\n:return: Tuple. The first match and the corresponding view. If no match is found, it returns None."}, "tests": ["tests/test_routes.py::test_routes"], "indent": 4}
{"namespace": "datasette.utils.truncate_url", "type": "function", "project_path": "Database/datasette", "completion_path": "Database/datasette/datasette/utils/__init__.py", "signature_position": [1193, 1193], "body_position": [1194, 1200], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "The function is used to truncate a given URL to a specified length, adding ellipsis at the end if the URL is longer than the specified length. If the URL ends with a file extension and the extension length is between 1 and 4 characters without a slash, it truncates the URL to the specified length and adds ellipsis and the extension at the end. If the URL length is less than or equal to the specified length, it returns the entire URL.", "Arguments": ":param url: String. The URL to be truncated.\n:param length: Integer. The maximum length of the truncated URL.\n:return: String. The truncated URL. If the URL is shorter than the specified length, the original URL is returned."}, "tests": ["tests/test_utils.py::test_truncate_url"], "indent": 4}
{"namespace": "kinto.core.authorization.groupfinder", "type": "function", "project_path": "Internet/kinto", "completion_path": "Internet/kinto/kinto/core/authorization.py", "signature_position": [21, 21], "body_position": [26, 41], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function fetches principals from the permission backend for the specified `userid`. It checks if the permission backend is configured and if so, queries the permission backend only once per request and returns the principals.", "Arguments": ":param userid: The user id for which the principals are to be fetched.\n:param request: The request object.\n:return: List. The list of principals fetched from the permission backend. If the permission backend is not configured, an empty list is returned."}, "tests": ["tests/core/test_authorization.py::GroupFinderTest::test_uses_provided_id_if_no_prefixed_userid", "tests/core/test_authorization.py::GroupFinderTest::test_uses_prefixed_as_userid"], "indent": 4}
{"namespace": "kinto.core.utils.json.dumps", "type": "method", "project_path": "Internet/kinto", "completion_path": "Internet/kinto/kinto/core/utils.py", "signature_position": [35, 35], "body_position": [36, 37], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "The function is a custom serialization function that uses the rapidjson library to convert a Python object into a JSON string. It accepts one parameter v and optional keyword parameters kw, where the bytes_mode parameter is set to rapidjson.BM_NONE by default in the kw parameter. The function then calls the rapidjson.dumps method to perform JSON serialization and returns the resulting string.", "Arguments": ":param v: Object. Python object to be serialized.\n:param kw: Dict. Additional keyword arguments to be passed to the rapidjson.dumps function.\n:return: String. The JSON string corresponding to the Python object."}, "tests": ["tests/core/resource/test_pagination.py::PaginationTest::test_raises_bad_request_if_token_has_bad_data_structure", "tests/core/test_views_batch.py::BatchServiceTest::test_subrequests_body_are_json_serialized", "tests/core/test_views_batch.py::BatchServiceTest::test_subrequests_body_have_utf8_charset"], "indent": 8}
{"namespace": "kinto.core.utils.json.loads", "type": "method", "project_path": "Internet/kinto", "completion_path": "Internet/kinto/kinto/core/utils.py", "signature_position": [43, 43], "body_position": [44, 45], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function loads the given JSON string and returns the corresponding Python object. It sets the default number mode to \"rapidjson.NM_NATIVE\" if not specified.", "Arguments": ":param v: String. The JSON string to be loaded.\n:param kw: Dict. Additional keyword arguments to be passed to the rapidjson.loads function.\n:return: Object. The Python object corresponding to the JSON string."}, "tests": ["tests/core/resource/test_pagination.py::BuildPaginationTokenTest::test_sorting_handle_both_rules", "tests/core/resource/test_pagination.py::BuildPaginationTokenTest::test_multiple_sorting_keep_all", "tests/core/resource/test_pagination.py::BuildPaginationTokenTest::test_token_contains_current_offset", "tests/core/resource/test_pagination.py::BuildPaginationTokenTest::test_sorting_handle_ordering_direction", "tests/core/resource/test_pagination.py::BuildPaginationTokenTest::test_no_sorting_default_to_modified_field"], "indent": 8}
{"namespace": "kinto.core.utils.hmac_digest", "type": "function", "project_path": "Internet/kinto", "completion_path": "Internet/kinto/kinto/core/utils.py", "signature_position": [161, 161], "body_position": [163, 165], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "The function calculates the hexadecimal digest of a message using the HMAC-SHA256 algorithm. It takes a secret key, a message, and an optional encoding as parameters. The function returns the hash value represented in hexadecimal form. If the secret key is of string type, it is converted to bytes type.", "Arguments": ":param secret: String or bytes. The secret key used for generating the HMAC digest.\n:param message: String. The message for which the HMAC digest is to be generated.\n:param encoding: String. The encoding to be used for encoding the secret key and the message. Defaults to \"utf-8\".\n:return: String. The hex digest of the HMAC."}, "tests": ["tests/plugins/test_default_bucket.py::DefaultBucketViewTest::test_default_bucket_exists_and_has_user_id_fallback_to_hmac_secret", "tests/plugins/test_default_bucket.py::DefaultBucketViewTest::test_default_bucket_exists_and_has_user_id", "tests/core/test_utils.py::HmacDigestTest::test_supports_secret_as_bytes", "tests/plugins/test_accounts.py::AccountCreationTest::test_authentication_refresh_the_cache_each_time_we_authenticate", "tests/core/test_utils.py::HmacDigestTest::test_supports_secret_as_text"], "indent": 4}
{"namespace": "kinto.core.utils.current_service", "type": "function", "project_path": "Internet/kinto", "completion_path": "Internet/kinto/kinto/core/utils.py", "signature_position": [285, 285], "body_position": [291, 299], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a decorator that is used to get the Cornice service matching the specified request. If the request matches a route, it retrieves the Cornice services from the request's registry and returns the corresponding service based on the matching route pattern. If no matching service is found, it returns None.", "Arguments": ":param request: The request object.\n:return: The service or None if unmatched."}, "tests": ["tests/core/test_utils.py::CurrentServiceTest::test_current_service_returns_the_service_for_existing_patterns"], "indent": 4}
{"namespace": "kinto.core.utils.prefixed_principals", "type": "function", "project_path": "Internet/kinto", "completion_path": "Internet/kinto/kinto/core/utils.py", "signature_position": [328, 328], "body_position": [332, 344], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a list of principals with a prefixed user id. It first retrieves the list of principals from the request object. If the \"Authenticated\" principal is not in the list, it returns the original list of principals. Otherwise, it removes the unprefixed user id from the effective principals to avoid conflicts, and then adds the prefixed user id to the beginning of the list.", "Arguments": ":param request: Request. The request object containing the effective principals and the prefixed user id.\n:return: List. The list of principals with the prefixed user id."}, "tests": ["tests/core/test_utils.py::PrefixedPrincipalsTest::test_works_if_userid_is_not_in_principals", "tests/core/test_utils.py::PrefixedPrincipalsTest::test_removes_unprefixed_from_principals"], "indent": 4}
{"namespace": "kinto.plugins.accounts.views.on_account_created", "type": "function", "project_path": "Internet/kinto", "completion_path": "Internet/kinto/kinto/plugins/accounts/views/__init__.py", "signature_position": [176, 176], "body_position": [177, 190], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is called when an account is created. It checks if the account validation is enabled in the settings. If it is enabled, the function proceeds to iterate through each impacted object in the event. For each impacted object, it retrieves the account information, which includes the user email, and an activation key. If the activation key is not found (i.e., it is None), the function skips to the next impacted object. Otherwise, the function sends an email to the user using the Emailer class, passing the request object and the account information as arguments to the send_activation method. The email contains a link for the user to activate their account.", "Arguments": ":param event: The event object containing the request and impacted objects.\n:return: No return values."}, "tests": ["tests/plugins/test_accounts.py::AccountValidationCreationTest::test_user_creation_listener"], "indent": 4}
{"namespace": "kinto.plugins.accounts.utils.hash_password", "type": "function", "project_path": "Internet/kinto", "completion_path": "Internet/kinto/kinto/plugins/accounts/utils.py", "signature_position": [13, 15], "body_position": [16, 18], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes a password as input, hashes it using bcrypt, and returns the hashed password as a string.", "Arguments": ":param password: String. The password to be hashed.\n:return: String. The hashed password."}, "tests": ["tests/plugins/test_accounts.py::AccountValidationCreationTest::test_previously_created_accounts_can_still_authenticate"], "indent": 4}
{"namespace": "kinto.views.admin.get_parent_uri", "type": "function", "project_path": "Internet/kinto", "completion_path": "Internet/kinto/kinto/views/admin.py", "signature_position": [44, 44], "body_position": [52, 58], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a function that retrieves the parent URI of an object's URI. It achieves universality by performing string operations on the URI, rather than attempting to parse the URI, identify the parent resource, and generate a new URI. It obtains the parent URI by splitting it by \"/\". If the path length is less than 3, an empty string is returned. Otherwise, return the first element of the path as the parent URI.", "Arguments": ":param object_uri: String. The URI of the object.\n:return: String. The parent URI for the object URI. If the object URI does not conform to the URL scheme, an empty string is returned."}, "tests": ["tests/test_views_admin.py::GetParentUriTest::test_parent_uri_behaves_sensibly_for_unknown_resources", "tests/test_views_admin.py::GetParentUriTest::test_parent_uri_accepts_pathological_urls"], "indent": 4}
{"namespace": "alembic.script.write_hooks.register", "type": "function", "project_path": "Database/alembic", "completion_path": "Database/alembic/alembic/script/write_hooks.py", "signature_position": [23, 23], "body_position": [35, 39], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a function decorator that registers the function as a write hook. It adds the function to the registry with the given name.", "Arguments": ":param name: String. The name to register the function with.\n:return: Callable. A callable function that registers the input function."}, "tests": ["tests/test_post_write.py::RunHookTest::test_generic", "tests/test_post_write.py::HookTest::test_invoke", "tests/test_post_write.py::HookTest::test_register"], "indent": 4}
{"namespace": "mongo_connector.namespace_config.match_replace_regex", "type": "function", "project_path": "Database/mongo-doc-manager", "completion_path": "Database/mongo-doc-manager/mongo_connector/namespace_config.py", "signature_position": [546, 546], "body_position": [549, 552], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if the source namespace matches the given regex. If it does, it returns the new mapped namespace by replacing the wildcard character '*' with the corresponding group from the match.", "Arguments": ":param regex: Regular expression. The regular expression pattern to match the source namespace.\n:param src_namespace: String. The source namespace to be matched.\n:param dest_namespace: String. The destination namespace to be replaced.\n:return: String. The new mapped namespace if the source namespace matches the regex, otherwise None."}, "tests": ["tests/test_namespace_config.py::TestNamespaceConfig::test_match_replace_regex"], "indent": 4}
{"namespace": "mongo_connector.namespace_config.namespace_to_regex", "type": "function", "project_path": "Database/mongo-doc-manager", "completion_path": "Database/mongo-doc-manager/mongo_connector/namespace_config.py", "signature_position": [560, 560], "body_position": [562, 567], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Create a regular expression object from a wildcard namespace. It first splits the namespace into database and collection names. Then, it creates a regular expression for the database and collection names and compiles them into a single regular expression object.", "Arguments": ":param namespace: String. The wildcard namespace to be converted into a regular expression.\n:return: RegexObject. The compiled regular expression object."}, "tests": ["tests/test_namespace_config.py::TestNamespaceConfig::test_namespace_to_regex_escapes_metacharacters", "tests/test_namespace_config.py::TestNamespaceConfig::test_namespace_to_regex"], "indent": 4}
{"namespace": "mongo_connector.util.long_to_bson_ts", "type": "function", "project_path": "Database/mongo-doc-manager", "completion_path": "Database/mongo-doc-manager/mongo_connector/util.py", "signature_position": [60, 60], "body_position": [63, 66], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Converts an integer into a BSON timestamp. The resulting BSON timestamp is a combination of the time (in seconds) and an incrementor, both extracted from the 64-bit integer.", "Arguments": ":param val: Integer. The value to be converted into a BSON timestamp.\n:return: Timestamp. The BSON timestamp created from the input value."}, "tests": ["tests/test_util.py::TestUtil::test_bson_ts_to_long"], "indent": 4}
{"namespace": "mongo_connector.doc_managers.formatters.DocumentFlattener.format_document", "type": "method", "project_path": "Database/mongo-doc-manager", "completion_path": "Database/mongo-doc-manager/mongo_connector/doc_managers/formatters.py", "signature_position": [150, 150], "body_position": [151, 170], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function flattens the given document and returns a dictionary with the flattened keys and values. It uses a recursive approach to flatten the document. For example, given a dictionary {\"a\": 2, \"b\": {\"c\": {\"d\": 5}}, \"e\": [6, 7, 8]}, it would output {\"a\": 2, \"b.c.d\": 5, \"e.0\": 6, \"e.1\": 7, \"e.2\": 8}.", "Arguments": ":param self: DocumentFlattener. An instance of the DocumentFlattener class.\n:param document: Dictionary. The document to be flattened.\n:return: Dictionary. The flattened document."}, "tests": ["tests/test_formatters.py::TestFormatters::test_flattener"], "indent": 8}
{"namespace": "bplustree.memory.open_file_in_dir", "type": "function", "project_path": "Database/bplustree", "completion_path": "Database/bplustree/bplustree/memory.py", "signature_position": [23, 23], "body_position": [32, 49], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function opens a file and its directory. The file is opened in binary mode and created if it does not exist. Both file descriptors must be closed after use to prevent them from leaking. On Windows, the directory is not opened, as it is useless.", "Arguments": ":param path: String. The path of the file to be opened.\n:return: Tuple[io.FileIO, Optional[int]]. The file descriptor and directory descriptor."}, "tests": ["tests/test_memory.py::test_open_file_in_dir_windows", "tests/test_memory.py::test_open_file_in_dir"], "indent": 4}
{"namespace": "bplustree.memory.FileMemory.read_transaction", "type": "method", "project_path": "Database/bplustree", "completion_path": "Database/bplustree/bplustree/memory.py", "signature_position": [167, 168], "body_position": [169, 177], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function creates a read transaction for the FileMemory instance. When the transaction begins ( __enter__ method), it acquires a reader lock, ensuring thread-safe read access to a shared resource. Upon completion or exit of the transaction ( __exit__ method), it releases this reader lock.", "Arguments": ":param self: FileMemory. An instance of the FileMemory class.\n:return: ReadTransaction. The created ReadTransaction instance."}, "tests": ["tests/test_memory.py::test_file_memory_write_transaction"], "indent": 8}
{"namespace": "bplustree.utils.pairwise", "type": "function", "project_path": "Database/bplustree", "completion_path": "Database/bplustree/bplustree/utils.py", "signature_position": [5, 5], "body_position": [10, 12], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function iterates over elements two by two in the given iterable.", "Arguments": ":param iterable: Iterable. The input iterable to iterate over.\n:return: Zip. The pairs of elements in the iterable."}, "tests": ["tests/test_utils.py::test_pairwise"], "indent": 4}
{"namespace": "bplustree.utils.iter_slice", "type": "function", "project_path": "Database/bplustree", "completion_path": "Database/bplustree/bplustree/utils.py", "signature_position": [15, 15], "body_position": [20, 31], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function yields slices of the given size from the input iterable and indicates if each slice is the last one.", "Arguments": ":param iterable: bytes. The input iterable to be sliced.\n:param n: int. The size of each slice.\n:return: Yields a tuple containing the slice and a boolean indicating if it is the last slice."}, "tests": ["tests/test_utils.py::test_iter_slice"], "indent": 4}
{"namespace": "bplustree.serializer.StrSerializer.serialize", "type": "method", "project_path": "Database/bplustree", "completion_path": "Database/bplustree/bplustree/serializer.py", "signature_position": [44, 44], "body_position": [45, 47], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Serialize the input string to bytes using the UTF-8 encoding and assert if the length of the bytes is less than or equal to the specified key size.", "Arguments": ":param self: StrSerializer. An instance of the StrSerializer class.\n:param obj: String. The input string to be serialized.\n:param key_size: Integer. The maximum size of the serialized bytes.\n:return: Bytes. The serialized bytes of the input string."}, "tests": ["tests/test_serializer.py::test_str_serializer"], "indent": 8}
{"namespace": "psd_tools.utils.pack", "type": "function", "project_path": "Multimedia/psd-tools", "completion_path": "Multimedia/psd-tools/src/psd_tools/utils.py", "signature_position": [18, 18], "body_position": [19, 20], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function packs the input arguments into a binary string according to the given format like \">{format}\".", "Arguments": ":param fmt: String. The format string that specifies the format of the returned string.\n:param *args: Tuple. The input arguments to be packed.\n:return: Binary string. The packed binary string."}, "tests": ["tests/psd_tools/test_utils.py::test_pack"], "indent": 4}
{"namespace": "psd_tools.utils.unpack", "type": "function", "project_path": "Multimedia/psd-tools", "completion_path": "Multimedia/psd-tools/src/psd_tools/utils.py", "signature_position": [23, 23], "body_position": [24, 25], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function unpacks the given data according to the specified format like \">{format}\".", "Arguments": ":param fmt: String. The format string to be used for unpacking the data.\n:param data: Data. The data to be unpacked.\n:return: Tuple. A tuple containing the unpacked values."}, "tests": ["tests/psd_tools/test_utils.py::test_unpack"], "indent": 4}
{"namespace": "psd_tools.api.numpy_io.get_pattern", "type": "function", "project_path": "Multimedia/psd-tools", "completion_path": "Multimedia/psd-tools/src/psd_tools/api/numpy_io.py", "signature_position": [105, 105], "body_position": [107, 112], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function gets the pattern array from the input pattern. It first extracts the height and width from the third place and fourth place of the rectangle in the pattern's \"data\" attribute and then creates a pattern array by parsing the data from the channels in the pattern's \"data\" attribute.", "Arguments": ":param pattern: Pattern. The input pattern from which the pattern array is to be extracted.\n:return: Numpy array. The pattern array extracted from the input pattern."}, "tests": ["tests/psd_tools/api/test_numpy_io.py::test_get_pattern"], "indent": 4}
{"namespace": "sqlite_utils.utils.maximize_csv_field_size_limit", "type": "function", "project_path": "Database/sqlite-utils", "completion_path": "Database/sqlite-utils/sqlite_utils/utils.py", "signature_position": [45, 45], "body_position": [50, 57], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Increase the CSV field size limit to the maximum possible. It first set the limit of the field's size to be max size of system and then iteratively tries to set the field size limit to the maximum possible value until it succeeds.", "Arguments": ":param: No input parameters.\n:return: No return values."}, "tests": ["tests/test_utils.py::test_maximize_csv_field_size_limit"], "indent": 4}
{"namespace": "sqlite_utils.utils.column_affinity", "type": "function", "project_path": "Database/sqlite-utils", "completion_path": "Database/sqlite-utils/sqlite_utils/utils.py", "signature_position": [123, 125], "body_position": [126, 139], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the affinity of the given column type based on SQLite affinity rules including \"INT\", \"CHAR\", \"CLOB\", \"TEXT\", \"BLOB\", \"REAL\", \"FLOA\", \"DOUB\".", "Arguments": ":param column_type: str. The type of the column.\n:return: The affinity of the given column type."}, "tests": ["tests/test_column_affinity.py::test_column_affinity"], "indent": 4}
{"namespace": "sqlite_utils.utils.decode_base64_values", "type": "function", "project_path": "Database/sqlite-utils", "completion_path": "Database/sqlite-utils/sqlite_utils/utils.py", "signature_position": [142, 143], "body_position": [144, 153], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Decode the base64 encoded values in the given document. It looks for the values with the format '{\"$base64\": true..., \"encoded\": ...}' and decodes them.", "Arguments": ":param doc: Dictionary. The input document containing base64 encoded values.\n:return: Dictionary. The document with base64 encoded values decoded."}, "tests": ["tests/test_utils.py::test_decode_base64_values"], "indent": 4}
{"namespace": "sqlite_utils.utils.chunks", "type": "function", "project_path": "Database/sqlite-utils", "completion_path": "Database/sqlite-utils/sqlite_utils/utils.py", "signature_position": [489, 489], "body_position": [496, 498], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Iterate over chunks of the sequence of the given size. It takes a sequence and a size as input and yields chunks of the sequence of the given size.", "Arguments": ":param sequence: Iterable. Any Python iterator.\n:param size: int. The size of each chunk.\n:return: Iterable[Iterable]. An iterator that yields chunks of the sequence."}, "tests": ["tests/test_utils.py::test_chunks"], "indent": 4}
{"namespace": "sqlite_utils.utils.hash_record", "type": "function", "project_path": "Database/sqlite-utils", "completion_path": "Database/sqlite-utils/sqlite_utils/utils.py", "signature_position": [501, 501], "body_position": [522, 529], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function generates a sha1 hash of the keys and values in the given record. If a subset of keys is provided, it uses only those keys to generate the hash.", "Arguments": ":param record: Dict. A Python dictionary representing the record to generate a hash for.\n:param keys: Optional[Iterable[str]]. A subset of keys to use for generating the hash. Defaults to None.\n:return: The sha1 hash of the keys and values in the record."}, "tests": ["tests/test_utils.py::test_hash_record", "tests/test_create.py::test_insert_hash_id_columns"], "indent": 4}
{"namespace": "arctic.decorators._get_host", "type": "function", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/decorators.py", "signature_position": [16, 16], "body_position": [17, 28], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a dictionary containing the host information of the given store. It first checks if the store is not empty. If the store is not empty, it checks whether it's a list or tuple and takes the first element if so. The function then gathers the store's library name, the MongoDB nodes (formatted as \"host:port\"), and the MongoDB host associated with the Arctic library.", "Arguments": ":param store: Object. The store object from which the host information is to be retrieved.\n:return: Dictionary. A dictionary containing the host information of the given store."}, "tests": ["tests/unit/test_decorators_unit.py::test_get_host_list", "tests/unit/test_decorators_unit.py::test_get_host_not_a_vs", "tests/unit/test_decorators_unit.py::test_get_host"], "indent": 4}
{"namespace": "arctic.decorators.mongo_retry", "type": "function", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/decorators.py", "signature_position": [35, 35], "body_position": [40, 66], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a decorator that handles AutoReconnect and OperationFailure errors from PyMongo. It catches all exceptions and logs them if the module name contains 'arctic' and finally set the global attribute _retry_count and _in_retry.", "Arguments": ":param f: The function to be decorated.\n:return: The decorated function."}, "tests": ["tests/unit/test_decorators_unit.py::test_mongo_retry_hook_changes", "tests/unit/test_decorators_unit.py::test_retry_nested", "tests/unit/test_decorators_unit.py::test_mongo_retry_fails", "tests/unit/test_decorators_unit.py::test_all_other_exceptions_logged", "tests/unit/test_decorators_unit.py::test_mongo_retry"], "indent": 4}
{"namespace": "arctic._util.are_equals", "type": "function", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/_util.py", "signature_position": [37, 37], "body_position": [38, 44], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if two objects are equal. If the objects are DataFrames, it uses the assert_frame_equal function to check for equality. Otherwise, it uses the equality operator to compare the objects.", "Arguments": ":param o1: Any. The first object to compare.\n:param o2: Any. The second object to compare.\n:param kwargs: Any. Additional keyword arguments to be passed to the assert_frame_equal function if o1 and o2 are DataFrames.\n:return: Bool. True if the objects are equal, False otherwise. If an exception occurs during the comparison, it returns False."}, "tests": ["tests/unit/test_util.py::test_are_equals_not_df"], "indent": 4}
{"namespace": "arctic.hooks.register_resolve_mongodb_hook", "type": "function", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/hooks.py", "signature_position": [18, 18], "body_position": [19, 20], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function registers a MongoDB hook for resolving MongoDB connections.", "Arguments": ":param hook: The MongoDB hook to be registered.\n:return: No return values."}, "tests": ["tests/unit/test_hooks.py::test_get_mongodb_uri_hook"], "indent": 4}
{"namespace": "arctic.hooks.register_log_exception_hook", "type": "function", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/hooks.py", "signature_position": [30, 30], "body_position": [31, 32], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function registers a log exception hook to be used globally.", "Arguments": ":param hook: The hook to be registered for logging exceptions.\n:return: No return values."}, "tests": ["tests/unit/test_decorators_unit.py::test_mongo_retry_hook_changes", "tests/unit/test_hooks.py::test_log_exception_hook"], "indent": 4}
{"namespace": "arctic.hooks.register_get_auth_hook", "type": "function", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/hooks.py", "signature_position": [35, 35], "body_position": [36, 37], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Register a hook function to be used for getting authentication information.", "Arguments": ":param hook: Function. The hook function to be registered for getting authentication information.\n:return: No return values."}, "tests": ["tests/unit/test_hooks.py::test_get_auth_hook"], "indent": 4}
{"namespace": "arctic.store._version_store_utils._split_arrs", "type": "function", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/store/_version_store_utils.py", "signature_position": [17, 17], "body_position": [22, 31], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function splits a 2D array into multiple sub-arrays based on the given slices. It avoids using fancy indexing and is equivalent to numpy.split(array_2d, slices).", "Arguments": ":param array_2d: 2D array. The input 2D array to be split.\n:param slices: List of integers. The indices where the array is split.\n:return: 1D array. The resulting array of sub-arrays."}, "tests": ["tests/unit/store/test_version_store_utils.py::test_split_arrs"], "indent": 4}
{"namespace": "arctic.store._version_store_utils.checksum", "type": "function", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/store/_version_store_utils.py", "signature_position": [34, 34], "body_position": [38, 46], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calculates the checksum of the passed-in dictionary. It uses the SHA1 algorithm to calculate the checksum and returns the result as a Binary object.", "Arguments": ":param symbol: String. The symbol to be encoded and used in the checksum calculation.\n:param doc: Dictionary. The dictionary for which the checksum needs to be calculated.\n:return: Binary. The calculated checksum as a Binary object."}, "tests": ["tests/unit/store/test_version_store_utils.py::test_checksum_handles_p3strs_and_binary", "tests/unit/store/test_version_store_utils.py::test_checksum"], "indent": 4}
{"namespace": "arctic.store.versioned_item.VersionedItem.__str__", "type": "method", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/store/versioned_item.py", "signature_position": [18, 18], "body_position": [19, 20], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Return a string representation of the VersionedItem instance in the format \"VersionedItem(symbol={symbol},library={library},data={data},version={version},metadata={metadata},host={host})\".", "Arguments": ":param self: VersionedItem. An instance of the VersionedItem class.\n:return: String. The string representation of the VersionedItem instance."}, "tests": ["tests/unit/store/test_version_item.py::test_versioned_item_str_handles_none", "tests/unit/store/test_version_item.py::test_versioned_item_str"], "indent": 8}
{"namespace": "arctic.store._ndarray_store.NdarrayStore._dtype", "type": "method", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/store/_ndarray_store.py", "signature_position": [313, 313], "body_position": [314, 318], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a numpy dtype object based on the input string including the string starting with \"[\" and so on, and metadata. If the metadata is not provided, it defaults to an empty dictionary.", "Arguments": ":param self: NdarrayStore. An instance of the NdarrayStore class.\n:param string: String. The input string to create the dtype object.\n:param metadata: Dictionary. Additional metadata to be passed to the dtype object. Defaults to an empty dictionary.\n:return: Numpy dtype. The created dtype object."}, "tests": ["tests/unit/store/test_ndarray_store.py::test_dtype_parsing"], "indent": 8}
{"namespace": "arctic.store._ndarray_store._promote_struct_dtypes", "type": "function", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/store/_ndarray_store.py", "signature_position": [26, 26], "body_position": [27, 38], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function promotes the data types of two structured arrays. It first checks if the fields of dtype1 are a superset of dtype2. Then, it promotes the data types of the two structured arrays and returns the promoted data type.", "Arguments": ":param dtype1: The data type of the first structured array.\n:param dtype2: The data type of the second structured array.\n:return: The promoted data type of the two structured arrays."}, "tests": ["tests/unit/store/test_ndarray_store.py::test_promote_dtype_throws_if_column_is_removed", "tests/unit/store/test_ndarray_store.py::test_promote_dtype_handles_rearrangement_of_columns_favouring_dtype1", "tests/unit/store/test_ndarray_store.py::test_promote_dtype_handles_string_decrease", "tests/unit/store/test_ndarray_store.py::test_promote_dtype_handles_new_column", "tests/unit/store/test_ndarray_store.py::test_promote_dtype_handles_string_increase"], "indent": 4}
{"namespace": "arctic.chunkstore.passthrough_chunker.PassthroughChunker.exclude", "type": "method", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/chunkstore/passthrough_chunker.py", "signature_position": [62, 62], "body_position": [72, 75], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function removes data within the bounds of the range object. Since the range object is not valid for this chunk type, it returns an empty dataframe or series.", "Arguments": ":param self: PassthroughChunker. An instance of the PassthroughChunker class.\n:param data: DataFrame or Series. The data to be processed.\n:param range_obj: Range object. The range object to be used for exclusion.\n:return: Empty DataFrame or Series. The result of the exclusion process."}, "tests": ["tests/unit/chunkstore/test_passthrough_chunker.py::test_pass_thru"], "indent": 8}
{"namespace": "arctic.chunkstore.date_chunker.DateChunker.to_chunks", "type": "method", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/chunkstore/date_chunker.py", "signature_position": [10, 10], "body_position": [28, 55], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function chunks the dataframe/series by dates based on the given chunk size. It then applies the given function to each chunk generated by the chunker. The function cannot modify the date column of the dataframe.", "Arguments": ":param df: pandas dataframe or series. The dataframe or series to be chunked.\n:param chunk_size: str. Any valid Pandas frequency string.\n:param func: function. The function to be applied to each chunk generated by the chunker. This function CANNOT modify the date column of the dataframe.\n:param kwargs: Additional keyword arguments.\n:return: generator. A generator that produces tuples: (start date, end date, chunk_size, dataframe/series)."}, "tests": ["tests/unit/chunkstore/test_date_chunker.py::test_to_chunks_exceptions"], "indent": 8}
{"namespace": "arctic.chunkstore.date_chunker.DateChunker.exclude", "type": "method", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/chunkstore/date_chunker.py", "signature_position": [135, 135], "body_position": [143, 150], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "The exclude function filters and returns data that falls outside the specified date range. It first checks if the range_obj is either a pd.DatetimeIndex or a tuple, and converts it to a DateRange object. The function then determines if 'date' is present in either the index names or columns of the data and filters the data to include only those records where the date is either before the start or after the end of the specified range.", "Arguments": ":param self: DateChunker. An instance of the DateChunker class.\n:param data: DataFrame. The data to be filtered.\n:param range_obj: DatetimeIndex or tuple. The range object to filter the data.\n:return: DataFrame. The data filtered by range_obj."}, "tests": ["tests/unit/chunkstore/test_date_chunker.py::test_exclude", "tests/unit/chunkstore/test_date_chunker.py::test_exclude_no_index"], "indent": 8}
{"namespace": "mopidy.httpclient.format_proxy", "type": "function", "project_path": "Multimedia/Mopidy", "completion_path": "Multimedia/Mopidy/mopidy/httpclient.py", "signature_position": [8, 8], "body_position": [19, 33], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts a Mopidy proxy config to the commonly used proxy string format. It outputs \"scheme://host:port\", \"scheme://user:pass@host:port\" or None depending on the proxy config provided. You can also opt out of getting the basic auth by setting \"auth\" to False.", "Arguments": ":param proxy_config: Dictionary. The Mopidy proxy config.\n:param auth: Bool. Whether to include basic authentication in the proxy string. Defaults to True.\n:return: String. The commonly used proxy string format."}, "tests": ["tests/test_httpclient.py::test_format_proxy_without_auth", "tests/test_httpclient.py::test_format_proxy"], "indent": 4}
{"namespace": "arctic.chunkstore.date_chunker.DateChunker.filter", "type": "method", "project_path": "Database/arctic-latest", "completion_path": "Database/arctic-latest/arctic/chunkstore/date_chunker.py", "signature_position": [101, 101], "body_position": [114, 133], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function ensures that the data is properly subset to the range in range_obj. It checks the type of range_obj and converts it to DateRange if it is a tuple or pd.DatetimeIndex. Then, it filters the data based on the Pandas DateRange.", "Arguments": ":param self: DateChunker. An instance of the DateChunker class.\n:param data: DataFrame. The data to be filtered.\n:param range_obj: DateRange or tuple. The range to filter the data.\n:return: DataFrame. The data filtered by range_obj."}, "tests": ["tests/unit/chunkstore/test_date_chunker.py::test_with_tuples", "tests/unit/chunkstore/test_date_chunker.py::test_date_filter_with_pd_date_range", "tests/unit/chunkstore/test_date_chunker.py::test_date_filter", "tests/unit/chunkstore/test_date_chunker.py::test_date_filter_no_index"], "indent": 8}
{"namespace": "mopidy.config.validators.validate_required", "type": "function", "project_path": "Multimedia/Mopidy", "completion_path": "Multimedia/Mopidy/mopidy/config/validators.py", "signature_position": [4, 4], "body_position": [10, 11], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function validates that the value is set if it is required. It is normally called in the mopidy.config.types.ConfigValue.deserialize method on the raw string, not the converted value.", "Arguments": ":param value: The value to be validated.\n:param required: Boolean. Whether the value is required or not.\n:return: No return values."}, "tests": ["tests/config/test_validator.py::ValidateRequiredTest::test_blocks_when_required_and_emtpy"], "indent": 4}
{"namespace": "mopidy.config.validators.validate_choice", "type": "function", "project_path": "Multimedia/Mopidy", "completion_path": "Multimedia/Mopidy/mopidy/config/validators.py", "signature_position": [14, 14], "body_position": [19, 21], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function validates whether the given value is one of the choices provided. If the value is not in the choices, it raises a ValueError in the format \"must be one of {names}, not {value}.\".", "Arguments": ":param value: The value to be validated.\n:param choices: List. The list of choices to validate the value against.\n:return: No return values."}, "tests": ["tests/config/test_validator.py::ValidateChoiceTest::test_empty_choices_fails", "tests/config/test_validator.py::ValidateChoiceTest::test_invalid_value_fails"], "indent": 4}
{"namespace": "mopidy.config.validators.validate_minimum", "type": "function", "project_path": "Multimedia/Mopidy", "completion_path": "Multimedia/Mopidy/mopidy/config/validators.py", "signature_position": [24, 24], "body_position": [29, 30], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function validates that the input value is at least the minimum value. If the input value is less than the minimum value, it raises a ValueError in the format \"{value!r} must be larger than {minimum!r}.\".", "Arguments": ":param value: The input value to be validated.\n:param minimum: The minimum value that the input value should be compared against.\n:return: No return values."}, "tests": ["tests/config/test_validator.py::ValidateMinimumTest::test_to_small_value_fails_with_zero_as_minimum", "tests/config/test_validator.py::ValidateMinimumTest::test_to_small_value_fails"], "indent": 4}
{"namespace": "mopidy.config.validators.validate_maximum", "type": "function", "project_path": "Multimedia/Mopidy", "completion_path": "Multimedia/Mopidy/mopidy/config/validators.py", "signature_position": [33, 33], "body_position": [38, 39], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function validates that the given value is at most the given maximum value. If the maximum is not None or value is bigger than maximum, it raises a ValueError in the format \"\"{value!r} must be smaller than {maximum!r}.\".", "Arguments": ":param value: The value to be validated.\n:param maximum: The maximum value that the given value should not exceed.\n:return: No return values."}, "tests": ["tests/config/test_validator.py::ValidateMaximumTest::test_to_large_value_fails_with_zero_as_maximum", "tests/config/test_validator.py::ValidateMaximumTest::test_to_large_value_fails"], "indent": 4}
{"namespace": "mopidy.config.schemas._did_you_mean", "type": "function", "project_path": "Multimedia/Mopidy", "completion_path": "Multimedia/Mopidy/mopidy/config/schemas.py", "signature_position": [6, 6], "body_position": [8, 17], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function suggests the most likely setting based on the Levenshtein distance. It calculates the Levenshtein distance between the input name and each choice, sorts the results, and returns the most likely setting if the distance is less than or equal to 3.", "Arguments": ":param name: String. The input name for which the most likely setting is to be suggested.\n:param choices: List of strings. The list of choices to compare with the input name.\n:return: String. The most likely setting based on the Levenshtein distance, or None if no choices are provided or the distance is greater than 3."}, "tests": ["tests/config/test_schemas.py::DidYouMeanTest::test_suggestions"], "indent": 4}
{"namespace": "mopidy.config.types.encode", "type": "function", "project_path": "Multimedia/Mopidy", "completion_path": "Multimedia/Mopidy/mopidy/config/types.py", "signature_position": [21, 21], "body_position": [22, 30], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function encodes the given value. If the value is of type bytes, it decodes it using the \"surrogateescape\" error handler. Then, it replaces the characters \"\\\" with \"\\\\n\" and \"\\t\" with \"\\\\t\" and returns the encoded value.", "Arguments": ":param value: The value to be encoded.\n:return: The encoded value."}, "tests": ["tests/config/test_types.py::test_encode_decode_invalid_utf8", "tests/config/test_types.py::test_encode"], "indent": 4}
{"namespace": "mopidy.config.types.decode", "type": "function", "project_path": "Multimedia/Mopidy", "completion_path": "Multimedia/Mopidy/mopidy/config/types.py", "signature_position": [9, 9], "body_position": [10, 18], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Decode the given value. If the value is of type bytes, it decodes it using the \"surrogateescape\" error handler. Then, it replaces the escape sequences for backslash, newline, and tab with their corresponding characters.", "Arguments": ":param value: Any. The value to be decoded.\n:return: Any. The decoded value."}, "tests": ["tests/config/test_types.py::test_encode_decode_invalid_utf8", "tests/config/test_types.py::test_decode"], "indent": 4}
{"namespace": "mopidy.config.types.ConfigValue.serialize", "type": "method", "project_path": "Multimedia/Mopidy", "completion_path": "Multimedia/Mopidy/mopidy/config/types.py", "signature_position": [66, 66], "body_position": [68, 70], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts the input value to a string for saving purposes. If the input value is None, it returns an empty string.", "Arguments": ":param self: ConfigValue. An instance of the ConfigValue class.\n:param value: Any. The value to be converted to a string.\n:param display: Bool. Whether to display the value. Defaults to False.\n:return: String. The converted string value."}, "tests": ["tests/config/test_types.py::TestConfigValue::test_serialize_none", "tests/config/test_types.py::TestConfigValue::test_serialize_supports_display", "tests/config/test_types.py::TestConfigValue::test_serialize_conversion_to_string"], "indent": 8}
{"namespace": "mopidy.config.types.Boolean.serialize", "type": "method", "project_path": "Multimedia/Mopidy", "completion_path": "Multimedia/Mopidy/mopidy/config/types.py", "signature_position": [213, 213], "body_position": [214, 219], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Serialize the given value to a string representation of a boolean. If the value is True, it returns \"true\". If the value is False or None, it returns \"false\". Otherwise, it raises a ValueError in the format \"{value!r} is not a boolean\".", "Arguments": ":param self: Boolean. An instance of the Boolean class.\n:param value: Any. The value to be serialized.\n:param display: Bool. Whether to display the value. Defaults to False.\n:return: String. The serialized value."}, "tests": ["tests/config/test_types.py::TestBoolean::test_serialize_true", "tests/config/test_types.py::TestBoolean::test_serialize_false", "tests/config/test_types.py::TestBoolean::test_serialize_invalid_values", "tests/config/test_types.py::TestBoolean::test_serialize_none_as_false"], "indent": 8}
{"namespace": "hypertools.tools.df2mat.df2mat", "type": "function", "project_path": "Multimedia/hypertools", "completion_path": "Multimedia/hypertools/hypertools/tools/df2mat.py", "signature_position": [6, 6], "body_position": [32, 45], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function transforms a single-level Pandas DataFrame into a Numpy array with binarized text columns. It uses the Pandas.DataFrame.get_dummies function to transform text columns into binary vectors.", "Arguments": ":param data: Pandas DataFrame. The DataFrame that needs to be converted. It only works with single-level (not Multi-level indices).\n:param return_labels: Bool. Whether to return a list of column labels for the numpy array. Defaults to False.\n:return: Numpy array. A Numpy array where text columns are turned into binary vectors.\n:labels: List. A list of column labels for the numpy array. Only returned if return_labels is set to True."}, "tests": ["tests/test_pandas_to_matrix.py::test_df2mat"], "indent": 4}
{"namespace": "hypertools._shared.helpers.center", "type": "function", "project_path": "Multimedia/hypertools", "completion_path": "Multimedia/hypertools/hypertools/_shared/helpers.py", "signature_position": [20, 20], "body_position": [21, 23], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function first asserts the type of input is list and then centers the input list of data by subtracting the mean of the input data from each element of the list.", "Arguments": ":param x: list. The input list of data to be centered.\n:return: list. The centered list of data."}, "tests": ["tests/test_helpers.py::test_center"], "indent": 4}
{"namespace": "hypertools._shared.helpers.group_by_category", "type": "function", "project_path": "Multimedia/hypertools", "completion_path": "Multimedia/hypertools/hypertools/_shared/helpers.py", "signature_position": [35, 35], "body_position": [36, 39], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function groups the input values by category. It first checks if the input values contain any list. If so, it flattens the list. Then, it creates a sorted set of unique values and returns the index of each value in the sorted set.", "Arguments": ":param vals: List. The input list of values.\n:return: List. The list of indices of the input values in the sorted set."}, "tests": ["tests/test_helpers.py::test_group_by_category_ints", "tests/test_helpers.py::test_group_by_category_str"], "indent": 4}
{"namespace": "hypertools._shared.helpers.vals2colors", "type": "function", "project_path": "Multimedia/hypertools", "completion_path": "Multimedia/hypertools/hypertools/_shared/helpers.py", "signature_position": [42, 42], "body_position": [52, 58], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function maps the input values to colors based on the given color map and resolution. It first flattens the input list if it is a list of lists. Then, it gets the color palette from seaborn and maps the input values to colors based on the color map and resolution.", "Arguments": ":param vals: List or list of lists. List of values to map to colors.\n:param cmap: String. The color map to be used. It defaults to 'GnBu' if not specified.\n:param res: Integer. The resolution of the color map. It defaults to 100.\n:return: List of RGB tuples. The list of RGB tuples representing the mapped colors."}, "tests": ["tests/test_helpers.py::test_vals2colors_list", "tests/test_helpers.py::test_vals2colors_list_of_lists"], "indent": 4}
{"namespace": "hypertools._shared.helpers.vals2bins", "type": "function", "project_path": "Multimedia/hypertools", "completion_path": "Multimedia/hypertools/hypertools/_shared/helpers.py", "signature_position": [61, 61], "body_position": [70, 72], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function maps the input values to bins based on the given resolution. It first flattens the input list if it is a list of lists and then maps the values to bins based on the resolution.", "Arguments": ":param vals: List or list of lists. List of values to map to colors.\n:param res: Int. Resolution of the color map. Defaults to 100.\n:return: List of numbers representing bins."}, "tests": ["tests/test_helpers.py::test_vals2bins"], "indent": 4}
{"namespace": "hypertools._shared.helpers.interp_array", "type": "function", "project_path": "Multimedia/hypertools", "completion_path": "Multimedia/hypertools/hypertools/_shared/helpers.py", "signature_position": [75, 75], "body_position": [76, 79], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function interpolates the given array using piecewise cubic Hermite interpolation.", "Arguments": ":param arr: Array. The input array to be interpolated.\n:param interp_val: Integer. The interpolation value. Defaults to 10.\n:return: Array. The interpolated array."}, "tests": ["tests/test_helpers.py::test_interp_array"], "indent": 4}
{"namespace": "hypertools._shared.helpers.parse_args", "type": "function", "project_path": "Multimedia/hypertools", "completion_path": "Multimedia/hypertools/hypertools/_shared/helpers.py", "signature_position": [89, 89], "body_position": [90, 103], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes two input parameters, x and args, and creates a list of tuples. It iterates through the elements of x and for each element, it creates a tuple by combining the elements of args. If the element of args is a list or tuple, it checks if its length is the same as that of x. If not, it prints an error message and exits the program.", "Arguments": ":param x: List. The input list of elements.\n:param args: List. The list of arguments to be combined with the elements of x.\n:return: List of tuples. A list of tuples, where each tuple contains the combined elements of x and args."}, "tests": ["tests/test_helpers.py::test_parse_args_array", "tests/test_helpers.py::test_parse_args_list"], "indent": 4}
{"namespace": "hypertools._shared.helpers.parse_kwargs", "type": "function", "project_path": "Multimedia/hypertools", "completion_path": "Multimedia/hypertools/hypertools/_shared/helpers.py", "signature_position": [106, 106], "body_position": [107, 119], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function creates a list of dictionaries based on the input list and the input keyword arguments. It iterates through the input list and creates a dictionary for each item in the list using the keyword arguments.", "Arguments": ":param x: List. The input list.\n:param kwargs: Dictionary. The keyword arguments.\n:return: List of Dictionary. A list of dictionaries created based on the input list and keyword arguments."}, "tests": ["tests/test_helpers.py::test_parse_kwargs_list", "tests/test_helpers.py::test_parse_kwargs_array"], "indent": 4}
{"namespace": "gif_for_cli.utils._get_default_display_mode", "type": "function", "project_path": "Multimedia/gif-for-cli", "completion_path": "Multimedia/gif-for-cli/gif_for_cli/utils.py", "signature_position": [39, 39], "body_position": [40, 47], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the default display mode based on the environment variables. It checks the TERM and COLORTERM environment variables and returns the display mode based on the values of these variables. If \"truecolor\" in TERM or COLORTERM, it will return \"truecolor\". If \"256\" in TERM or COLORTERM, it will return \"256fgbg\". In other conditions, it returns \"nocolor\".", "Arguments": ":param environ: Dictionary. The environment variables.\n:return: String. The default display mode based on the environment variables."}, "tests": ["tests/test_utils.py::TestGetDefaultDisplayMode::test_truecolor", "tests/test_utils.py::TestGetDefaultDisplayMode::test_256", "tests/test_utils.py::TestGetDefaultDisplayMode::test_empty_env"], "indent": 4}
{"namespace": "gif_for_cli.utils._pool_type", "type": "function", "project_path": "Multimedia/gif-for-cli", "completion_path": "Multimedia/gif-for-cli/gif_for_cli/utils.py", "signature_position": [50, 50], "body_position": [51, 56], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts the input value to an integer and checks if it is greater than 0. If not, it raises an exception.", "Arguments": ":param val: The input value to be converted to an integer.\n:return: Integer. The converted value. Or an exception is raised if the value is less than or equal to 0."}, "tests": ["tests/test_utils.py::TestPoolType::test_int_string_0", "tests/test_utils.py::TestPoolType::test_int_string"], "indent": 4}
{"namespace": "gif_for_cli.generate.utils.get_avg_for_em", "type": "function", "project_path": "Multimedia/gif-for-cli", "completion_path": "Multimedia/gif-for-cli/gif_for_cli/generate/utils.py", "signature_position": [65, 65], "body_position": [66, 71], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calculates the average of the pixels in a given area of an image.", "Arguments": ":param px: List. The list of pixels in the image.\n:param x: Integer. The x-coordinate of the top-left corner of the area.\n:param y: Integer. The y-coordinate of the top-left corner of the area.\n:param cell_height: Integer. The height of the area.\n:param cell_width: Integer. The width of the area.\n:return: List. The average of the pixels in the given area."}, "tests": ["tests/generate/test_utils.py::TestGetAvgForEm::test_white_block", "tests/generate/test_utils.py::TestGetAvgForEm::test_separate_color_channels", "tests/generate/test_utils.py::TestGetAvgForEm::test_gray_block", "tests/generate/test_utils.py::TestGetAvgForEm::test_default_black_block"], "indent": 4}
{"namespace": "gif_for_cli.generate.utils.process_input_source", "type": "function", "project_path": "Multimedia/gif-for-cli", "completion_path": "Multimedia/gif-for-cli/gif_for_cli/generate/utils.py", "signature_position": [74, 74], "body_position": [75, 116], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function processes the input source to get the GIF URL. It first checks if the input source is a Tenor GIF URL by checking the input source start with \"https://tenor.com/view/\". If it is, it extracts the GIF ID and uses it to get the GIF URL. If the input source is not a URL, it sends a request to the Tenor GIF API to get the GIF URL based on the input source.", "Arguments": ":param input_source: String. The input source, which can be a Tenor GIF URL, a local file path, or a search query.\n:param api_key: String. The API key for accessing the Tenor GIF API.\n:return: String. The GIF URL obtained from the input source."}, "tests": ["tests/generate/test_utils.py::TestProcessInputSource::test_http_url", "tests/generate/test_utils.py::TestProcessInputSource::test_file", "tests/generate/test_utils.py::TestProcessInputSource::test_tenor_search", "tests/generate/test_utils.py::TestProcessInputSource::test_tenor_trending", "tests/generate/test_utils.py::TestProcessInputSource::test_https_url"], "indent": 4}
{"namespace": "hypertools._shared.helpers.reshape_data", "type": "function", "project_path": "Multimedia/hypertools", "completion_path": "Multimedia/hypertools/hypertools/_shared/helpers.py", "signature_position": [122, 122], "body_position": [123, 132], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Reshape the input data based on the hue and labels. It stacks the input data and reshapes it based on the categories in the hue. It also reshapes the labels based on the categories in the hue.", "Arguments": ":param x: Array. The input data to be reshaped.\n:param hue: Array. The categories based on which the data is reshaped.\n:param labels: Array. The labels corresponding to the input data. Defaults to None.\n:return: List of arrays. The reshaped input data based on the categories in the hue, and the reshaped labels."}, "tests": ["tests/test_helpers.py::test_reshape_data"], "indent": 4}
{"namespace": "mingus.extra.lilypond.from_Note", "type": "function", "project_path": "Multimedia/mingus", "completion_path": "Multimedia/mingus/mingus/extra/lilypond.py", "signature_position": [37, 37], "body_position": [46, 73], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes a Note object and returns the LilyPond equivalent in a string. It can ignore all data regarding octaves and produce a valid output.", "Arguments": ":param note: Note. The Note object to be converted.\n:param process_octaves: Bool. Whether to process octaves. Defaults to True.\n:param standalone: Bool. Whether the result can be used by functions like to_png. Defaults to True.\n:return: String. The LilyPond equivalent of the Note object."}, "tests": ["tests/integration/test_lilypond.py::test_LilyPond::test_from_Note"], "indent": 4}
{"namespace": "mingus.extra.tablature._get_qsize", "type": "function", "project_path": "Multimedia/mingus", "completion_path": "Multimedia/mingus/mingus/extra/tablature.py", "signature_position": [452, 452], "body_position": [454, 459], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calculates and returns a reasonable quarter note size based on the input tuning and width.", "Arguments": ":param tuning: Tuning. The tuning object used to calculate the quarter note size.\n:param width: Integer. The width used to calculate the quarter note size.\n:return: Integer. The calculated quarter note size."}, "tests": ["tests/unit/extra/test_tablature.py::test_Tablature::test__get_qsize"], "indent": 4}
{"namespace": "mingus.core.notes.augment", "type": "function", "project_path": "Multimedia/mingus", "completion_path": "Multimedia/mingus/mingus/core/notes.py", "signature_position": [147, 147], "body_position": [156, 159], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function augments a given note. If the note does not end with \"b\", it adds \"#\" to the note. Otherwise, it removes the last character \"b\" from the note.", "Arguments": ":param note: String. The note to be augmented.\n:return: String. The augmented note."}, "tests": ["tests/unit/core/test_notes.py::test_notes::test_augment"], "indent": 4}
{"namespace": "mingus.core.meter.valid_beat_duration", "type": "function", "project_path": "Multimedia/mingus", "completion_path": "Multimedia/mingus/mingus/core/meter.py", "signature_position": [30, 30], "body_position": [32, 42], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the duration is a valid beat duration. A valid beat duration is when log2(duration) is an integer.", "Arguments": ":param duration: Integer. The duration to be checked.\n:return: Bool. True if log2(duration) is an integer, False otherwise."}, "tests": ["tests/unit/core/test_meter.py::test_meter::test_valid_beat_duration"], "indent": 4}
{"namespace": "mingus.core.notes.diminish", "type": "function", "project_path": "Multimedia/mingus", "completion_path": "Multimedia/mingus/mingus/core/notes.py", "signature_position": [162, 162], "body_position": [171, 174], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Diminish a given note. If the note does not end with \"#\", it adds \"b\" to the note. Otherwise, it removes the last character \"#\" from the note.", "Arguments": ":param note: String. The note to be diminished.\n:return: String. The diminished note."}, "tests": ["tests/unit/core/test_notes.py::test_notes::test_diminish"], "indent": 4}
{"namespace": "mingus.core.intervals.invert", "type": "function", "project_path": "Multimedia/mingus", "completion_path": "Multimedia/mingus/mingus/core/intervals.py", "signature_position": [312, 312], "body_position": [319, 322], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Invert an interval. It reverses the order of the elements in the input interval list and returns the reversed list.", "Arguments": ":param interval: List. The input interval list to be inverted.\n:return: List. The inverted interval list."}, "tests": ["tests/unit/core/test_intervals.py::test_intervals::test_invert"], "indent": 4}
{"namespace": "mingus.core.progressions.parse_string", "type": "function", "project_path": "Multimedia/mingus", "completion_path": "Multimedia/mingus/mingus/core/progressions.py", "signature_position": [215, 215], "body_position": [224, 239], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function parses the input string and returns a tuple containing the roman numeral, accidentals, and chord suffix.", "Arguments": ":param progression: String. The input string to be parsed.\n:return: Tuple. A tuple containing the roman numeral, accidentals, and chord suffix."}, "tests": ["tests/unit/core/test_progressions.py::test_progressions::test_parse_string"], "indent": 4}
{"namespace": "exodus_bundler.bundling.bytes_to_int", "type": "function", "project_path": "System/exodus-bundler", "completion_path": "System/exodus-bundler/src/exodus_bundler/bundling.py", "signature_position": [35, 35], "body_position": [37, 41], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert a byte string into an integer. It first unpacks the byte string into characters and then converts the characters into an integer.", "Arguments": ":param bytes: Byte string. The byte string to be converted into an integer.\n:param byteorder: String. The byte order to be used. It defaults to \"big\" if not specified.\n:return: Integer. The converted integer value."}, "tests": ["tests/test_bundling.py::test_bytes_to_int"], "indent": 4}
{"namespace": "exodus_bundler.templating.render_template", "type": "function", "project_path": "System/exodus-bundler", "completion_path": "System/exodus-bundler/src/exodus_bundler/templating.py", "signature_position": [13, 13], "body_position": [14, 16], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function replaces the placeholders in the input string with the corresponding values from the context dictionary.", "Arguments": ":param string: String. The input string containing placeholders.\n:param context: Dictionary. The key-value pairs to replace the placeholders in the input string.\n:return: String. The modified string after replacing the placeholders."}, "tests": ["tests/test_templating.py::test_render_template"], "indent": 4}
{"namespace": "exodus_bundler.input_parsing.strip_pid_prefix", "type": "function", "project_path": "System/exodus-bundler", "completion_path": "System/exodus-bundler/src/exodus_bundler/input_parsing.py", "signature_position": [105, 105], "body_position": [107, 110], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function removes the `[pid XXX] ` prefix from the input line if it is present.", "Arguments": ":param line: String. The input line that may contain the `[pid XXX] ` prefix.\n:return: String. The line with the `[pid XXX] ` prefix removed if present. If not present, the original line is returned."}, "tests": ["tests/test_input_parsing.py::test_strip_pid_prefix"], "indent": 4}
{"namespace": "fs.path.abspath", "type": "function", "project_path": "System/fs", "completion_path": "System/fs/fs/path.py", "signature_position": [169, 170], "body_position": [184, 186], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts the given path to an absolute path. It adds a leading \"/\" character if the path doesn't already have one.", "Arguments": ":param path: Text. A PyFilesytem path.\n:return: Text. An absolute path."}, "tests": ["tests/test_path.py::TestPathFunctions::test_abspath"], "indent": 4}
{"namespace": "fs.path.combine", "type": "function", "project_path": "System/fs", "completion_path": "System/fs/fs/path.py", "signature_position": [244, 245], "body_position": [264, 266], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function joins two paths together. It is faster than fs.path.join, but only works when the second path is relative, and there are no back references in either path. For example, it convert (\"foo/bar\", \"baz\") into \"foo/bar/baz\".", "Arguments": ":param path1: Text. A PyFilesytem path.\n:param path2: Text. A PyFilesytem path.\n:return: Text. The joint path."}, "tests": ["tests/test_path.py::TestPathFunctions::test_combine"], "indent": 4}
{"namespace": "fs.path.split", "type": "function", "project_path": "System/fs", "completion_path": "System/fs/fs/path.py", "signature_position": [293, 294], "body_position": [315, 318], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Split a path into a pair (head, tail) where 'tail' is the last pathname component and 'head' is all preceding components.", "Arguments": ":param path: Text. The path to split.\n:return: Tuple[Text, Text]. A tuple containing the head and the tail of the path."}, "tests": ["tests/test_path.py::TestPathFunctions::test_pathsplit"], "indent": 4}
{"namespace": "fs.path.isparent", "type": "function", "project_path": "System/fs", "completion_path": "System/fs/fs/path.py", "signature_position": [464, 465], "body_position": [486, 495], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if the first path is a parent directory of the second path. It compares the two paths and returns True if the first path is a parent directory of the second path. Example: isparent(\"foo/bar\", \"foo/bar/spam.txt\") -> True; isparent(\"foo/bar/\", \"foo/bar\") -> True; isparent(\"foo/barry\", \"foo/baz/bar\") -> False; isparent(\"foo/bar/baz/\", \"foo/baz/bar\") -> False", "Arguments": ":param path1: Text. The first path to be compared.\n:param path2: Text. The second path to be compared.\n:return: bool. True if path1 is a parent directory of path2."}, "tests": ["tests/test_path.py::TestPathFunctions::test_isparent"], "indent": 4}
{"namespace": "fs.path.forcedir", "type": "function", "project_path": "System/fs", "completion_path": "System/fs/fs/path.py", "signature_position": [498, 499], "body_position": [517, 519], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Ensure the path ends with a trailing forward slash. If the path does not end with a slash, it appends a slash to the path and returns it.", "Arguments": ":param path: Text. A PyFilesytem path.\n:return: Text. The path, ending with a slash."}, "tests": ["tests/test_path.py::TestPathFunctions::test_forcedir"], "indent": 4}
{"namespace": "fs.wildcard.match_any", "type": "function", "project_path": "System/fs", "completion_path": "System/fs/fs/wildcard.py", "signature_position": [61, 62], "body_position": [76, 78], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function tests if a name matches any of a list of patterns. It returns True if the patterns list is empty.", "Arguments": ":param patterns: Iterable of Text. A list of wildcard patterns, e.g., [\"*.py\", \"*.pyc\"].\n:param name: Text. A filename.\n:return: bool. True if the name matches at least one of the patterns."}, "tests": ["tests/test_wildcard.py::TestFNMatch::test_match_any"], "indent": 4}
{"namespace": "fs.wildcard.imatch_any", "type": "function", "project_path": "System/fs", "completion_path": "System/fs/fs/wildcard.py", "signature_position": [81, 82], "body_position": [96, 98], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function tests if a name matches any of a list of patterns in a case-insensitive manner. It returns True if the patterns list is empty.", "Arguments": ":param patterns: Iterable of Text. A list of wildcard patterns, e.g., [\"*.py\", \"*.pyc\"].\n:param name: Text. A filename.\n:return: bool. True if the name matches at least one of the patterns."}, "tests": ["tests/test_wildcard.py::TestFNMatch::test_match_any"], "indent": 4}
{"namespace": "wal_e.cmd.parse_boolean_envvar", "type": "function", "project_path": "System/wal-e", "completion_path": "System/wal-e/wal_e/cmd.py", "signature_position": [161, 161], "body_position": [163, 168], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function parses a boolean environment variable. It checks if the input value is a valid boolean value 'false', '0', 'true', '1' and returns the corresponding boolean value. Otherwise raises an error.", "Arguments": ":param val: String. The value of the environment variable to be parsed.\n:return: Boolean. The parsed boolean value."}, "tests": ["tests/test_cmd.py::test_parse_boolean_envvar"], "indent": 4}
{"namespace": "wal_e.log_help.get_log_destinations", "type": "function", "project_path": "System/wal-e", "completion_path": "System/wal-e/wal_e/log_help.py", "signature_position": [111, 111], "body_position": [114, 115], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function parses the environment string \"WALE_LOG_DESTINATION\" and returns the log destinations from the corresponding environment varialbe. If the environment variable is not set, it defaults to \"stderr,syslog\".", "Arguments": ":param: No input parameters.\n:return: List of strings. The log destinations."}, "tests": ["tests/test_log_help.py::test_get_log_destinations_empty", "tests/test_log_help.py::test_get_log_destinations_notempty"], "indent": 4}
{"namespace": "wal_e.log_help.WalELogger._fmt_structured", "type": "method", "project_path": "System/wal-e", "completion_path": "System/wal-e/wal_e/log_help.py", "signature_position": [145, 145], "body_position": [151, 158], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function formats a dictionary into a string. The dictionary is formatted as '{k1:v1, k2:v2}' and the output is formatted as 'time=... pid=... k1=v1 k2=v2', in which the time is time=%Y-%m-%dT%H:%M:%S.%f-00. The output is sorted lexically, except the time and pid always come first.", "Arguments": ":param d: Dictionary. The input dictionary to be formatted.\n:return: String. The formatted string."}, "tests": ["tests/test_log_help.py::test_format_structured_info"], "indent": 8}
{"namespace": "wal_e.tar_partition._fsync_files", "type": "function", "project_path": "System/wal-e", "completion_path": "System/wal-e/wal_e/tar_partition.py", "signature_position": [158, 158], "body_position": [164, 184], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calls fsync() on a list of file names. It opens each file, calls fsync() and then closes the file. It also calls fsync() on the directory where the file is created.", "Arguments": ":param filenames: List of string. A list of absolute file paths.\n:return: No return values."}, "tests": ["tests/test_tar_hacks.py::test_fsync_tar_members"], "indent": 4}
{"namespace": "wal_e.blobstore.file.calling_format.Bucket.list", "type": "method", "project_path": "System/wal-e", "completion_path": "System/wal-e/wal_e/blobstore/file/calling_format.py", "signature_position": [72, 72], "body_position": [73, 77], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "List all the files in the bucket with the given prefix. It first constructs the path based on \"/\" + prefix, then retrieves all the file paths under the path, and finally creates an array of FileKey instances based on the file paths.", "Arguments": ":param self: Bucket. An instance of the Bucket class.\n:param prefix: String. The prefix to be used for listing files.\n:return: List of FileKey. An array of FileKey instances representing the files in the bucket with the given prefix."}, "tests": ["tests/test_file_blobstore.py::test_bucket_list"], "indent": 8}
{"namespace": "pyinfra.operations.util.files.unix_path_join", "type": "function", "project_path": "System/pyinfra", "completion_path": "System/pyinfra/pyinfra/operations/util/files.py", "signature_position": [7, 7], "body_position": [8, 10], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Join the given path parts into a single path. It removes the trailing slashes from all parts except the last one and joins them using a forward slash.", "Arguments": ":param path_parts: Tuple. The parts of the path to be joined.\n:return: String. The joined path."}, "tests": ["tests/test_operations_utils.py::TestUnixPathJoin::test_end_slash_path", "tests/test_operations_utils.py::TestUnixPathJoin::test_simple_path", "tests/test_operations_utils.py::TestUnixPathJoin::test_multiple_slash_path", "tests/test_operations_utils.py::TestUnixPathJoin::test_absolute_path"], "indent": 4}
{"namespace": "pyinfra.operations.server.shell", "type": "function", "project_path": "System/pyinfra", "completion_path": "System/pyinfra/pyinfra/operations/server.py", "signature_position": [133, 133], "body_position": [152, 156], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "It converts str to list by using [str] and yields each str in the list.", "Arguments": ":param commands: str or list. Command or list of commands to execute on the remote server.\n:return: Iterator[str]. It yields each command in the list."}, "tests": ["tests/test_api/test_api_operations.py::TestNestedOperationsApi::test_nested_op_api", "tests/test_api/test_api_operations.py::TestOperationFailures::test_ignore_errors_op_fail", "tests/test_api/test_api_operations.py::TestOperationsApi::test_run_once_serial_op", "tests/test_api/test_api_operations.py::TestOperationOrdering::test_cli_op_line_numbers", "tests/test_api/test_api_operations.py::TestOperationFailures::test_full_op_fail"], "indent": 4}
{"namespace": "pyinfra.api.util.try_int", "type": "function", "project_path": "System/pyinfra", "completion_path": "System/pyinfra/pyinfra/api/util.py", "signature_position": [55, 55], "body_position": [56, 59], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function tries to convert the input value to an integer. If it fails, it returns the original value.", "Arguments": ":param value: Any. The value to be converted to an integer.\n:return: int. The converted integer value if successful, otherwise the original value."}, "tests": ["tests/test_api/test_api_util.py::TestApiUtil::test_try_int_fail", "tests/test_api/test_api_util.py::TestApiUtil::test_try_int_number"], "indent": 4}
{"namespace": "mrjob.job.MRJob.mr_job_script", "type": "method", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/job.py", "signature_position": [927, 927], "body_position": [931, 934], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Returns the path of the source file containing the MRJob class. Returns None on error.", "Arguments": ":param cls: The MRJob class.\n:return: Optional[str]. The path of the script containing the MRJob class or None."}, "tests": ["tests/test_job.py::LibjarsTestCase::test_libjars_attr_relative_path", "tests/test_job.py::LibjarsTestCase::test_libjars_environment_variables"], "indent": 8}
{"namespace": "mrjob.compat.map_version", "type": "function", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/compat.py", "signature_position": [623, 623], "body_position": [638, 654], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function allows you to look up something by version (e.g. which jobconf variable to use, specifying only the versions where that value changed). It returns the value for the earliest version in the version map if the version is less than any version in the version map.", "Arguments": ":param version: String. The version to look up.\n:param version_map: Map. A map from version (as a string) that a value changed to the new value. For efficiency, version_map can also be a list of tuples of (LooseVersion(version_as_string), value), with oldest versions first.\n:return: The value for the earliest version in the version map if the version is less than any version in the version map."}, "tests": ["tests/test_compat.py::MapVersionTestCase::test_empty", "tests/test_compat.py::MapVersionTestCase::test_dict", "tests/test_compat.py::MapVersionTestCase::test_version_may_not_be_None", "tests/test_compat.py::MapVersionTestCase::test_list_of_tuples"], "indent": 4}
{"namespace": "mrjob.conf.combine_values", "type": "function", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/conf.py", "signature_position": [378, 378], "body_position": [383, 387], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the last value in the input *values which is not None.", "Arguments": ":param *values: Any. The input values to be combined.\n:return: Any. The last non-None value in the input values. If all values are None, it returns None."}, "tests": ["tests/test_conf.py::CombineValuesTestCase::test_picks_last_value", "tests/test_conf.py::CombineValuesTestCase::test_falseish_values", "tests/test_conf.py::CombineValuesTestCase::test_skips_None", "tests/test_conf.py::CombineCmdsTestCase::test_skips_None"], "indent": 4}
{"namespace": "mrjob.protocol.BytesProtocol.read", "type": "method", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/protocol.py", "signature_position": [361, 361], "body_position": [362, 366], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function reads a line and splits it into two parts - key and value - using the tab delimiter. If there is only one part, it uses None as the value.", "Arguments": ":param self: BytesProtocol. An instance of the BytesProtocol class.\n:param line: Bytes. The line to be read and processed.\n:return: Tuple. A tuple containing the key-value pair."}, "tests": ["tests/test_protocol.py::BytesProtocolTestCase::test_extra_tabs", "tests/test_protocol.py::BytesProtocolTestCase::test_no_strip", "tests/test_protocol.py::BytesProtocolTestCase::test_no_tabs"], "indent": 8}
{"namespace": "mrjob.protocol.TextProtocol.write", "type": "method", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/protocol.py", "signature_position": [418, 418], "body_position": [419, 420], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Write the key and value to the TextProtocol instance. It encodes the key and value to utf-8 and joins them with a tab character. If either key or value is None, it is not included in the string.", "Arguments": ":param self: TextProtocol. An instance of the TextProtocol class.\n:param key: The key to write to the instance.\n:param value: The value to write to the instance.\n:return: bytes. The encoded key and value joined by a tab character."}, "tests": ["tests/test_protocol.py::TextProtocolTestCase::test_extra_tabs", "tests/test_protocol.py::TextProtocolTestCase::test_no_tabs"], "indent": 8}
{"namespace": "mrjob.protocol.TextProtocol.read", "type": "method", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/protocol.py", "signature_position": [406, 406], "body_position": [407, 416], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function reads a line and decodes it using utf_8. If it fails, it decodes it using latin_1. It then splits the line into key and value using the tab character and returns the tuple of key and value.", "Arguments": ":param self: TextProtocol. An instance of the TextProtocol class.\n:param line: The line to be read and processed.\n:return: Tuple. The tuple of key and value."}, "tests": ["tests/test_protocol.py::TextProtocolTestCase::test_no_strip", "tests/test_protocol.py::TextProtocolTestCase::test_extra_tabs", "tests/test_protocol.py::TextProtocolTestCase::test_no_tabs", "tests/test_protocol.py::TextProtocolTestCase::test_latin_1_fallback", "tests/test_protocol.py::TextProtocolTestCase::test_utf_8"], "indent": 8}
{"namespace": "mrjob.protocol.TextValueProtocol.read", "type": "method", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/protocol.py", "signature_position": [444, 444], "body_position": [445, 448], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function reads a line and decodes it using the utf-8 encoding. If a UnicodeDecodeError occurs, it decodes the line using the latin-1 encoding.", "Arguments": ":param self: TextValueProtocol. An instance of the TextValueProtocol class.\n:param line: The line to be read and decoded.\n:return: Tuple. The first element is None and the second element is the decoded line."}, "tests": ["tests/test_protocol.py::TextValueProtocolTestCase::test_fall_back_to_latin_1", "tests/test_protocol.py::TextValueProtocolTestCase::test_utf_8_decode", "tests/test_protocol.py::TextValueProtocolTestCase::test_converts_raw_line_to_unicode", "tests/test_protocol.py::TextValueProtocolTestCase::test_no_strip"], "indent": 8}
{"namespace": "mrjob.util.file_ext", "type": "function", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/util.py", "signature_position": [67, 67], "body_position": [79, 84], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the file extension of the given filename, including the \".\" character. It first strips the leading \".\" from the filename and then finds the index of the first occurrence of \".\". If no \".\" is found, it returns an empty string.", "Arguments": ":param filename: str. The name of the file.\n:return: str. The file extension, including the \".\" character. If no extension is found, an empty string is returned."}, "tests": ["tests/test_util.py::FileExtTestCase::test_file_ext"], "indent": 4}
{"namespace": "mrjob.util.cmd_line", "type": "function", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/util.py", "signature_position": [49, 49], "body_position": [52, 53], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function builds a command line that works in a shell. It takes a list of arguments and converts each argument to a string. Then, it joins the arguments with a space and quotes each argument.", "Arguments": ":param args: List. A list of arguments to be used in the command line.\n:return: str. The command line that works in a shell."}, "tests": ["tests/test_local.py::PythonBinTestCase::test_python_dash_v_as_python_bin", "tests/test_bin.py::SparkUploadArgsTestCase::test_setup_disabled", "tests/test_bin.py::SparkUploadArgsTestCase::test_no_setup", "tests/test_util.py::CmdLineTestCase::test_cmd_line", "tests/test_bin.py::SparkUploadArgsTestCase::test_setup_interpolation"], "indent": 4}
{"namespace": "mrjob.util.save_cwd", "type": "function", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/util.py", "signature_position": [186, 186], "body_position": [189, 195], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a context manager that saves the current working directory and finally: chdir back to it.", "Arguments": ":param: No input parameters.\n:return: No return values."}, "tests": ["tests/test_parse.py::URITestCase::test_relative_path_to_uri"], "indent": 4}
{"namespace": "mrjob.util.save_sys_std", "type": "function", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/util.py", "signature_position": [199, 199], "body_position": [204, 224], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a context manager that saves the current values of `sys.stdin`, `sys.stdout`, and `sys.stderr`, and flushes these file handles before and after switching them out, finally: restore them.", "Arguments": ":param: No input parameters.\n:return: No return values."}, "tests": ["tests/test_util.py::SaveSysStdTestCase::test_basic", "tests/test_util.py::SaveSysStdTestCase::test_bad_flush", "tests/test_util.py::SaveSysStdTestCase::test_flushing"], "indent": 4}
{"namespace": "mrjob.util.unarchive", "type": "function", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/util.py", "signature_position": [334, 334], "body_position": [348, 367], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Extract the contents of a tar or zip file at *archive_path* into the directory *dest*. It first checks the type of the archive file and then extracts the contents accordingly. tar files can be gzip compressed, bzip2 compressed, or uncompressed. Files within zip files can be deflated or stored.", "Arguments": ":param archive_path: str. Path to the archive file.\n:param dest: str. Path to the directory where the archive will be extracted. The path will be created if it doesn't already exist.\n:return: No return values."}, "tests": ["tests/test_util.py::ArchiveTestCase::test_unarchive_non_archive"], "indent": 4}
{"namespace": "mrjob.util.unique", "type": "function", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/util.py", "signature_position": [322, 322], "body_position": [324, 331], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function yields items from the input list in order, skipping duplicates.", "Arguments": ":param items: List. The input list of items.\n:return: Generator[items]."}, "tests": ["tests/test_util.py::UniqueTestCase::test_de_duplication", "tests/test_util.py::UniqueTestCase::test_preserves_order", "tests/test_util.py::UniqueTestCase::test_empty", "tests/test_util.py::UniqueTestCase::test_mixed_types_ok"], "indent": 4}
{"namespace": "mrjob.parse.urlparse", "type": "function", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/parse.py", "signature_position": [79, 79], "body_position": [85, 91], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a wrapper for the urlparse.urlparse function. It splits the fragment correctly in all URIs, not just Web-related ones.", "Arguments": ":param urlstring: String. The URL to be parsed.\n:param scheme: String. The URL scheme. Defaults to an empty string.\n:param allow_fragments: Bool. Whether to allow fragments in the URL. Defaults to True.\n:param *args: Additional positional arguments.\n:param **kwargs: Additional keyword arguments.\n:return: ParseResult. The result of parsing the URL."}, "tests": ["tests/test_parse.py::URITestCase::test_urlparse"], "indent": 4}
{"namespace": "mrjob.util.which", "type": "function", "project_path": "System/mrjob", "completion_path": "System/mrjob/mrjob/util.py", "signature_position": [370, 370], "body_position": [379, 386], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function searches for the executable named *cmd* in the specified *path*. If *path* is not specified, it defaults to :envvar:`PATH`. It returns ``None`` if no such executable is found.", "Arguments": ":param cmd: str. The name of the executable to search for.\n:param path: str. The path to search for the executable. Defaults to :envvar:`PATH`.\n:return: Optional[str]. The path to the executable if found, otherwise ``None``."}, "tests": ["tests/test_util.py::WhichTestCase::test_path_from_environment", "tests/test_util.py::WhichTestCase::test_explicit_path"], "indent": 4}
{"namespace": "sshuttle.ssh.parse_hostport", "type": "function", "project_path": "System/sshuttle", "completion_path": "System/sshuttle/sshuttle/ssh.py", "signature_position": [33, 33], "body_position": [46, 84], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Parse the given rhostport variable looking like [username[:password]@]host[:port]. If only host is given, can be a hostname, IPv4/v6 address or a ssh alias from ~/.ssh/config. It returns a tuple containing username, password, port, and host. It first checks if the rhostport is empty and returns None for all values. Then, it parses the rhostport and extracts the username, password, port, and host based on the given format.", "Arguments": ":param rhostport: str. The input rhostport variable to be parsed.\n:return: Tuple. A tuple containing username, password, port, and host.\n```"}, "tests": ["tests/ssh/test_parse_hostport.py::test_username_and_host", "tests/ssh/test_parse_hostport.py::test_host_and_port", "tests/ssh/test_parse_hostport.py::test_host_only"], "indent": 4}
{"namespace": "flower.utils.search.stringified_dict_contains_value", "type": "function", "project_path": "System/flower", "completion_path": "System/flower/flower/utils/search.py", "signature_position": [62, 62], "body_position": [67, 80], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if a dictionary in the form of a string like \"{'test': 5}\" contains the input key/value pair. It is faster than creating an actual dictionary from a string since this operation is called for each task in case of kwargs search.", "Arguments": ":param key: The key to be searched in the dictionary.\n:param value: The value to be searched in the dictionary.\n:param str_dict: str. The dictionary in the form of a string.\n:return: bool. True if the key/value pair is found in the dictionary, False otherwise."}, "tests": ["tests/unit/utils/test_search.py::TestStringfiedDictChecker::test_works_for_nonexisting_kwargs", "tests/unit/utils/test_search.py::TestStringfiedDictChecker::test_works_for_kwargs_in_different_parts_of_string", "tests/unit/utils/test_search.py::TestStringfiedDictChecker::test_works_for_no_kwargs", "tests/unit/utils/test_search.py::TestStringfiedDictChecker::test_stringifies_args"], "indent": 4}
{"namespace": "flower.utils.abs_path", "type": "function", "project_path": "System/flower", "completion_path": "System/flower/flower/utils/__init__.py", "signature_position": [32, 32], "body_position": [33, 37], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the absolute path of the given input path. It first expands the user path and then checks if the path is absolute. If not, it appends the current working directory to the path.", "Arguments": ":param path: str. The input path.\n:return: str. The absolute path of the input path."}, "tests": ["tests/unit/utils/test_utils.py::TestAbsPath::test_home_path", "tests/unit/utils/test_utils.py::TestAbsPath::test_relative_path_with_pwd", "tests/unit/utils/test_utils.py::TestAbsPath::test_absolute_path"], "indent": 4}
{"namespace": "flower.utils.strtobool", "type": "function", "project_path": "System/flower", "completion_path": "System/flower/flower/utils/__init__.py", "signature_position": [44, 44], "body_position": [51, 56], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert a string representation of truth to true (1) or false (0). It checks the input string and returns 1 if the input string is a true value and 0 if the input string is a false value. It raises a ValueError if the input string is neither a true value nor a false value.", "Arguments": ":param val: str. The string representation of truth. True values are 'y', 'yes', 't', 'true', 'on', and '1'; false values are 'n', 'no', 'f', 'false', 'off', and '0'. Raises ValueError if 'val' is anything else.\n:return: int. 1 if the input string is a true value, 0 if the input string is a false value."}, "tests": ["tests/unit/utils/test_utils.py::TestStrtobool::test_invalid_value", "tests/unit/utils/test_utils.py::TestStrtobool::test_false_values", "tests/unit/utils/test_utils.py::TestStrtobool::test_true_values"], "indent": 4}
{"namespace": "sshuttle.methods.get_method", "type": "function", "project_path": "System/sshuttle", "completion_path": "System/sshuttle/sshuttle/methods/__init__.py", "signature_position": [103, 103], "body_position": [104, 105], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function imports a module named \"sshuttle.methods.{method_name}\" and returns an instance of the Method class from the module.", "Arguments": ":param method_name: str. The name of the method to import.\n:return: Method. An instance of the Method class from the imported module.\n```"}, "tests": ["tests/client/test_methods_nat.py::test_recv_udp", "tests/client/test_methods_nat.py::test_setup_tcp_listener", "tests/client/test_methods_nat.py::test_send_udp", "tests/client/test_methods_nat.py::test_get_tcp_dstip", "tests/client/test_methods_nat.py::test_get_supported_features"], "indent": 4}
{"namespace": "trailscraper.iam.all_known_iam_permissions", "type": "function", "project_path": "Security/trailscraper", "completion_path": "Security/trailscraper/trailscraper/iam.py", "signature_position": [173, 173], "body_position": [175, 176], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a list of all known IAM actions. It joins the dirname of the current python script and 'known-iam-actions.txt' and return the lines in the file as a line set.", "Arguments": ":param: No input parameters.\n:return: set. A set of lines."}, "tests": ["tests/iam/known_iam_actions_test.py::test_all_iam_permissions"], "indent": 4}
{"namespace": "trailscraper.cloudtrail.parse_records", "type": "function", "project_path": "Security/trailscraper", "completion_path": "Security/trailscraper/trailscraper/cloudtrail.py", "signature_position": [240, 240], "body_position": [242, 243], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes a list of JSON records and converts them into Record objects. It uses the _parse_record function to parse each JSON record and then filters out any None values from the parsed records.", "Arguments": ":param json_records: List. A list of JSON records to be parsed.\n:return: List. A list of Record objects parsed from the JSON records."}, "tests": ["tests/cloudtrail/cloudtrail_test.py::test_parse_records_should_ignore_records_that_cant_be_parsed"], "indent": 4}
{"namespace": "pycoin.satoshi.IntStreamer.IntStreamer.int_to_script_bytes", "type": "method", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/satoshi/IntStreamer.py", "signature_position": [31, 31], "body_position": [32, 46], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert an integer to a script byte. It first checks if the integer is 0 and returns an empty byte if true. Then, it checks if the integer is negative and converts it to a positive value. It then converts the integer to a bytearray and cast it to bytes.", "Arguments": ":param class_: A class.\n:param v: int. The integer to be converted to a script byte.\n:return: bytes. The bytes corresponding to the input integer."}, "tests": ["tests/tools_test.py::ToolsTest::test_int_to_from_script_bytes"], "indent": 8}
{"namespace": "pycoin.satoshi.stackops.do_OP_2DROP", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/satoshi/stackops.py", "signature_position": [33, 33], "body_position": [34, 35], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function pops the top two elements from the stack.", "Arguments": ":param stack: List. The stack from which the top two elements are removed.\n:return: No return values."}, "tests": ["tests/script/stackops_test.py::StackOpsTest::test_do_OP_2DROP"], "indent": 4}
{"namespace": "pycoin.satoshi.stackops.do_OP_2DUP", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/satoshi/stackops.py", "signature_position": [38, 39], "body_position": [40, 41], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function duplicates the top two elements of the stack and appends them to the stack, like this: (x1 x2 -- x1 x2 x1 x2)", "Arguments": ":param stack: List. The stack containing elements.\n:return: No return values."}, "tests": ["tests/script/stackops_test.py::StackOpsTest::test_do_OP_2DUP"], "indent": 4}
{"namespace": "pycoin.satoshi.stackops.do_OP_3DUP", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/satoshi/stackops.py", "signature_position": [44, 45], "body_position": [46, 48], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function duplicates the top three elements of the stack and appends them to the stack, like this: (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)", "Arguments": ":param stack: List. The stack containing elements.\n:return: No return values."}, "tests": ["tests/script/stackops_test.py::StackOpsTest::test_do_OP_3DUP"], "indent": 4}
{"namespace": "trailscraper.s3_download._s3_key_prefixes", "type": "function", "project_path": "Security/trailscraper", "completion_path": "Security/trailscraper/trailscraper/s3_download.py", "signature_position": [22, 22], "body_position": [23, 36], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function generates a list of S3 key prefixes based on the given parameters. It first calculates the delta between the two dates, then generates a list of dates based on the delta. It then creates a list of S3 key prefixes based on the organization IDs, account IDs, regions, and dates.", "Arguments": ":param prefix: String. The prefix for the S3 key.\n:param org_ids: List of Strings. The organization IDs.\n:param account_ids: List of Strings. The account IDs.\n:param regions: List of Strings. The regions.\n:param from_date: Datetime. The start date.\n:param to_date: Datetime. The end date.\n:return: List of Strings. The list of S3 key prefixes."}, "tests": ["tests/s3/key_prefixes_test.py::test_should_generate_prefixes_for_multiple_days", "tests/s3/key_prefixes_test.py::test_should_generate_prefixes_for_one_day", "tests/s3/key_prefixes_test.py::test_should_generate_prefixes_for_multiple_accounts_on_one_day", "tests/s3/key_prefixes_test.py::test_should_generate_prefixes_for_regions", "tests/s3/key_prefixes_test.py::test_should_generate_prefixes_for_one_day_when_datetime_contains_time"], "indent": 4}
{"namespace": "pycoin.satoshi.stackops.do_OP_2OVER", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/satoshi/stackops.py", "signature_position": [51, 52], "body_position": [53, 54], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function duplicates the -3rd and -4th element to the top of the stack, like this: (x1 x2 x3 x4 \"top\" -- x1 x2 x3 x4 x1 x2 \"top\")", "Arguments": ":param stack: List. The stack containing the items to be duplicated.\n:return: No return values."}, "tests": ["tests/script/stackops_test.py::StackOpsTest::test_do_OP_2OVER"], "indent": 4}
{"namespace": "pycoin.satoshi.stackops.do_OP_2SWAP", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/satoshi/stackops.py", "signature_position": [63, 63], "body_position": [64, 65], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function move the third and fourth elements to the top of the stack, preserving their order.", "Arguments": ":param stack: List. The stack containing elements to be swapped.\n:return: No return values."}, "tests": ["tests/script/stackops_test.py::StackOpsTest::test_do_OP_2SWAP"], "indent": 4}
{"namespace": "pycoin.satoshi.stackops.do_OP_IFDUP", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/satoshi/stackops.py", "signature_position": [68, 68], "body_position": [69, 70], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function duplicates the top element of the stack onto the top if it is not zero.", "Arguments": ":param stack: List. The stack to be operated on.\n:return: No return values."}, "tests": ["tests/script/stackops_test.py::StackOpsTest::test_do_OP_IFDUP"], "indent": 4}
{"namespace": "pycoin.satoshi.stackops.do_OP_NIP", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/satoshi/stackops.py", "signature_position": [81, 81], "body_position": [82, 84], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function removes the second item from the top of the stack and keeps the top item unchanged.", "Arguments": ":param stack: List. The stack from which the items are popped and appended.\n:return: No return values."}, "tests": ["tests/script/stackops_test.py::StackOpsTest::test_do_OP_NIP"], "indent": 4}
{"namespace": "pycoin.satoshi.stackops.do_OP_TUCK", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/satoshi/stackops.py", "signature_position": [99, 99], "body_position": [100, 104], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function performs the TUCK operation on the input stack. It pops the top two elements from the stack, and then pushes them back in the reverse order, followed by the original top element.", "Arguments": ":param stack: List. The input stack on which the TUCK operation is to be performed.\n:return: No return values."}, "tests": ["tests/script/stackops_test.py::StackOpsTest::test_do_OP_TUCK"], "indent": 4}
{"namespace": "pycoin.satoshi.stackops.do_OP_CAT", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/satoshi/stackops.py", "signature_position": [107, 107], "body_position": [108, 110], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function pops the top two values from the stack, concatenates them, and pushes the result back to the stack.", "Arguments": ":param stack: List. The stack containing the values to be concatenated.\n:return: No return values."}, "tests": ["tests/script/stackops_test.py::StackOpsTest::test_do_OP_CAT"], "indent": 4}
{"namespace": "pycoin.crack.ecdsa.crack_secret_exponent_from_k", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/crack/ecdsa.py", "signature_position": [2, 2], "body_position": [6, 7], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Given a signature of a signed value and a known k, this function returns the secret exponent for RSA.", "Arguments": ":param generator: The generator.\n:param signed_value: The signed value.\n:param sig: The signature.\n:param k: The known k value.\n:return: The secret exponent."}, "tests": ["tests/crack_sig_test.py::CrackSigTest::test_crack_secret_exponent_from_k"], "indent": 4}
{"namespace": "pycoin.crack.ecdsa.crack_k_from_sigs", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/crack/ecdsa.py", "signature_position": [10, 10], "body_position": [29, 34], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calculates the value of k from the given signatures and values in RSA domain.", "Arguments": ":param generator: The generator value.\n:param sig1: The first signature.\n:param val1: The first value.\n:param sig2: The second signature.\n:param val2: The second value.\n:return: The value of k."}, "tests": ["tests/crack_sig_test.py::CrackSigTest::test_crack_k_from_sigs"], "indent": 4}
{"namespace": "pycoin.message.make_parser_and_packer.standard_streamer", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/message/make_parser_and_packer.py", "signature_position": [209, 209], "body_position": [214, 217], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Create a satoshi_streamer, which parses and packs using the bitcoin protocol (mostly the custom way arrays and integers are parsed and packed) through register array length parsing function and register other parsing functions.", "Arguments": ":param parsing_functions: The parsing functions to be registered with the streamer.\n:param parse_satoshi_int: The function to parse satoshi integers. Defaults to parse_satoshi_int.\n:return: Streamer. The created streamer instance."}, "tests": ["tests/message_test.py::MessageTest::test_make_parser_and_packer"], "indent": 4}
{"namespace": "pycoin.key.subpaths.subpaths_for_path_range", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/key/subpaths.py", "signature_position": [4, 4], "body_position": [16, 36], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns an iterator of paths based on the given path range. It processes the input path range like the format \"xx/xx/x-x\" and returns an iterator of paths based on the given conditions \"xx/xx/x1, xx/xx/x2\" and so on.", "Arguments": ":param path_range: String. The input path range.\n:param hardening_chars: String. The characters that indicate hardening. Defaults to \"'pH\".\n:return: Iterator. An iterator of paths based on the given path range."}, "tests": ["tests/keychain_test.py::KeychainTest::test_keychain"], "indent": 4}
{"namespace": "pyt.core.project_handler._is_python_file", "type": "function", "project_path": "Security/python-taint", "completion_path": "Security/python-taint/pyt/core/project_handler.py", "signature_position": [73, 73], "body_position": [74, 76], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the given file path is a Python file by checking its file extension.", "Arguments": ":param path: String. The file path to be checked.\n:return: Bool. True if the file is a Python file, False otherwise."}, "tests": ["tests/core/project_handler_test.py::ProjectHandlerTest::test_is_python_file"], "indent": 4}
{"namespace": "pycoin.encoding.hexbytes.h2b", "type": "function", "project_path": "Security/pycoin", "completion_path": "Security/pycoin/pycoin/encoding/hexbytes.py", "signature_position": [4, 4], "body_position": [12, 15], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts a hexadecimal string to a binary string using the binascii.unhexlify method. It accepts a unicode string and raises a ValueError on failure.", "Arguments": ":param h: String. The hexadecimal string to be converted to binary.\n:return: Binary string. The converted binary string."}, "tests": ["tests/sign_test.py::SignTest::test_p2sh_multisig_sequential_signing", "tests/sign_test.py::SignTest::test_sign_p2sh", "tests/hexbytes.py::HexbytesTest::test_h2b", "tests/validation_test.py::ValidationTest::test_validate_block_data", "tests/tools_test.py::ToolsTest::test_tx_7e0114e93f903892b4dff5526a8cab674b2825fd715c4a95f852a1aed634a0f6"], "indent": 4}
{"namespace": "zxcvbn.scoring.calc_average_degree", "type": "function", "project_path": "Security/zxcvbn-python", "completion_path": "Security/zxcvbn-python/zxcvbn/scoring.py", "signature_position": [10, 10], "body_position": [11, 17], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Calculate the average degree of a graph. It iterates through the graph and calculates the average degree based on the number of neighbors for each node.", "Arguments": ":param graph: Dictionary. The input graph represented as a dictionary where keys are nodes and values are lists of neighboring nodes.\n:return: Float. The average degree of the graph."}, "tests": ["tests/scoring_test.py::test_returns_average_degree"], "indent": 4}
{"namespace": "zxcvbn.scoring.nCk", "type": "function", "project_path": "Security/zxcvbn-python", "completion_path": "Security/zxcvbn-python/zxcvbn/scoring.py", "signature_position": [29, 29], "body_position": [31, 42], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Calculate the number of combinations of n items taken k at a time.", "Arguments": ":param n: Integer. The total number of items.\n:param k: Integer. The number of items to choose.\n:return: Integer. The number of combinations of n items taken k at a time."}, "tests": ["tests/scoring_test.py::test_uppercase_variants", "tests/scoring_test.py::test_l33t_variants", "tests/scoring_test.py::test_nCk", "tests/scoring_test.py::test_spatial_guesses"], "indent": 4}
{"namespace": "zxcvbn.matching.relevant_l33t_subtable", "type": "function", "project_path": "Security/zxcvbn-python", "completion_path": "Security/zxcvbn-python/zxcvbn/matching.py", "signature_position": [134, 134], "body_position": [135, 145], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function creates a subtable based on the given password and table. It first creates a dictionary of characters in the password and then creates a subtable based on the relevant substitutions in the table.", "Arguments": ":param password: String. The password to be used for creating the subtable.\n:param table: Dictionary. The table containing the substitutions for each letter.\n:return: Dictionary. The created subtable."}, "tests": ["tests/matching_test.py::test_l33t_matching"], "indent": 4}
{"namespace": "zxcvbn.matching.translate", "type": "function", "project_path": "Security/zxcvbn-python", "completion_path": "Security/zxcvbn-python/zxcvbn/matching.py", "signature_position": [204, 204], "body_position": [205, 212], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Translate the input string based on the given character map. It replaces the characters in the input string with the corresponding values from the character map. The output format is splitted by the space.", "Arguments": ":param string: String. The input string to be translated.\n:param chr_map: Dictionary. The character map containing the mapping of characters to their corresponding values.\n:return: String. The translated string."}, "tests": ["tests/matching_test.py::test_matching_utils"], "indent": 4}
{"namespace": "tools.cgrep.get_nets", "type": "function", "project_path": "Security/capirca", "completion_path": "Security/capirca/tools/cgrep.py", "signature_position": [380, 380], "body_position": [390, 394], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function retrieves a list of all networks that are inside a network object. It iterates through the input network objects, retrieves the networks inside each object from the network and service definitions, and returns the results.", "Arguments": ":param objects: network objects. List of network objects for which the networks need to be retrieved.\n:param db: network and service definitions. The database containing network and service definitions.\n:return: List. List of tuples containing the network object and the corresponding network inside it."}, "tests": ["tests/lib/cgrep_test.py::CgrepTest::test_token_to_ips", "tests/lib/cgrep_test.py::CgrepTest::test_token_to_ip_fail"], "indent": 2}
{"namespace": "tools.cgrep.get_ports", "type": "function", "project_path": "Security/capirca", "completion_path": "Security/capirca/tools/cgrep.py", "signature_position": [447, 447], "body_position": [458, 462], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function gets the ports and protocols defined in a service group. It iterates through each service in the service group and retrieves the corresponding port and protocol from the network and service definitions.", "Arguments": ":param svc_group: List of strings. A list of strings for each service group.\n:param db: Network and service definitions.\n:return: List of tuples. A list of tuples for each service defined, in the format: (service name, \"<port>/<protocol>\")."}, "tests": ["tests/lib/cgrep_test.py::CgrepTest::test_svc_to_port_fail", "tests/lib/cgrep_test.py::CgrepTest::test_svc_to_port"], "indent": 2}
{"namespace": "tools.cgrep.compare_ip_token", "type": "function", "project_path": "Security/capirca", "completion_path": "Security/capirca/tools/cgrep.py", "signature_position": [426, 426], "body_position": [436, 444], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if a network IP is contained in a network object. It iterates through the list of IPs and checks if each IP is in the network object. It then returns a string stating the results.", "Arguments": ":param options: The options sent to the script.\n:param db: Network and service definitions.\n:return: String. The end-user string stating the results."}, "tests": ["tests/lib/cgrep_test.py::CgrepTest::test_ip_in_token", "tests/lib/cgrep_test.py::CgrepTest::test_ipv6_in_token", "tests/lib/cgrep_test.py::CgrepTest::test_ipv6_in_token_fail", "tests/lib/cgrep_test.py::CgrepTest::test_ip_in_token_fail"], "indent": 2}
{"namespace": "tools.cgrep.get_services", "type": "function", "project_path": "Security/capirca", "completion_path": "Security/capirca/tools/cgrep.py", "signature_position": [465, 465], "body_position": [476, 482], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function finds any services that include a specific port/protocol pair. It retrieves the port and protocol from the options and then searches the network and service definitions to find services containing this pair.", "Arguments": ":param options: The options sent to the script.\n:param db: Network and service definitions.\n:return: Tuple. The port, protocol, and a list of services containing this pair."}, "tests": ["tests/lib/cgrep_test.py::CgrepTest::test_get_port_parents_range_udp", "tests/lib/cgrep_test.py::CgrepTest::test_get_port_parents", "tests/lib/cgrep_test.py::CgrepTest::test_get_port_parents_fail", "tests/lib/cgrep_test.py::CgrepTest::test_get_port_parents_range_tcp"], "indent": 2}
{"namespace": "asyncssh.packet.String", "type": "function", "project_path": "Security/asyncssh", "completion_path": "Security/asyncssh/asyncssh/packet.py", "signature_position": [67, 67], "body_position": [70, 73], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function encodes a byte string or UTF-8 string value. It first checks if the input value is a string, then encodes it to UTF-8. It then returns the length of the value in bytes followed by the value itself.", "Arguments": ":param value: Union[bytes, str]. The input value to be encoded, which can be either a byte string or a UTF-8 string.\n:return: bytes. The encoded byte string value."}, "tests": ["tests/test_agent.py::_TestAgent::test_get_sk_keys", "tests/test_agent.py::_TestAgent::test_query_extensions", "tests/test_packet.py::_TestPacket::test_unicode"], "indent": 4}
{"namespace": "msticpy.analysis.anomalous_sequence.utils.laplace_smooth.laplace_smooth_cmd_counts", "type": "function", "project_path": "Security/msticpy", "completion_path": "Security/msticpy/msticpy/analysis/anomalous_sequence/utils/laplace_smooth.py", "signature_position": [12, 18], "body_position": [45, 56], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Apply laplace smoothing to the input counts for the cmds. It adds 1 to each of the counts, including the unk_token, to handle unseen commands. It's used for smoothing individual command counts (seq1_counts) and sequence command counts of length 2 (seq2_counts).", "Arguments": ":param seq1_counts: DefaultDict[str, int]. Individual command counts.\n:param seq2_counts: DefaultDict[str, DefaultDict[str, int]]. Sequence command (length 2) counts.\n:param start_token: str. Dummy command to signify the start of a session (e.g. \"##START##\").\n:param end_token: str. Dummy command to signify the end of a session (e.g. \"##END##\").\n:param unk_token: str. Dummy command to signify an unseen command (e.g. \"##UNK##\").\n:return: Tuple[DefaultDict[str, int], DefaultDict[str, DefaultDict[str, int]]]. Laplace smoothed counts: individual command counts, sequence command (length 2) counts."}, "tests": ["tests/analysis/test_anom_seq_laplace_smooth.py::TestLaplaceSmooth::test_laplace_smooth_cmd_counts"], "indent": 4}
{"namespace": "msticpy.analysis.anomalous_sequence.utils.laplace_smooth.laplace_smooth_param_counts", "type": "function", "project_path": "Security/msticpy", "completion_path": "Security/msticpy/msticpy/analysis/anomalous_sequence/utils/laplace_smooth.py", "signature_position": [59, 64], "body_position": [89, 99], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function applies Laplace smoothing to the input counts for the parameters. It adds 1 to each of the counts, including the unk_token, to handle unseen parameters. it's used for smoothing individual parameter counts (param_counts) and parameter conditional on command counts (cmd_param_counts).", "Arguments": ":param cmds: List[str]. List of all the possible commands (including the unk_token).\n:param param_counts: DefaultDict[str, int]. Individual parameter counts.\n:param cmd_param_counts: DefaultDict[str, DefaultDict[str, int]]. Parameter conditional on command counts.\n:param unk_token: str. Dummy command to signify an unseen command (e.g. \"##UNK##\").\n:return: Tuple[DefaultDict[str, int], DefaultDict[str, DefaultDict[str, int]]]. Individual parameter probabilities, parameter conditional on command probabilities."}, "tests": ["tests/analysis/test_anom_seq_laplace_smooth.py::TestLaplaceSmooth::test_laplace_smooth_param_counts"], "indent": 4}
{"namespace": "msticpy.analysis.anomalous_sequence.utils.laplace_smooth.laplace_smooth_value_counts", "type": "function", "project_path": "Security/msticpy", "completion_path": "Security/msticpy/msticpy/analysis/anomalous_sequence/utils/laplace_smooth.py", "signature_position": [102, 107], "body_position": [132, 142], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Apply laplace smoothing to the input counts for the values. It adds 1 to each of the counts, including the unk_token. By including the unk_token, it can handle unseen values. It smooths individual value counts (value_counts) and value conditional on parameter counts (param_value_counts).", "Arguments": ":param params: List of string. List of all possible params, including the unk_token.\n:param value_counts: DefaultDict of string and integer. Individual value counts.\n:param param_value_counts: DefaultDict of string and DefaultDict of string and integer. Value conditional on param counts.\n:param unk_token: String. Dummy command to signify an unseen command (e.g. \"##UNK##\").\n:return: Tuple of DefaultDict of string and integer, DefaultDict of string and DefaultDict of string and integer. Individual value probabilities, value conditional on param probabilities."}, "tests": ["tests/analysis/test_anom_seq_laplace_smooth.py::TestLaplaceSmooth::test_laplace_smooth_value_counts"], "indent": 4}
{"namespace": "diffprivlib.validation.check_epsilon_delta", "type": "function", "project_path": "Security/diffprivlib", "completion_path": "Security/diffprivlib/diffprivlib/validation.py", "signature_position": [28, 28], "body_position": [47, 57], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the epsilon and delta are valid values for differential privacy. It raises errors including \"Epsilon and delta must be numeric\", \"Epsilon must be non-negative\",\"Delta must be in [0, 1]\",\"Epsilon and Delta cannot both be zero\" if the checks fail. It also checks that both epsilon and delta cannot be simultaneously zero unless allow_zero is set to True.", "Arguments": ":param epsilon: float. Epsilon parameter for differential privacy. Must be non-negative.\n:param delta: float. Delta parameter for differential privacy. Must be on the unit interval, [0, 1].\n:param allow_zero: bool, default: False. Allow epsilon and delta both be zero.\n:return: No return value."}, "tests": ["tests/test_check_epsilon_delta.py::TestCheckEpsilonDelta::test_real_inputs", "tests/test_check_epsilon_delta.py::TestCheckEpsilonDelta::test_wrong_delta", "tests/test_check_epsilon_delta.py::TestCheckEpsilonDelta::test_all_zero", "tests/test_check_epsilon_delta.py::TestCheckEpsilonDelta::test_neg_eps"], "indent": 4}
{"namespace": "diffprivlib.utils.check_random_state", "type": "function", "project_path": "Security/diffprivlib", "completion_path": "Security/diffprivlib/diffprivlib/utils.py", "signature_position": [75, 75], "body_position": [93, 102], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function turns the seed into a np.random.RandomState or secrets.SystemRandom instance based on the given condition. If seed is None and secure is False, return the RandomState singleton used by np.random. If seed is None and secure is True, return a SystemRandom instance from secrets. If seed is an int, return a new RandomState instance seeded with seed. If seed is already a RandomState or SystemRandom instance, return it. Otherwise raise ValueError.", "Arguments": ":param seed : None, int or instance of RandomState.\n:param secure : bool, default: False. Specifies if a secure random number generator from secrets can be used.\n:return: np.random.RandomState or secrets.SystemRandom instance."}, "tests": ["tests/test_check_random_state.py::TestCheckRandomState::test_not_secure", "tests/models/test_GaussianNB.py::TestGaussianNB::test_noisy_count", "tests/models/test_GaussianNB.py::TestGaussianNB::test_missing_bounds", "tests/models/test_GaussianNB.py::TestGaussianNB::test_different_results", "tests/test_check_random_state.py::TestCheckRandomState::test_secure"], "indent": 4}
{"namespace": "diffprivlib.validation.clip_to_norm", "type": "function", "project_path": "Security/diffprivlib", "completion_path": "Security/diffprivlib/diffprivlib/validation.py", "signature_position": [135, 135], "body_position": [152, 164], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function clips the examples of a 2-dimensional array to a given maximum norm. After clipping, all examples have a 2-norm of at most `clip`. It raises errors including \"Input array must be a numpy array, got {type(array)}.\", \"input array must be 2-dimensional, got {array.ndim} dimensions.\", \"Clip value must be numeric, got {type(clip)}.\" and \"Clip value must be strictly positive, got {clip}.\".", "Arguments": ":param array: np.ndarray. Array to be clipped.\n:param clip: float. Norm at which to clip each example.\n:return: np.ndarray. The clipped array."}, "tests": ["tests/test_clip_to_norm.py::TestClipToNorm::test_simple", "tests/test_clip_to_norm.py::TestClipToNorm::test_iris", "tests/test_clip_to_norm.py::TestClipToNorm::test_incorrect_parameterisation"], "indent": 4}
{"namespace": "diffprivlib.models.pca.PCA.fit_transform", "type": "method", "project_path": "Security/diffprivlib", "completion_path": "Security/diffprivlib/diffprivlib/models/pca.py", "signature_position": [283, 283], "body_position": [284, 288], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "It fits the model with the input data and then applies the dimensionality reduction on it.", "Arguments": ":param self: PCA. An instance of the PCA class.\n:param X: Array-like. The input data.\n:param y: Array-like. The target variable. Defaults to None.\n:return: Array-like. The transformed data."}, "tests": ["tests/models/test_PCA.py::TestPCA::test_fit_transform"], "indent": 8}
{"namespace": "discord.utils.get_slots", "type": "function", "project_path": "Software-Development/discord-py", "completion_path": "Software-Development/discord-py/discord/utils.py", "signature_position": [721, 721], "body_position": [722, 726], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns an iterator that yields the names of the slots in the class and its base classes. It iterates through the class hierarchy and yields the slots of each class.", "Arguments": ":param cls: Type. The class for which the slots are to be retrieved.\n:return: Iterator. An iterator that yields the names of the slots in the class and its base classes."}, "tests": ["tests/test_utils.py::test_get_slots"], "indent": 4}
{"namespace": "discord.utils.is_inside_class", "type": "function", "project_path": "Software-Development/discord-py", "completion_path": "Software-Development/discord-py/discord/utils.py", "signature_position": [1178, 1186], "body_position": [1187, 1190], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Determine whether a given callable (function or method) is defined within a class. It checks the __qualname__ attribute of the callable to analyze the dotted path that denotes its qualified name, considering the possibility of nested functions.", "Arguments": ":param func: Callable. The function to be checked.\n:return: Bool. True if the function is defined inside a class, False otherwise."}, "tests": ["tests/test_utils.py::test_is_inside_class"], "indent": 4}
{"namespace": "faker.utils.decorators.slugify", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/utils/decorators.py", "signature_position": [9, 10], "body_position": [11, 14], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a decorator that takes a function and returns a new function. The new function calls the original function and then slugifies the result.", "Arguments": ":param fn: Callable. The original function to be decorated.\n:return: Callable. The decorated function."}, "tests": ["tests/test_factory.py::FactoryTestCase::test_slugify"], "indent": 4}
{"namespace": "faker.utils.decorators.slugify_domain", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/utils/decorators.py", "signature_position": [17, 18], "body_position": [19, 22], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a decorator that takes a function and returns a new function. The new function calls the original function and then slugifies the result using the `text.slugify` function with the `allow_dots` parameter set to True.", "Arguments": ":param fn: Callable. The original function to be decorated.\n:return: Callable. The decorated function."}, "tests": ["tests/test_factory.py::FactoryTestCase::test_slugify"], "indent": 4}
{"namespace": "faker.utils.decorators.slugify_unicode", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/utils/decorators.py", "signature_position": [25, 26], "body_position": [27, 30], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a decorator that wraps the input function and returns a new function. The new function slugifies the output of the input function and returns the slugified string.", "Arguments": ":param fn: Callable. The input function to be wrapped and modified.\n:return: Callable. The wrapper function that slugifies the output of the input function."}, "tests": ["tests/test_factory.py::FactoryTestCase::test_slugify"], "indent": 4}
{"namespace": "faker.utils.loading.get_path", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/utils/loading.py", "signature_position": [10, 10], "body_position": [11, 28], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Get the path of the given module. It first checks if the system is frozen. If it is, it checks if it is frozen by PyInstaller or others and then returns the path accordingly. If the system is not frozen, it returns the path of the module. If the file is None, it raises RuntimeError(f\"Can't find path from module `{module}.\").", "Arguments": ":param module: ModuleType. The module for which the path is to be found.\n:return: str. The path of the given module."}, "tests": ["tests/utils/test_utils.py::UtilsTestCase::test_get_path"], "indent": 4}
{"namespace": "faker.utils.checksums.luhn_checksum", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/utils/checksums.py", "signature_position": [4, 4], "body_position": [5, 15], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Calculate the Luhn checksum for the given number. The Luhn algorithm is used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, National Provider Identifier numbers in the United States, and Canadian Social Insurance Numbers.", "Arguments": ":param number: float. The number for which the Luhn checksum needs to be calculated.\n:return: int. The Luhn checksum for the given number."}, "tests": ["tests/providers/test_company.py::TestFrFr::test_siret", "tests/utils/test_utils.py::UtilsTestCase::test_valid_luhn", "tests/providers/test_company.py::TestFrFr::test_siren"], "indent": 4}
{"namespace": "faker.utils.datasets.add_ordereddicts", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/utils/datasets.py", "signature_position": [6, 6], "body_position": [7, 8], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes multiple ordered dictionaries and combines them into a single ordered dictionary. It first extracts the items from each input ordered dictionary and then combines them into a single ordered dictionary.", "Arguments": ":param odicts: OrderedDictType. Multiple ordered dictionaries to be combined.\n:return: OrderedDictType. The combined ordered dictionary."}, "tests": ["tests/utils/test_utils.py::UtilsTestCase::test_add_ordereddicts"], "indent": 4}
{"namespace": "faker.providers.person.pl_PL.checksum_identity_card_number", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/providers/person/pl_PL/__init__.py", "signature_position": [7, 7], "body_position": [11, 16], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calculates and returns a control digit for a given list of characters based on the Identity Card Number standards. This control digit is often used for error checking and validation of identity card numbers. The weights for check digits is [7, 3, 1, 0, 7, 3, 1, 7, 3].", "Arguments": ":param characters: Sequence of Union of string and integer. A list of characters for which the control digit is to be calculated.\n:return: Integer. The calculated control digit."}, "tests": ["tests/providers/test_person.py::TestPlPL::test_identity_card_number_checksum"], "indent": 4}
{"namespace": "faker.providers.company.pl_PL.regon_checksum", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/providers/company/pl_PL/__init__.py", "signature_position": [6, 6], "body_position": [10, 21], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calculates and returns a control digit for a given list of digits based on the REGON standard. Ths weights for check digits is [8, 9, 2, 3, 4, 5, 6, 7].", "Arguments": ":param digits: List of integers. The list of digits for which the control digit is to be calculated.\n:return: Integer. The calculated control digit."}, "tests": ["tests/providers/test_company.py::TestPlPl::test_regon_checksum"], "indent": 4}
{"namespace": "faker.providers.company.ru_RU.calculate_checksum", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/providers/company/ru_RU/__init__.py", "signature_position": [6, 6], "body_position": [7, 12], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "The function is designed to compute a checksum for a given string value based on a specific set of factors. This type of checksum is commonly used in various applications, including identification numbers. The function defines a list of factors [3, 7, 2, 4, 10, 3, 5, 9, 4, 6, 8].", "Arguments": ":param value: String. The input value for which the checksum needs to be calculated.\n:return: String. The calculated checksum value."}, "tests": ["tests/providers/test_company.py::TestRuRu::test_individuals_inn", "tests/providers/test_company.py::TestRuRu::test_calculate_checksum_nine_digits", "tests/providers/test_company.py::TestRuRu::test_businesses_inn"], "indent": 4}
{"namespace": "faker.providers.company.pl_PL.local_regon_checksum", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/providers/company/pl_PL/__init__.py", "signature_position": [24, 24], "body_position": [28, 39], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calculates and returns a control digit for a given list of digits based on the local REGON standard. Ths weights for check digits is [2, 4, 8, 5, 0, 9, 7, 3, 6, 1, 2, 4, 8].", "Arguments": ":param digits: List of integers. The list of digits for which the control digit is to be calculated.\n:return: Integer. The calculated control digit."}, "tests": ["tests/providers/test_company.py::TestPlPl::test_local_regon_checksum"], "indent": 4}
{"namespace": "faker.providers.company.pl_PL.company_vat_checksum", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/providers/company/pl_PL/__init__.py", "signature_position": [42, 42], "body_position": [46, 54], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calculates and returns a control digit for a given list of digits based on the NIP standard. The weights of check digits is [6, 5, 7, 2, 3, 4, 5, 6, 7].", "Arguments": ":param digits: List of integers. The list of digits for which the control digit needs to be calculated.\n:return: Integer. The calculated control digit."}, "tests": ["tests/providers/test_company.py::TestPlPl::test_company_vat_checksum"], "indent": 4}
{"namespace": "faker.providers.company.pt_BR.company_id_checksum", "type": "function", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/providers/company/pt_BR/__init__.py", "signature_position": [6, 6], "body_position": [7, 20], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Calculate the checksum of the company ID based on the given digits. It first calculates the checksum based on the weights and digits, and then appends the calculated checksum to the input digits. The weights of check digits is [6, 5, 4, 3, 2, 9, 8, 7, 6, 5, 4, 3, 2].", "Arguments": ":param digits: List of integers. The list of digits representing the company ID.\n:return: List of integers. The calculated checksum digits."}, "tests": ["tests/providers/test_company.py::TestPtBr::test_company_id_checksum"], "indent": 4}
{"namespace": "faker.providers.misc.Provider.binary", "type": "method", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/providers/misc/__init__.py", "signature_position": [43, 43], "body_position": [52, 57], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Generate a random binary blob of the specified length. If the faker instance has been seeded, the performance will be significantly reduced to conform to the seeding.", "Arguments": ":param self: Provider. An instance of the Provider class.\n:param length: int. The length of the binary blob to be generated. Defaults to 1 * 1024 * 1024.\n:return: bytes. The generated random binary blob."}, "tests": ["tests/test_factory.py::FactoryTestCase::test_binary"], "indent": 8}
{"namespace": "faker.providers.python.Provider.pystr", "type": "method", "project_path": "Software-Development/Faker", "completion_path": "Software-Development/Faker/faker/providers/python/__init__.py", "signature_position": [105, 111], "body_position": [121, 131], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function generates a random string of upper and lowercase letters. It can generate a random string of a specific length between the minimum and maximum length. It can also add a prefix and suffix to the random string.", "Arguments": ":param self: Provider. An instance of the Provider class.\n:param min_chars: Optional integer. The minimum length of the random part. Defaults to None.\n:param max_chars: Integer. The maximum length of the random part. Defaults to 20.\n:param prefix: String. An optional prefix to prepend to the random string. Defaults to an empty string.\n:param suffix: String. An optional suffix to append to the random string. Defaults to an empty string.\n:return: String. Random of random length between min and max characters."}, "tests": ["tests/test_factory.py::FactoryTestCase::test_random_pystr_characters"], "indent": 8}
{"namespace": "dash._utils.AttributeDict.set_read_only", "type": "method", "project_path": "Software-Development/dash", "completion_path": "Software-Development/dash/dash/_utils.py", "signature_position": [92, 92], "body_position": [99, 103], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function designates named attributes as read-only with the corresponding message. It is an additive method, which means that making additional calls to this method will update existing messages and add to the current set of _read_only names.", "Arguments": ":param self: AttributeDict. An instance of the AttributeDict class.\n:param names: List of strings. The names of the attributes to be designated as read-only.\n:param msg: String. The message to be associated with the read-only attribute. Defaults to \"Attribute is read-only\".\n:return: No return value."}, "tests": ["tests/unit/library/test_utils.py::test_ddut001_attribute_dict"], "indent": 8}
{"namespace": "dash._utils.AttributeDict.first", "type": "method", "project_path": "Software-Development/dash", "completion_path": "Software-Development/dash/dash/_utils.py", "signature_position": [125, 125], "body_position": [126, 131], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the first non-empty value from the given list of names. If no names are provided, it returns the first value from the instance.", "Arguments": ":param self: AttributeDict. An instance of the AttributeDict class.\n:param names: String. A list of names to search for in the instance.\n:return: The first non-empty value from the list of names or the first value from the instance."}, "tests": ["tests/unit/library/test_utils.py::test_ddut001_attribute_dict"], "indent": 8}
{"namespace": "dash._get_paths.app_get_asset_url", "type": "function", "project_path": "Software-Development/dash", "completion_path": "Software-Development/dash/dash/_get_paths.py", "signature_position": [11, 11], "body_position": [12, 23], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the URL of the asset based on the given configuration and path. It first checks if the assets_external_path is set, if not, it uses requests_pathname_prefix. Then, it constructs the URL based on the configuration and path.", "Arguments": ":param config: Configuration. The configuration object.\n:param path: String. The path of the asset.\n:return: String. The URL of the asset."}, "tests": ["tests/unit/test_configs.py::test_pathname_prefix_assets"], "indent": 4}
{"namespace": "peewee.sort_models", "type": "function", "project_path": "Software-Development/peewee", "completion_path": "Software-Development/peewee/peewee.py", "signature_position": [7058, 7058], "body_position": [7059, 7078], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Sort the given models based on their dependencies. It uses a depth-first search to sort the models based on their dependencies and returns the sorted list of models.", "Arguments": ":param models: List. A list of model instances to be sorted.\n:return: List. The sorted list of model instances based on their dependencies."}, "tests": ["tests/models.py::TestModelAPIs::test_deferred_fk_dependency_graph", "tests/db_tests.py::TestSortModels::test_sort_models"], "indent": 4}
{"namespace": "dash._grouping.grouping_len", "type": "function", "project_path": "Software-Development/dash", "completion_path": "Software-Development/dash/dash/_grouping.py", "signature_position": [50, 50], "body_position": [59, 65], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "The function calculates the length of a grouping. The length is equal to the number of scalar values contained in the grouping, which is equivalent to the length of the list that would result from calling flatten_grouping on the grouping value.", "Arguments": ":param grouping: The grouping value to calculate the length of\n:return: non-negative integer"}, "tests": ["tests/unit/library/test_grouping.py::test_flatten_dict", "tests/unit/library/test_grouping.py::test_flatten_scalar", "tests/unit/library/test_grouping.py::test_flatten_dict_key_order", "tests/unit/library/test_grouping.py::test_flatten_list", "tests/unit/library/test_grouping.py::test_flatten_mixed"], "indent": 4}
{"namespace": "playhouse.kv.KeyValue.get", "type": "method", "project_path": "Software-Development/peewee", "completion_path": "Software-Development/peewee/playhouse/kv.py", "signature_position": [150, 150], "body_position": [151, 154], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Get the value of the given key in the KeyValue instance. If the key is not found, return the default value.", "Arguments": ":param self: KeyValue. An instance of the KeyValue class.\n:param key: The key to retrieve the value from the instance.\n:param default: The value to return if the key is not found in the instance. Defaults to None.\n:return: The value corresponding to the key or the default value if the key is not found."}, "tests": ["tests/kv.py::TestKeyValue::test_basic_apis"], "indent": 8}
{"namespace": "playhouse.kv.KeyValue.setdefault", "type": "method", "project_path": "Software-Development/peewee", "completion_path": "Software-Development/peewee/playhouse/kv.py", "signature_position": [156, 156], "body_position": [157, 161], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Set the default value for the key in the KeyValue instance. If the key is not found, it sets the default value for the key and returns it.", "Arguments": ":param self: KeyValue. An instance of the KeyValue class.\n:param key: The key to set the default value.\n:param default: The default value to set for the key. Defaults to None.\n:return: The value corresponding to the key."}, "tests": ["tests/kv.py::TestKeyValue::test_basic_apis"], "indent": 8}
{"namespace": "sslyze.plugins.certificate_info._certificate_utils.get_public_key_sha256", "type": "function", "project_path": "System/sslyze", "completion_path": "System/sslyze/sslyze/plugins/certificate_info/_certificate_utils.py", "signature_position": [54, 54], "body_position": [55, 57], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "It returns the SHA-256 hash of the public key in the given certificate.", "Arguments": ":param certificate: Certificate. The input certificate from which the public key is extracted.\n:return: bytes. The SHA-256 hash of the public key."}, "tests": ["tests/plugins_tests/certificate_info/test_certificate_utils.py::TestCertificateUtils::test_get_public_key_sha256"], "indent": 4}
{"namespace": "ydata_profiling.compare_reports._compare_title", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/compare_reports.py", "signature_position": [112, 112], "body_position": [113, 117], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Compare the titles in the list and return the result. If all titles are the same, it returns the title. Otherwise, it returns a string that compares the titles.", "Arguments": ":param titles: List of strings. The list of titles to be compared.\n:return: String. The result of the comparison."}, "tests": ["tests/unit/test_comparison.py::test_title"], "indent": 4}
{"namespace": "ydata_profiling.report.formatters.fmt_bytesize", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/report/formatters.py", "signature_position": [61, 61], "body_position": [71, 75], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts a number of bytes into a human-readable format. It iteratively divides the input number by 1024 and appends the appropriate unit (e.g., KiB, MiB, GiB) until the absolute value of the number is less than 1024.", "Arguments": ":param num: float. The number of bytes to format.\n:param suffix: str. The suffix to be appended to the formatted value. Defaults to \"B\".\n:return: str. The formatted value in a human-readable format."}, "tests": ["tests/unit/test_formatters.py::test_fmt_bytesize"], "indent": 4}
{"namespace": "ydata_profiling.report.formatters.fmt_percent", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/report/formatters.py", "signature_position": [79, 79], "body_position": [89, 94], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Format a ratio as a percentage. It checks for edge cases and returns the percentage with 1 point precision.", "Arguments": ":param value: Float. The ratio to be formatted as a percentage.\n:param edge_cases: Bool. Whether to check for edge cases. Defaults to True.\n:return: String. The formatted percentage with 1 point precision."}, "tests": ["tests/issues/test_issue215.py::test_issue215"], "indent": 4}
{"namespace": "ydata_profiling.report.formatters.fmt_numeric", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/report/formatters.py", "signature_position": [237, 237], "body_position": [247, 255], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Format any numeric value with the given precision.", "Arguments": ":param value: float. The numeric value to format.\n:param precision: int. The numeric precision. It defaults to 10 if not specified.\n:return: str. The numeric value with the given precision."}, "tests": ["tests/unit/test_formatters.py::test_fmt_numeric"], "indent": 4}
{"namespace": "ydata_profiling.report.formatters.fmt_array", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/report/formatters.py", "signature_position": [272, 272], "body_position": [282, 285], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function formats numpy arrays. It sets the threshold at which to show ellipsis and returns the string representation of the numpy array.", "Arguments": ":param value: np.ndarray. The array to format.\n:param threshold: Any. The threshold at which to show ellipsis. Defaults to np.nan.\n:return: str. The string representation of the numpy array."}, "tests": ["tests/unit/test_formatters.py::test_fmt_array"], "indent": 4}
{"namespace": "ydata_profiling.report.formatters.fmt_monotonic", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/report/formatters.py", "signature_position": [305, 305], "body_position": [306, 317], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a string based on the input value. The string returned is based on the value of the input integer.", "Arguments": ":param value: int. The input integer value.\n:return: str. The string based on the input value."}, "tests": ["tests/unit/test_formatters.py::test_fmt_monotonic", "tests/unit/test_formatters.py::test_fmt_monotonic_err"], "indent": 4}
{"namespace": "ydata_profiling.visualisation.plot._plot_pie_chart", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/visualisation/plot.py", "signature_position": [429, 431], "body_position": [445, 471], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function plots a pie chart to show category frequency based on the input data. It also allows the user to specify the colors and whether to hide the legend.", "Arguments": ":param data: pd.Series. Category frequencies with category names as index.\n:param colors: List. List of colors in a valid matplotlib format.\n:param hide_legend: Bool. If true, the legend is omitted. Defaults to False.\n:return: Tuple[plt.Axes, matplotlib.legend.Legend]. The pie chart and legend handler."}, "tests": ["tests/unit/test_plot.py::test_plot_pie_chart"], "indent": 4}
{"namespace": "ydata_profiling.visualisation.plot._prepare_heatmap_data", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/visualisation/plot.py", "signature_position": [802, 808], "body_position": [809, 842], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Prepare the data for a heatmap based on the given conditions. It processes the input dataframe and returns a new dataframe that is suitable for creating a heatmap.", "Arguments": ":param dataframe: pd.DataFrame. The input dataframe containing the data.\n:param entity_column: str. The name of the column containing the entities.\n:param sortby: Optional. Union[str, list]. The column or list of columns to sort by. Defaults to None.\n:param max_entities: int. The maximum number of entities to include in the heatmap. Defaults to 5.\n:param selected_entities: Optional. List of str. The list of selected entities to include in the heatmap. Defaults to None.\n:return: pd.DataFrame. The prepared dataframe for creating a heatmap.\n```"}, "tests": ["tests/unit/test_plot.py::test_timeseries_heatmap"], "indent": 4}
{"namespace": "ydata_profiling.visualisation.plot._create_timeseries_heatmap", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/visualisation/plot.py", "signature_position": [845, 849], "body_position": [850, 861], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Create a timeseries heatmap based on the given dataframe. It creates a heatmap with the specified color and size and returns the axes object.", "Arguments": ":param df: pd.DataFrame. The input dataframe for creating the heatmap.\n:param figsize: Tuple[int, int]. The size of the figure. Defaults to (12, 5).\n:param color: str. The color to be used for the heatmap. Defaults to \"#337ab7\".\n:return: plt.Axes. The axes object representing the created heatmap."}, "tests": ["tests/unit/test_plot.py::test_timeseries_heatmap"], "indent": 4}
{"namespace": "ydata_profiling.model.expectation_algorithms.generic_expectations", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/model/expectation_algorithms.py", "signature_position": [4, 6], "body_position": [7, 15], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function defines generic expectations for a given column in a batch. It checks if the column exists, if there are any missing values, and if all values are unique.", "Arguments": ":param name: str. The name of the column to be checked.\n:param summary: dict. A summary of the column statistics.\n:param batch: Any. The batch of data to be checked.\n:param *args: Additional arguments.\n:return: Tuple. A tuple containing the name of the column, its summary, and the batch."}, "tests": ["tests/unit/test_ge_integration_expectations.py::test_generic_expectations_min", "tests/unit/test_ge_integration_expectations.py::test_generic_expectations"], "indent": 4}
{"namespace": "ydata_profiling.model.expectation_algorithms.numeric_expectations", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/model/expectation_algorithms.py", "signature_position": [18, 20], "body_position": [21, 55], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "It checks the numeric expectations of the given batch and returns the name, summary, and batch.", "Arguments": ":param name: str. The name of the column.\n:param summary: dict. The summary of the column.\n:param batch: Any. The batch of data to be checked.\n:param *args: Any. Additional arguments.\n:return: Tuple[str, dict, Any]. The name, summary, and batch.\n```"}, "tests": ["tests/unit/test_ge_integration_expectations.py::test_numeric_expectations_min", "tests/unit/test_ge_integration_expectations.py::test_numeric_expectations"], "indent": 4}
{"namespace": "ydata_profiling.model.expectation_algorithms.categorical_expectations", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/model/expectation_algorithms.py", "signature_position": [58, 61], "body_position": [62, 71], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check the categorical expectations for the given batch and summary. It checks if the number of distinct values and the percentage of distinct values are below the threshold. If so, it expects the column values to be in the set of value counts without NaN.", "Arguments": ":param name: str. The name of the column.\n:param summary: dict. The summary of the column.\n:param batch: Any. The batch of data to be checked.\n:param *args: Any. Additional arguments.\n:return: Tuple[str, dict, Any]. The name, summary, and batch.\n```"}, "tests": ["tests/unit/test_ge_integration_expectations.py::test_categorical_expectations"], "indent": 4}
{"namespace": "ydata_profiling.model.expectation_algorithms.datetime_expectations", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/model/expectation_algorithms.py", "signature_position": [80, 82], "body_position": [83, 91], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function sets the expectations for the datetime values in the batch based on the summary. It checks if the \"min\" and \"max\" keys are present in the summary and then sets the corresponding expectations for the datetime values in the batch.", "Arguments": ":param name: str. The name of the column for which the expectations are set.\n:param summary: dict. A dictionary containing the summary of the column.\n:param batch: Any. The batch of data for which the expectations are set.\n:param *args: Additional positional arguments.\n:return: Tuple. A tuple containing the name of the column, the summary, and the batch with expectations set."}, "tests": ["tests/unit/test_ge_integration_expectations.py::test_datetime_expectations"], "indent": 4}
{"namespace": "ydata_profiling.model.expectation_algorithms.file_expectations", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/model/expectation_algorithms.py", "signature_position": [106, 109], "body_position": [110, 112], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if a file exists and returns the name, summary, and batch.", "Arguments": ":param name: str. The name of the file.\n:param summary: dict. The summary of the file.\n:param batch: Any. The batch of the file.\n:param *args: Any. Additional arguments.\n:return: Tuple[str, dict, Any]. The name, summary, and batch of the file."}, "tests": ["tests/unit/test_ge_integration_expectations.py::test_file_expectations"], "indent": 4}
{"namespace": "ydata_profiling.model.pandas.describe_categorical_pandas.word_summary_vc", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/model/pandas/describe_categorical_pandas.py", "signature_position": [154, 154], "body_position": [172, 186], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Count the number of occurrences of each individual word across all lines of the data Series, then sort from the word with the most occurrences to the word with the least occurrences. If a list of stop words is given, they will be ignored.", "Arguments": ":param vc: Series containing all unique categories as index and their frequency as value. Sorted from the most frequent down.\n:param stop_words: List of stop words to ignore, empty by default.\n:return: A dict containing the results as a Series with unique words as index and the computed frequency as value"}, "tests": ["tests/unit/test_pandas/test_describe_categorical_pandas.py::test_word_summary_vc", "tests/unit/test_pandas/test_describe_categorical_pandas.py::test_word_summary_vc_with_stop_words"], "indent": 4}
{"namespace": "ydata_profiling.model.pandas.imbalance_pandas.column_imbalance_score", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/model/pandas/imbalance_pandas.py", "signature_position": [8, 10], "body_position": [30, 35], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calculates the class balance score for categorical and boolean variables using entropy to calculate a bounded score between 0 and 1. A perfectly uniform distribution would return a score of 0, and a perfectly imbalanced distribution would return a score of 1.", "Arguments": ":param value_counts: pd.Series. Frequency of each category.\n:param n_classes: int. Number of classes.\n:return: Union[float, int]. Float or integer bounded between 0 and 1 inclusively."}, "tests": ["tests/unit/test_pandas/test_imbalance.py::test_column_imbalance_score_many_classes", "tests/unit/test_pandas/test_imbalance.py::test_column_imbalance_score_one_class", "tests/unit/test_pandas/test_imbalance.py::test_column_imbalance_score_uniform_distribution"], "indent": 4}
{"namespace": "django.core.exceptions.ValidationError.messages", "type": "method", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/core/exceptions.py", "signature_position": [188, 188], "body_position": [189, 191], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the error messages. If the error_dict attribute exists, it returns the sum of the values of the error dictionary. Otherwise, it returns the list of errors.", "Arguments": ":param self: ValidationError. An instance of the ValidationError class.\n:return: List. The list of error messages."}, "tests": ["tests/test_exceptions/test_validation_error.py::TestValidationError::test_messages_concatenates_error_dict_values"], "indent": 8}
{"namespace": "django.utils.module_loading.module_has_submodule", "type": "function", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/utils/module_loading.py", "signature_position": [74, 74], "body_position": [76, 89], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the given module is in the package. It first checks if the package is a valid package and then tries to import the module. If the module is found, it returns True; otherwise, it returns False.", "Arguments": ":param package: The package to check.\n:param module_name: The name of the module to check.\n:return: Boolean. True if the module is found in the package; otherwise, False."}, "tests": ["tests/utils_tests/test_module_loading.py::EggLoader::test_deep_loader", "tests/utils_tests/test_module_loading.py::DefaultLoader::test_has_sumbodule_with_dotted_path", "tests/utils_tests/test_module_loading.py::EggLoader::test_shallow_loader", "tests/utils_tests/test_module_loading.py::DefaultLoader::test_loader"], "indent": 4}
{"namespace": "django.utils.timezone.get_fixed_timezone", "type": "function", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/utils/timezone.py", "signature_position": [59, 59], "body_position": [61, 66], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a tzinfo instance with a fixed offset from UTC. It first checks if the offset is an instance of timedelta and converts it to minutes if it is. Then, it creates a timezone instance with the given offset and name.", "Arguments": ":param offset: The offset from UTC. It can be an integer or a timedelta object.\n:return: timezone. The created timezone instance."}, "tests": ["tests/utils_tests/test_dateparse.py::DateParseTests::test_parse_datetime"], "indent": 4}
{"namespace": "django.utils.encoding.filepath_to_uri", "type": "function", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/utils/encoding.py", "signature_position": [236, 236], "body_position": [244, 248], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts a file system path to a URI portion that can be included in a URL. It encodes certain characters that would normally be recognized as special characters for URIs. It does not encode the ' character, as it is a valid character within URIs.", "Arguments": ":param path: String. The file system path to be converted to a URI.\n:return: String. The URI portion suitable for inclusion in a URL."}, "tests": ["tests/utils_tests/test_encoding.py::TestRFC3987IEncodingUtils::test_filepath_to_uri"], "indent": 4}
{"namespace": "django.utils._os.to_path", "type": "function", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/utils/_os.py", "signature_position": [56, 56], "body_position": [58, 62], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the input value to a pathlib.Path instance if it is not already a Path. If the input value is a string, it creates a Path instance with the string value.", "Arguments": ":param value: Any. The value to be converted to a Path instance.\n:return: Path. The converted Path instance."}, "tests": ["tests/utils_tests/test_os_utils.py::ToPathTests::test_to_path_invalid_value", "tests/utils_tests/test_os_utils.py::ToPathTests::test_to_path"], "indent": 4}
{"namespace": "django.utils.lorem_ipsum.sentence", "type": "function", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/utils/lorem_ipsum.py", "signature_position": [225, 225], "body_position": [234, 240], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function generates a random sentence of lorem ipsum text. The first word is capitalized, and the sentence ends in either a period or question mark. Commas are added at random.", "Arguments": ":param: No input parameters.\n:return: String. A randomly generated sentence of lorem ipsum text."}, "tests": ["tests/utils_tests/test_lorem_ipsum.py::LoremIpsumTests::test_sentence_ending", "tests/utils_tests/test_lorem_ipsum.py::LoremIpsumTests::test_sentence_starts_with_capital", "tests/utils_tests/test_lorem_ipsum.py::LoremIpsumTests::test_sentence"], "indent": 4}
{"namespace": "ydata_profiling.utils.dataframe.sort_column_names", "type": "function", "project_path": "Software-Development/ydata-profiling", "completion_path": "Software-Development/ydata-profiling/src/ydata_profiling/utils/dataframe.py", "signature_position": [227, 227], "body_position": [228, 238], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Sort the column names of the given dictionary in ascending or descending order based on the input parameter. If the sort parameter is None, the original dictionary is returned.", "Arguments": ":param dct: Dict. The input dictionary to be sorted.\n:param sort: Optional string. The sorting order. It can be \"ascending\", \"descending\" or None.\n:return: Dict. The sorted dictionary."}, "tests": ["tests/unit/test_sort.py::test_ascending", "tests/unit/test_sort.py::test_descending", "tests/unit/test_sort.py::test_none"], "indent": 4}
{"namespace": "django.utils.ipv6.is_valid_ipv6_address", "type": "function", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/utils/ipv6.py", "signature_position": [39, 39], "body_position": [43, 47], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the given string is a valid IPv6 address.", "Arguments": ":param ip_str: String. The input string to be checked.\n:return: Bool. True if the input string is a valid IPv6 address, False otherwise."}, "tests": ["tests/utils_tests/test_ipv6.py::TestUtilsIPv6::test_validates_correct_plain_address", "tests/utils_tests/test_ipv6.py::TestUtilsIPv6::test_validates_correct_with_v4mapping", "tests/utils_tests/test_ipv6.py::TestUtilsIPv6::test_validates_incorrect_with_v4mapping"], "indent": 4}
{"namespace": "django.utils.http.urlsafe_base64_decode", "type": "function", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/utils/http.py", "signature_position": [199, 199], "body_position": [204, 208], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Decode a base64 encoded string. Add back any trailing equal signs that might have been stripped.", "Arguments": ":param s: String. The base64 encoded string to be decoded.\n:return: The decoded base64 string."}, "tests": ["tests/utils_tests/test_http.py::URLSafeBase64Tests::test_roundtrip"], "indent": 4}
{"namespace": "django.utils.http.parse_etags", "type": "function", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/utils/http.py", "signature_position": [211, 211], "body_position": [217, 222], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Parse a string of ETags given in an If-None-Match or If-Match header as defined by RFC 9110. Return a list of quoted ETags, or ['*'] if all ETags should be matched.", "Arguments": ":param etag_str: String. A string of ETags given in an If-None-Match or If-Match header.\n:return: List of quoted ETags, or ['*'] if all ETags should be matched."}, "tests": ["tests/utils_tests/test_http.py::ETagProcessingTests::test_parsing"], "indent": 4}
{"namespace": "django.utils.http.is_same_domain", "type": "function", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/utils/http.py", "signature_position": [236, 236], "body_position": [245, 253], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the given host is an exact match or a match to the wildcard pattern. It returns True if the host is either an exact match or a match to the wildcard pattern.", "Arguments": ":param host: String. The host to be checked.\n:param pattern: String. The wildcard pattern to be matched.\n:return: Bool. True if the host is either an exact match or a match to the wildcard pattern, False otherwise."}, "tests": ["tests/utils_tests/test_http.py::IsSameDomainTests::test_bad", "tests/utils_tests/test_http.py::IsSameDomainTests::test_good"], "indent": 4}
{"namespace": "django.utils.http.content_disposition_header", "type": "function", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/utils/http.py", "signature_position": [431, 431], "body_position": [436, 449], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Construct a Content-Disposition HTTP header value from the given filename as specified by RFC 6266. It constructs the header value based on the filename and the attachment flag.", "Arguments": ":param as_attachment: Bool. Whether the content should be treated as an attachment.\n:param filename: String. The name of the file to be included in the header value.\n:return: String. The constructed Content-Disposition HTTP header value."}, "tests": ["tests/utils_tests/test_http.py::ContentDispositionHeaderTests::test_basic"], "indent": 4}
{"namespace": "pysnooper.utils.truncate", "type": "function", "project_path": "Software-Development/PySnooper", "completion_path": "Software-Development/PySnooper/pysnooper/utils.py", "signature_position": [81, 81], "body_position": [82, 87], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Truncate the input string to the maximum length specified. If the length of the string is less than or equal to the maximum length, the original string is returned. Otherwise, the string is truncated and ellipsis is added at the beginning and end of the truncated string.", "Arguments": ":param string: String. The input string to be truncated.\n:param max_length: Integer. The maximum length to which the string should be truncated.\n:return: String. The truncated string. If the original string is less than or equal to the maximum length, the original string is returned. Otherwise, the truncated string is returned with ellipsis at the beginning and end."}, "tests": ["tests/test_pysnooper.py::test_truncate"], "indent": 4}
{"namespace": "pysnooper.variables.needs_parentheses", "type": "function", "project_path": "Software-Development/PySnooper", "completion_path": "Software-Development/PySnooper/pysnooper/variables.py", "signature_position": [13, 13], "body_position": [14, 17], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if parentheses are needed for the given source code. It compares the bytecode of the source code with and without parentheses to determine if they are needed.", "Arguments": ":param source: String. The source code to check for parentheses.\n:return: Bool. True if parentheses are needed, False otherwise."}, "tests": ["tests/test_pysnooper.py::test_needs_parentheses"], "indent": 4}
{"namespace": "django.test.utils.extend_sys_path", "type": "function", "project_path": "Software-Development/Django", "completion_path": "Software-Development/Django/django/test/utils.py", "signature_position": [779, 779], "body_position": [781, 786], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a context manager that temporarily adds paths to sys.path. It first saves the original sys.path, then extends sys.path with the given paths. After the yield, it restores the original sys.path.", "Arguments": ":param *paths: Tuple of strings. The paths to be added to sys.path.\n:return: None. No return values."}, "tests": ["tests/utils_tests/test_module_loading.py::EggLoader::test_deep_loader", "tests/utils_tests/test_module_loading.py::EggLoader::test_shallow_loader"], "indent": 4}
{"namespace": "albumentations.augmentations.functional.normalize_cv2", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/augmentations/functional.py", "signature_position": [67, 67], "body_position": [68, 78], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Normalize the input image using the given mean and denominator. It first checks the shape of the mean and denominator and converts them to the required shape. Then, it performs subtraction and multiplication operations on the input image using the mean and denominator.", "Arguments": ":param img: Numpy array. The input image to be normalized.\n:param mean: Numpy array. The mean values for normalization.\n:param denominator: Numpy array. The denominator values for normalization.\n:return: Numpy array. The normalized image."}, "tests": ["tests/test_functional.py::test_normalize_np_cv_equal"], "indent": 4}
{"namespace": "albumentations.augmentations.functional.normalize_numpy", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/augmentations/functional.py", "signature_position": [81, 81], "body_position": [82, 85], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Normalize the input image using the given mean and denominator. It first converts the image to a float32 type, then subtracts the mean and multiplies by the denominator.", "Arguments": ":param img: Numpy array. The input image to be normalized.\n:param mean: Numpy array. The mean value to be subtracted from the image.\n:param denominator: Numpy array. The value to be multiplied with the image after subtracting the mean.\n:return: Numpy array. The normalized image."}, "tests": ["tests/test_functional.py::test_normalize_np_cv_equal"], "indent": 4}
{"namespace": "albumentations.augmentations.functional.gamma_transform", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/augmentations/functional.py", "signature_position": [820, 820], "body_position": [821, 827], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function applies gamma correction to the input image. It first checks the data type of the input image and then applies the gamma correction accordingly.", "Arguments": ":param img: Numpy array. The input image.\n:param gamma: Float. The gamma value for the transformation.\n:return: Numpy array. The transformed image after applying gamma correction."}, "tests": ["tests/test_functional.py::test_gamma_transform_float", "tests/test_functional.py::test_gamma_transform", "tests/test_functional.py::test_gamma_float_equal_uint8"], "indent": 4}
{"namespace": "albumentations.augmentations.functional.swap_tiles_on_image", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/augmentations/functional.py", "signature_position": [975, 975], "body_position": [990, 997], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function swaps the tiles on the input image based on the given tile parameters.", "Arguments": ":param image: np.ndarray. Input image.\n:param tiles: np.ndarray. Array of tuples representing the tiles to be swapped. Each tuple contains the current and old left-up corner coordinates, height, and width of the tile.\n:return: np.ndarray. The output image after swapping the tiles."}, "tests": ["tests/test_functional.py::test_swap_tiles_on_image_with_non_empty_tiles", "tests/test_functional.py::test_swap_tiles_on_image_with_empty_tiles"], "indent": 4}
{"namespace": "albumentations.augmentations.geometric.functional.keypoint_rotate", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/augmentations/geometric/functional.py", "signature_position": [197, 197], "body_position": [210, 214], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Rotate a keypoint by a given angle. It calculates the new position of the keypoint after rotation and returns the updated keypoint.", "Arguments": ":param keypoint: Tuple. A keypoint `(x, y, angle, scale)`.\n:param angle: Float. The rotation angle.\n:param rows: Int. The height of the image.\n:param cols: Int. The width of the image.\n:return: Tuple. The updated keypoint `(x, y, angle, scale)`."}, "tests": ["tests/test_keypoint.py::test_keypoint_rotate"], "indent": 4}
{"namespace": "albumentations.augmentations.geometric.functional.keypoint_shift_scale_rotate", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/augmentations/geometric/functional.py", "signature_position": [236, 236], "body_position": [237, 253], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Shift, scale, and rotate the given keypoint based on the input parameters. It first extracts the x, y, angle, and scale values from the keypoint. Then, it calculates the center of the image and constructs a rotation matrix based on the input angle and scale. It then applies the transformation to the keypoint and returns the updated x, y, angle, and scale values.", "Arguments": ":param keypoint: List. The input keypoint containing x, y, angle, and scale values.\n:param angle: Float. The angle of rotation in degrees.\n:param scale: Float. The scale factor for scaling the keypoint.\n:param dx: Float. The shift in the x-direction.\n:param dy: Float. The shift in the y-direction.\n:param rows: Integer. The number of rows in the image.\n:param cols: Integer. The number of columns in the image.\n:param **params: Additional keyword arguments.\n:return: Tuple. The updated x, y, angle, and scale values of the keypoint."}, "tests": ["tests/test_keypoint.py::test_keypoint_shift_scale_rotate"], "indent": 4}
{"namespace": "albumentations.core.keypoints_utils.angle_to_2pi_range", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/core/keypoints_utils.py", "signature_position": [23, 23], "body_position": [24, 25], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts the input angle to the range of 0 to 2.", "Arguments": ":param angle: Float. The input angle in radians.\n:return: Float. The angle in the range of 0 to 2."}, "tests": ["tests/test_keypoint.py::test_angle_to_2pi_range"], "indent": 4}
{"namespace": "albumentations.augmentations.geometric.functional.rot90", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/augmentations/geometric/functional.py", "signature_position": [885, 885], "body_position": [886, 887], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Rotate the input image by 90 degrees in the plane specified by axes. The rotation is performed in the counter-clockwise direction for positive factor values.", "Arguments": ":param img: np.ndarray. The input image to be rotated.\n:param factor: int. The number of 90 degree rotations to be applied.\n:return: np.ndarray. The rotated image."}, "tests": ["tests/test_functional.py::test_rot90_float", "tests/test_functional.py::test_rot90"], "indent": 4}
{"namespace": "albumentations.core.keypoints_utils.convert_keypoints_to_albumentations", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/core/keypoints_utils.py", "signature_position": [261, 268], "body_position": [269, 272], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert a list of keypoints to the format used by the Albumentations library. It iterates through each keypoint and converts it to the required format.", "Arguments": ":param keypoints: Sequence of Sequence. A list of keypoints to be converted.\n:param source_format: String. The format of the input keypoints.\n:param rows: Int. The number of rows in the image.\n:param cols: Int. The number of columns in the image.\n:param check_validity: Bool. Whether to check the validity of the keypoints. Defaults to False.\n:param angle_in_degrees: Bool. Whether the angle is in degrees. Defaults to True.\n:return: List of Tuple. The converted keypoints in the format used by the Albumentations library."}, "tests": ["tests/test_keypoint.py::test_convert_keypoints_to_albumentations"], "indent": 4}
{"namespace": "albumentations.core.keypoints_utils.convert_keypoints_from_albumentations", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/core/keypoints_utils.py", "signature_position": [275, 282], "body_position": [283, 286], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the keypoints from the albumentations format to the target format. It iterates through each keypoint and converts it to the target format.", "Arguments": ":param keypoints: Sequence of Sequence. The keypoints to be converted.\n:param target_format: String. The format to which the keypoints are to be converted.\n:param rows: Int. The number of rows in the image.\n:param cols: Int. The number of columns in the image.\n:param check_validity: Bool. Whether to check the validity of the keypoints. Defaults to False.\n:param angle_in_degrees: Bool. Whether the angle is in degrees. Defaults to True.\n:return: List of Tuple. The converted keypoints.\n```"}, "tests": ["tests/test_keypoint.py::test_convert_keypoints_from_albumentations"], "indent": 4}
{"namespace": "albumentations.core.transforms_interface.to_tuple", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/core/transforms_interface.py", "signature_position": [41, 41], "body_position": [50, 71], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the input argument to a min-max tuple. If the input is a scalar, it returns a tuple with the first element as the offset - value and the second element as the offset + value. If the input is a tuple, it returns the value + offset (broadcasted).", "Arguments": ":param param: scalar, tuple or list of 2+ elements. Input value.\nIf value is scalar, return value would be (offset - value, offset + value).\nIf value is tuple, return value would be value + offset (broadcasted).\n:param low: Second element of tuple can be passed as an optional argument.\n:param bias: An offset factor added to each element.\n:return: tuple. The min-max tuple of the input argument."}, "tests": ["tests/test_core.py::test_to_tuple"], "indent": 4}
{"namespace": "albumentations.core.composition.ReplayCompose.replay", "type": "method", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/core/composition.py", "signature_position": [462, 462], "body_position": [463, 464], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function replays the saved augmentations on the input data and returns the augmented data.", "Arguments": ":param saved_augmentations: Dict. A dictionary containing the saved augmentations.\n:param **kwargs: Any. Additional keyword arguments to be passed to the augmentations.\n:return: Dict. The augmented data after replaying the saved augmentations."}, "tests": ["tests/test_bbox.py::test_crop_boxes_replay_compose", "tests/test_core.py::test_deterministic_oneof", "tests/test_core.py::test_deterministic_sequential", "tests/test_core.py::test_deterministic_one_or_other"], "indent": 8}
{"namespace": "albumentations.core.serialization.shorten_class_name", "type": "function", "project_path": "Software-Development/albumentations", "completion_path": "Software-Development/albumentations/albumentations/core/serialization.py", "signature_position": [26, 26], "body_position": [27, 33], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function shortens the class name by removing the top module name if it is \"albumentations\".", "Arguments": ":param class_fullname: String. The full name of the class.\n:return: String. The shortened class name."}, "tests": ["tests/test_serialization.py::test_shorten_class_name"], "indent": 4}
{"namespace": "wandb.util.to_forward_slash_path", "type": "function", "project_path": "Scientific-Engineering/wandb", "completion_path": "Scientific-Engineering/wandb/wandb/util.py", "signature_position": [1399, 1399], "body_position": [1400, 1402], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the backslash path to a forward slash path if the platform is Windows.", "Arguments": ":param path: String. The path to be converted.\n:return: String. The converted path."}, "tests": ["tests/pytest_tests/unit_tests/test_lib/test_paths.py::test_logical_path_is_idempotent"], "indent": 4}
{"namespace": "wandb.util.make_artifact_name_safe", "type": "function", "project_path": "Scientific-Engineering/wandb", "completion_path": "Scientific-Engineering/wandb/wandb/util.py", "signature_position": [1728, 1728], "body_position": [1731, 1735], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function makes an artifact name safe for use in artifacts. It replaces any characters that are not alphanumeric, dashes, underscores, or dots with underscores. If the length of the cleaned name is greater than 128, it truncates the name with dots in the middle using regex.", "Arguments": ":param name: str. The original artifact name.\n:return: str. The cleaned and safe artifact name."}, "tests": ["tests/pytest_tests/unit_tests/test_job_builder.py::test_build_repo_job", "tests/pytest_tests/unit_tests/test_job_builder.py::test_build_image_job", "tests/pytest_tests/unit_tests/test_job_builder.py::test_build_artifact_job"], "indent": 4}
{"namespace": "wandb.sdk.wandb_settings._redact_dict", "type": "function", "project_path": "Scientific-Engineering/wandb", "completion_path": "Scientific-Engineering/wandb/wandb/sdk/wandb_settings.py", "signature_position": [145, 149], "body_position": [151, 155], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Redact a dictionary of unsafe values specified by their key. It replaces the values of the specified keys with a redacted string.", "Arguments": ":param d: Dict[str, Any]. The input dictionary.\n:param unsafe_keys: Union[Set[str], FrozenSet[str]]. Set of unsafe keys to be redacted. Defaults to {\"api_key\"}.\n:param redact_str: str. The redacted string to replace the unsafe values. Defaults to \"***REDACTED***\".\n:return: Dict[str, Any]. The redacted dictionary."}, "tests": ["tests/pytest_tests/unit_tests/test_wandb_settings.py::test_redact"], "indent": 4}
{"namespace": "wandb.sdk.launch.builder.build.get_current_python_version", "type": "function", "project_path": "Scientific-Engineering/wandb", "completion_path": "Scientific-Engineering/wandb/wandb/sdk/launch/builder/build.py", "signature_position": [164, 164], "body_position": [165, 168], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "It retrieves the current Python version and returns the major and full version of the Python.", "Arguments": ":param: No input parameters.\n:return: Tuple. The first element is the full version of the Python, and the second element is the major version of the Python."}, "tests": ["tests/pytest_tests/unit_tests/test_launch/test_create_job.py::test_create_artifact_metadata"], "indent": 4}
{"namespace": "wandb.sdk.artifacts.storage_policy.StoragePolicy.lookup_by_name", "type": "method", "project_path": "Scientific-Engineering/wandb", "completion_path": "Scientific-Engineering/wandb/wandb/sdk/artifacts/storage_policy.py", "signature_position": [15, 15], "body_position": [16, 21], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function looks up a storage policy by its name. It iterates through the subclasses of the class and returns the subclass with the matching name. If no matching subclass is found, it raises a NotImplementedError.", "Arguments": ":param cls: Class. The class instance.\n:param name: String. The name of the storage policy to look up.\n:return: Type[\"StoragePolicy\"]. The subclass of the StoragePolicy with the matching name."}, "tests": ["tests/pytest_tests/unit_tests/test_artifacts/test_storage.py::test_storage_policy_incomplete"], "indent": 8}
{"namespace": "wandb.sdk.lib.runid.generate_id", "type": "function", "project_path": "Scientific-Engineering/wandb", "completion_path": "Scientific-Engineering/wandb/wandb/sdk/lib/runid.py", "signature_position": [7, 7], "body_position": [11, 12], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Generate a random base-36 string of the specified length, the string is made up of lowercase letter and digits.", "Arguments": ":param length: Integer. The length of the generated string. Defaults to 8.\n:return: String. The generated random base-36 string of the specified length."}, "tests": ["tests/pytest_tests/unit_tests/test_lib/test_runid.py::test_generate_id_is_base36", "tests/pytest_tests/unit_tests/test_lib/test_runid.py::test_generate_id_default_8_chars"], "indent": 4}
{"namespace": "wandb.sdk.internal.file_stream.CRDedupeFilePolicy.get_consecutive_offsets", "type": "method", "project_path": "Scientific-Engineering/wandb", "completion_path": "Scientific-Engineering/wandb/wandb/sdk/internal/file_stream.py", "signature_position": [151, 151], "body_position": [166, 177], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function compresses consecutive line numbers into an interval. It takes a dictionary of offsets (line numbers) and returns a list of intervals.", "Arguments": ":param console: Dict[int, str]. A dictionary that maps offsets (line numbers) to lines of text. It represents a mini version of the console dashboard on the UI.\n:return: A list of intervals, each is a tuple of two numbers."}, "tests": ["tests/pytest_tests/unit_tests/test_file_stream.py::test_crdedupe_consecutive_offsets"], "indent": 8}
{"namespace": "wandb.sdk.internal.system.assets.ipu.IPUStats.sample", "type": "method", "project_path": "Scientific-Engineering/wandb", "completion_path": "Scientific-Engineering/wandb/wandb/sdk/internal/system/assets/ipu.py", "signature_position": [81, 81], "body_position": [82, 111], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function samples the IPU stats and logs the metrics for the devices. It first gets the devices and their metrics. Then, it filters the metrics based on the user process id and logs the metrics for the devices that have not been called before or have variable metric keys. An exception will be thrown if any errors occur.", "Arguments": ":param self: IPUStats. An instance of the IPUStats class.\n:return: None. No return value."}, "tests": ["tests/pytest_tests/unit_tests/test_system_metrics/test_ipu.py::test_profiler"], "indent": 8}
{"namespace": "csvkit.cleanup.join_rows", "type": "function", "project_path": "Scientific-Engineering/csvkit", "completion_path": "Scientific-Engineering/csvkit/csvkit/cleanup.py", "signature_position": [6, 6], "body_position": [11, 21], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Given a series of rows, return them as a single row where the inner edge cells are merged. By default joins with a single space character, but you can specify new-line, empty string, or anything else with the 'joiner' kwarg.", "Arguments": ":param rows: List. A series of rows to be joined.\n:param joiner: String. The character to be used for joining the rows. Defaults to a single space character.\n:return: List. The joined row."}, "tests": ["tests/test_cleanup.py::TestCleanup::test_fix_rows", "tests/test_cleanup.py::TestCleanup::test_real_world_join_fail"], "indent": 4}
{"namespace": "csvkit.convert.guess_format", "type": "function", "project_path": "Scientific-Engineering/csvkit", "completion_path": "Scientific-Engineering/csvkit/csvkit/convert/__init__.py", "signature_position": [4, 4], "body_position": [8, 21], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function tries to guess a file's format based on its extension (or lack thereof). It checks the file extension(in ['csv', 'dbf', 'fixed', 'xls', 'xlsx', 'json']) and returns the corresponding format. 'json' will be returned if the extension is 'js'.", "Arguments": ":param filename: String. The name of the file.\n:return: String. The guessed format of the file based on its extension. If the extension is not recognized, it returns None."}, "tests": ["tests/test_convert/test_convert.py::TestConvert::test_guess_csv", "tests/test_convert/test_convert.py::TestConvert::test_guess_xlsx", "tests/test_convert/test_convert.py::TestConvert::test_guess_fixed", "tests/test_convert/test_convert.py::TestConvert::test_guess_xls_uppercase", "tests/test_convert/test_convert.py::TestConvert::test_guess_xls"], "indent": 4}
{"namespace": "folium.utilities.normalize", "type": "function", "project_path": "Scientific-Engineering/folium", "completion_path": "Scientific-Engineering/folium/folium/utilities.py", "signature_position": [443, 443], "body_position": [445, 447], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function removes non-functional spaces and newlines from the input string and returns the modified string.", "Arguments": ":param rendered: String. The input string to be normalized.\n:return: String. The input string without non-functional spaces or newlines."}, "tests": ["tests/plugins/test_scroll_zoom_toggler.py::test_scroll_zoom_toggler", "tests/plugins/test_boat_marker.py::test_boat_marker", "tests/plugins/test_minimap.py::test_minimap", "tests/plugins/test_fullscreen.py::test_fullscreen", "tests/plugins/test_boat_marker.py::test_boat_marker_with_no_wind_speed_or_heading"], "indent": 4}
{"namespace": "tpot.gp_deap.initialize_stats_dict", "type": "function", "project_path": "Scientific-Engineering/TPOT", "completion_path": "Scientific-Engineering/TPOT/tpot/gp_deap.py", "signature_position": [154, 154], "body_position": [171, 174], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function initializes the stats dictionary for an individual. The statistics initialized are: 'generation', 'mutation_count', 'crossover_count', and 'predecessor'.", "Arguments": ":param individual: deap individual. The individual for which the stats dictionary is to be initialized.\n:return: No return values."}, "tests": ["tests/stats_test.py::test_dict_initialization"], "indent": 4}
{"namespace": "bentoml_cli.env_manager.remove_env_arg", "type": "function", "project_path": "Scientific-Engineering/bentoml", "completion_path": "Scientific-Engineering/bentoml/src/bentoml_cli/env_manager.py", "signature_position": [34, 34], "body_position": [38, 50], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function removes `--env <env_name>` or `--env=<env_name>` from the input list of command line arguments.", "Arguments": ":param cmd_args: List of string. The list of command line arguments.\n:return: List of string. The updated list of command line arguments after removing `--env <env_name>` or `--env=<env_name>`."}, "tests": ["tests/unit/bentoml_cli/test_env_manager.py::test_remove_env_arg"], "indent": 4}
{"namespace": "bentoml._internal.utils.uri.path_to_uri", "type": "function", "project_path": "Scientific-Engineering/bentoml", "completion_path": "Scientific-Engineering/bentoml/src/bentoml/_internal/utils/uri.py", "signature_position": [11, 11], "body_position": [21, 26], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert a given path to a URI. It first converts the path to an absolute path and then uses the appropriate method based on the operating system to convert it to a URI.", "Arguments": ":param path: String. The path to be converted to a URI.\n:return: String. The URI string (quoted, absolute)."}, "tests": ["tests/unit/_internal/utils/test_uri.py::test_uri_path_conversion"], "indent": 4}
{"namespace": "bentoml._internal.utils.uri.uri_to_path", "type": "function", "project_path": "Scientific-Engineering/bentoml", "completion_path": "Scientific-Engineering/bentoml/src/bentoml/_internal/utils/uri.py", "signature_position": [29, 29], "body_position": [39, 43], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert a file URI to a path. It first parses the input URI and then checks if the scheme is supported. Then, it constructs the path string and returns it.", "Arguments": ":param uri: String. The URI to convert to a path.\n:return: String. The path string (unquoted)."}, "tests": ["tests/unit/_internal/utils/test_uri.py::test_uri_path_conversion"], "indent": 4}
{"namespace": "bentoml._internal.utils.validate_labels", "type": "function", "project_path": "Scientific-Engineering/bentoml", "completion_path": "Scientific-Engineering/bentoml/src/bentoml/_internal/utils/__init__.py", "signature_position": [303, 303], "body_position": [304, 312], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function validates the labels dictionary. It checks if the input is a dictionary and if the keys and values are strings. ValueError will be raised if any checks fail.", "Arguments": ":param labels: Dictionary. The dictionary to be validated.\n:return: No return values."}, "tests": ["tests/unit/_internal/test_utils.py::test_validate_labels"], "indent": 4}
{"namespace": "bentoml._internal.configuration.helpers.is_valid_ip_address", "type": "function", "project_path": "Scientific-Engineering/bentoml", "completion_path": "Scientific-Engineering/bentoml/src/bentoml/_internal/configuration/helpers.py", "signature_position": [162, 162], "body_position": [164, 168], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the given string is a valid IP address. It uses the ipaddress module to check if the input string is a valid IP address.", "Arguments": ":param addr: String. The input string to be checked.\n:return: Bool. True if the input string is a valid IP address, False otherwise."}, "tests": ["tests/unit/_internal/configuration/test_helpers.py::test_valid_ip_address", "tests/unit/_internal/configuration/test_helpers.py::test_invalid_ip_address"], "indent": 4}
{"namespace": "bentoml._internal.runner.container.PandasDataFrameContainer.batches_to_batch", "type": "method", "project_path": "Scientific-Engineering/bentoml", "completion_path": "Scientific-Engineering/bentoml/src/bentoml/_internal/runner/container.py", "signature_position": [348, 352], "body_position": [353, 362], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function concatenates the given batches of Pandas DataFrame along the specified batch dimension and returns the concatenated DataFrame and the indices of the subbatches.", "Arguments": ":param cls: PandasDataFrameContainer. The class instance.\n:param batches: Sequence of Pandas DataFrame. The batches of Pandas DataFrame to be concatenated.\n:param batch_dim: int. The dimension along which the concatenation is performed. Defaults to 0.\n:return: Tuple of Pandas DataFrame and list of int. The concatenated DataFrame and the indices of the subbatches."}, "tests": ["tests/unit/_internal/runner/test_container.py::test_pandas_container"], "indent": 8}
{"namespace": "bentoml._internal.runner.container.PandasDataFrameContainer.batch_to_batches", "type": "method", "project_path": "Scientific-Engineering/bentoml", "completion_path": "Scientific-Engineering/bentoml/src/bentoml/_internal/runner/container.py", "signature_position": [365, 370], "body_position": [371, 378], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes a Pandas DataFrame and splits it into multiple batches based on the given indices. It returns a list of Pandas DataFrames.", "Arguments": ":param cls: PandasDataFrameContainer. The class instance.\n:param batch: ext.PdDataFrame. The input Pandas DataFrame to be split.\n:param indices: t.Sequence[int]. A sequence of indices to split the DataFrame.\n:param batch_dim: int. The dimension to split the DataFrame. It defaults to 0.\n:return: list[ext.PdDataFrame]. A list of Pandas DataFrames."}, "tests": ["tests/unit/_internal/runner/test_container.py::test_pandas_container"], "indent": 8}
{"namespace": "bentoml._internal.runner.container.DefaultContainer.batches_to_batch", "type": "method", "project_path": "Scientific-Engineering/bentoml", "completion_path": "Scientific-Engineering/bentoml/src/bentoml/_internal/runner/container.py", "signature_position": [497, 499], "body_position": [500, 508], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts a list of batches into a single batch and returns the indices of the subbatches. It concatenates the subbatches into a single batch and calculates the indices of the subbatches.", "Arguments": ":param cls: DefaultContainer. The class instance.\n:param batches: Sequence of lists of any type. The list of batches to be converted.\n:param batch_dim: Integer. The dimension of the batch. It defaults to 0.\n:return: Tuple of list of any type and list of integers. The concatenated batch and the indices of the subbatches."}, "tests": ["tests/unit/_internal/runner/test_container.py::test_default_container"], "indent": 8}
{"namespace": "bentoml._internal.runner.container.DefaultContainer.batch_to_batches", "type": "method", "project_path": "Scientific-Engineering/bentoml", "completion_path": "Scientific-Engineering/bentoml/src/bentoml/_internal/runner/container.py", "signature_position": [511, 513], "body_position": [514, 517], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function splits the input batch into multiple batches based on the given indices. It returns a list of batches.", "Arguments": ":param cls: Class. The class instance.\n:param batch: List. The input batch to be split.\n:param indices: Sequence of integers. The indices to split the batch.\n:param batch_dim: Integer. The dimension to split the batch. Defaults to 0.\n:return: List of lists. The list of batches."}, "tests": ["tests/unit/_internal/runner/test_container.py::test_default_container"], "indent": 8}
{"namespace": "jwt.utils.force_bytes", "type": "function", "project_path": "Utilities/PyJWT", "completion_path": "Utilities/PyJWT/jwt/utils.py", "signature_position": [16, 16], "body_position": [17, 22], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the input value to bytes. If the input value is a string, it is encoded to bytes using UTF-8. If the input value is already bytes, it is returned as is. Otherwise, a TypeError will be raised.", "Arguments": ":param value: Union[bytes, str]. The input value that needs to be converted to bytes.\n:return: bytes. The input value converted to bytes."}, "tests": ["tests/test_utils.py::test_force_bytes_raises_error_on_invalid_object"], "indent": 4}
{"namespace": "pytube.cli.display_progress_bar", "type": "function", "project_path": "Utilities/pytube", "completion_path": "Utilities/pytube/pytube/cli.py", "signature_position": [209, 211], "body_position": [230, 239], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Display a simple, pretty progress bar in the terminal based on the bytes received and the total file size.", "Arguments": ":param int bytes_received: The delta between the total file size (bytes) and bytes already written to disk.\n:param int filesize: File size of the media stream in bytes.\n:param str ch: Character to use for presenting progress segment. Defaults to \"\".\n:param float scale: Scale multiplier to reduce progress bar size. Defaults to 0.55.\n:return: No return values."}, "tests": ["tests/test_cli.py::test_display_progress_bar"], "indent": 4}
{"namespace": "pytube.cli._download", "type": "function", "project_path": "Utilities/pytube", "completion_path": "Utilities/pytube/pytube/cli.py", "signature_position": [251, 255], "body_position": [256, 264], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Download a file from the given stream to the target location. It calculates the file size in megabytes, prints the filename and file size, and then downloads the file to the target location.", "Arguments": ":param stream: Stream. The stream from which the file is to be downloaded.\n:param target: String. The target location where the file is to be downloaded. Defaults to None.\n:param filename: String. The name of the file to be downloaded. Defaults to None.\n:return: No return value."}, "tests": ["tests/test_cli.py::test_download_stream_file_exists"], "indent": 4}
{"namespace": "pytube.cli.display_streams", "type": "function", "project_path": "Utilities/pytube", "completion_path": "Utilities/pytube/pytube/cli.py", "signature_position": [484, 484], "body_position": [491, 492], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function probes a YouTube video and lists its available formats.", "Arguments": ":param youtube: YouTube. A valid YouTube watch URL.\n:return: No return value."}, "tests": ["tests/test_cli.py::test_display_stream"], "indent": 4}
{"namespace": "pytube.cli._unique_name", "type": "function", "project_path": "Utilities/pytube", "completion_path": "Utilities/pytube/pytube/cli.py", "signature_position": [267, 267], "body_position": [280, 286], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function generates a unique filename for a given directory and file format based on the given base name, file format, and target directory. It checks for the existence of the file in the target directory and returns a unique filename.", "Arguments": ":param base: str. The given base-name.\n:param subtype: str. The filetype of the video which will be downloaded.\n:param media_type: str. The media_type of the file, i.e., \"audio\" or \"video\".\n:param target: Path. Target directory for download.\n:return: str. The unique filename for the given directory and file format."}, "tests": ["tests/test_cli.py::test_unique_name_counter", "tests/test_cli.py::test_unique_name"], "indent": 4}
{"namespace": "pytube.cli._print_available_captions", "type": "function", "project_path": "Utilities/pytube", "completion_path": "Utilities/pytube/pytube/cli.py", "signature_position": [495, 495], "body_position": [496, 498], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Print the available caption codes from the given CaptionQuery instance.", "Arguments": ":param captions: CaptionQuery. An instance of the CaptionQuery class.\n:return: No return value."}, "tests": ["tests/test_cli.py::test_print_available_captions"], "indent": 4}
{"namespace": "pytube.cipher.throttling_reverse", "type": "function", "project_path": "Utilities/pytube", "completion_path": "Utilities/pytube/pytube/cipher.py", "signature_position": [482, 482], "body_position": [489, 491], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Reverses the input list in place.", "Arguments": ":param arr: List. The input list to be reversed.\n:return: No return values."}, "tests": ["tests/test_cipher.py::test_throttling_reverse"], "indent": 4}
{"namespace": "pytube.helpers.setup_logger", "type": "function", "project_path": "Utilities/pytube", "completion_path": "Utilities/pytube/pytube/helpers.py", "signature_position": [180, 180], "body_position": [186, 201], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Create a configured instance of a logger. It sets the severity level of the logs to handle and adds a stream handler to the logger. If a log filename is provided, it also adds a file handler to the logger.", "Arguments": ":param level: int. Describe the severity level of the logs to handle. Defaults to logging.ERROR.\n:param log_filename: Optional[str]. The name of the log file. Defaults to None.\n:return: No return value."}, "tests": ["tests/test_helpers.py::test_setup_logger"], "indent": 4}
{"namespace": "pytube.helpers.deprecated", "type": "function", "project_path": "Utilities/pytube", "completion_path": "Utilities/pytube/pytube/helpers.py", "signature_position": [212, 212], "body_position": [219, 235], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a decorator that can be used to mark functions as deprecated. It will result in a warning being emitted when the function is used.", "Arguments": ":param reason: String. The reason for deprecation.\n:return: Callable. A callable object that can be used as a decorator."}, "tests": ["tests/test_helpers.py::test_deprecated"], "indent": 4}
{"namespace": "pytube.helpers.uniqueify", "type": "function", "project_path": "Utilities/pytube", "completion_path": "Utilities/pytube/pytube/helpers.py", "signature_position": [264, 264], "body_position": [273, 280], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function removes duplicate items from a list while maintaining the order of the list.", "Arguments": ":param duped_list: List. The list from which duplicates are to be removed.\n:return: List. The de-duplicated list."}, "tests": ["tests/test_helpers.py::test_uniqueify"], "indent": 4}
{"namespace": "pytube.helpers.target_directory", "type": "function", "project_path": "Utilities/pytube", "completion_path": "Utilities/pytube/pytube/helpers.py", "signature_position": [238, 238], "body_position": [249, 255], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function determines the target directory of a download. It returns an absolute path if a relative one is given or the current path if none is given. It also creates the directory if it does not exist.", "Arguments": ":param output_path: Optional string. The relative or absolute path of the target directory. Defaults to None.\n:return: String. An absolute directory path."}, "tests": ["tests/test_helpers.py::test_target_directory_with_relative_path", "tests/test_helpers.py::test_target_directory_with_no_path", "tests/test_helpers.py::test_target_directory_with_absolute_path"], "indent": 4}
{"namespace": "pytube.extract.is_private", "type": "function", "project_path": "Utilities/pytube", "completion_path": "Utilities/pytube/pytube/extract.py", "signature_position": [56, 56], "body_position": [65, 73], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if the content is private by searching for specific strings in the HTML content of the watch page.", "Arguments": ":param watch_html: str. The html contents of the watch page.\n:return: bool. Whether or not the content is private."}, "tests": ["tests/test_extract.py::test_is_private"], "indent": 4}
{"namespace": "pymc.math.cartesian", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/math.py", "signature_position": [187, 187], "body_position": [195, 202], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function makes the Cartesian product of arrays. It takes N-D arrays as input and returns the Cartesian product of the arrays.", "Arguments": ":param arrays: N-D array-like. N-D arrays where earlier arrays loop more slowly than later ones.\n:return: N-D array-like. The Cartesian product of the input arrays."}, "tests": ["tests/gp/test_cov.py::TestCovKron::test_symprod_cov", "tests/test_math.py::test_cartesian", "tests/gp/test_cov.py::TestCovKron::test_multiops", "tests/test_math.py::test_cartesian_2d"], "indent": 4}
{"namespace": "pymc.math.log1mexp", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/math.py", "signature_position": [293, 293], "body_position": [307, 316], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the log of 1 minus the exponential of the negative input. It is designed to be numerically more stable than the naive approach.", "Arguments": ":param x: Numeric. The input value.\n:param negative_input: Bool. Whether the input is negative. Defaults to False.\n:return: Numeric. The log of 1 minus the exponential of the negative input."}, "tests": ["tests/test_math.py::test_log1mexp_deprecation_warnings"], "indent": 4}
{"namespace": "pymc.math.log1mexp_numpy", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/math.py", "signature_position": [319, 319], "body_position": [325, 341], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the natural logarithm of 1 minus the exponential of the input value. It is designed to be numerically more stable than the naive approach.", "Arguments": ":param x: The input value for which the natural logarithm of 1 minus the exponential is to be calculated.\n:param negative_input: Bool. Whether the input value is negative. Defaults to False.\n:return: Numpy array. The natural logarithm of 1 minus the exponential of the input value."}, "tests": ["tests/test_math.py::test_log1mexp_numpy_integer_input", "tests/test_math.py::test_log1mexp_deprecation_warnings", "tests/test_math.py::test_log1mexp"], "indent": 4}
{"namespace": "pymc.util.drop_warning_stat", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/util.py", "signature_position": [263, 263], "body_position": [269, 274], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function removes the \"warning\" stat from the sample stats groups in the given InferenceData object and returns a new InferenceData object.", "Arguments": ":param idata: arviz.InferenceData. The input InferenceData object.\n:return: arviz.InferenceData. The new InferenceData object with the \"warning\" stat removed from sample stats groups."}, "tests": ["tests/test_util.py::test_drop_warning_stat"], "indent": 4}
{"namespace": "pymc.pytensorf.walk_model", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/pytensorf.py", "signature_position": [179, 183], "body_position": [195, 206], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function walks through the model graphs and yields their nodes. It uses a generator to yield the nodes of the model graphs.", "Arguments": ":param graphs: Iterable of TensorVariable. The graphs to walk.\n:param stop_at_vars: Optional set of TensorVariable. A set of variables at which the walk will terminate. Defaults to None.\n:param expand_fn: Callable function. A function that returns the next variable(s) to be traversed. Defaults to a lambda function that returns an empty list.\n:return: Generator of TensorVariable. A generator that yields the nodes of the model graphs."}, "tests": ["tests/test_pytensorf.py::TestReplaceRVsByValues::test_basic", "tests/test_pytensorf.py::test_walk_model"], "indent": 4}
{"namespace": "pymc.testing.select_by_precision", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/testing.py", "signature_position": [225, 225], "body_position": [227, 228], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a helper function to choose reasonable decimal cutoffs for different floatX modes. It selects the decimal cutoff based on the floatX mode.", "Arguments": ":param float64: The decimal cutoff for float64 mode.\n:param float32: The decimal cutoff for float32 mode.\n:return: The decimal cutoff based on the floatX mode."}, "tests": ["tests/distributions/test_multivariate.py::TestMatchesScipy::test_dirichlet_multinomial_matches_beta_binomial", "tests/distributions/test_multivariate.py::TestMatchesScipy::test_mvnormal", "tests/distributions/test_multivariate.py::TestMatchesScipy::test_stickbreakingweights_logp", "tests/distributions/test_multivariate.py::TestMatchesScipy::test_lkjcorr", "tests/distributions/test_multivariate.py::TestMatchesScipy::test_matrixnormal"], "indent": 4}
{"namespace": "pymc.gp.cov.handle_args", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/gp/cov.py", "signature_position": [1149, 1149], "body_position": [1150, 1158], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a decorator that takes a function as input and returns a new function. The new function takes two arguments, the first one is the input for the original function, and the second one is a tuple of arguments. If the second argument is None, the original function is called with only the first argument. Otherwise, the original function is called with the first argument and the unpacked tuple of arguments.", "Arguments": ":param func: Callable. The original function to be decorated.\n:return: Callable. The decorated function."}, "tests": ["tests/gp/test_cov.py::TestHandleArgs::test_handleargs"], "indent": 4}
{"namespace": "pymc.gp.util.kmeans_inducing_points", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/gp/util.py", "signature_position": [98, 98], "body_position": [113, 133], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function uses the K-means algorithm to initialize the locations of the inducing points `fu` based on the input parameters.", "Arguments": ":param n_inducing: int. The number of inducing points (or k, the number of clusters).\n:param X: array-like. Gaussian process input matrix.\n:param **kmeans_kwargs: Extra keyword arguments that are passed to `scipy.cluster.vq.kmeans`.\n:return: array-like. The initialized locations of the inducing points `fu` multiplied by the scaling factor."}, "tests": ["tests/gp/test_util.py::TestKmeansInducing::test_kmeans", "tests/gp/test_util.py::TestKmeansInducing::test_kmeans_raises"], "indent": 4}
{"namespace": "pymc.pytensorf.floatX", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/pytensorf.py", "signature_position": [436, 436], "body_position": [440, 444], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts a PyTensor tensor or numpy array to pytensor.config.floatX type.", "Arguments": ":param X: PyTensor tensor or numpy array. The input tensor or array to be converted.\n:return: PyTensor tensor or numpy array. The converted tensor or array."}, "tests": ["tests/distributions/test_mixture.py::TestMixture::test_list_mvnormals_logp", "tests/distributions/test_mixture.py::TestMixture::test_single_poisson_sampling", "tests/test_data.py::TestData::test_symbolic_coords", "tests/test_math.py::test_expand_packed_triangular", "tests/distributions/test_mixture.py::TestMixture::test_list_poissons_sampling"], "indent": 4}
{"namespace": "pymc.distributions.multivariate.posdef", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/distributions/multivariate.py", "signature_position": [829, 830], "body_position": [831, 835], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the input matrix is positive definite by attempting to perform a Cholesky decomposition. If the decomposition is successful, the matrix is positive definite.", "Arguments": ":param AA: The input matrix to be checked for positive definiteness.\n:return: Bool. True if the matrix is positive definite, False otherwise."}, "tests": ["tests/distributions/test_multivariate.py::test_posdef_symmetric"], "indent": 4}
{"namespace": "pymc.distributions.dist_math.multigammaln", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/distributions/dist_math.py", "signature_position": [398, 398], "body_position": [407, 408], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Calculate the multivariate log gamma of the given parameters.", "Arguments": ":param a: tensor like. The input tensor.\n:param p: int. The degrees of freedom. It should be greater than 0.\n:return: The multivariate log gamma value."}, "tests": ["tests/distributions/test_dist_math.py::test_multigamma"], "indent": 4}
{"namespace": "pymc.distributions.dist_math.incomplete_beta", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/distributions/dist_math.py", "signature_position": [436, 436], "body_position": [437, 442], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is used to calculate the incomplete beta function. It calls the betainc function from the pt module to calculate the incomplete beta function.", "Arguments": ":param a: float. The first shape parameter of the beta distribution.\n:param b: float. The second shape parameter of the beta distribution.\n:param value: float. The upper limit of integration of the incomplete beta function.\n:return: float. The value of the incomplete beta function."}, "tests": ["tests/distributions/test_dist_math.py::test_incomplete_beta_deprecation"], "indent": 4}
{"namespace": "pymc.sampling.forward.observed_dependent_deterministics", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/sampling/forward.py", "signature_position": [335, 335], "body_position": [337, 344], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function finds the deterministics that depend directly on observed variables in the given model. It first retrieves the deterministics, observed random variables, and basic random variables from the model. Then, it returns a list of deterministics that depend directly on observed variables.", "Arguments": ":param model: Model. The input model.\n:return: List. A list of deterministics that depend directly on observed variables."}, "tests": ["tests/sampling/test_forward.py::test_observed_dependent_deterministics"], "indent": 4}
{"namespace": "pymc.smc.kernels.systematic_resampling", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/smc/kernels.py", "signature_position": [571, 571], "body_position": [585, 598], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function performs systematic resampling. It generates a vector of indices based on the given weights and random number generator.", "Arguments": ":param weights: The weights should be probabilities and the total sum should be 1.\n:param rng: Random number generator.\n:return: new_indices: array. A vector of indices in the interval 0, ..., len(normalized_weights)."}, "tests": ["tests/smc/test_smc.py::test_systematic"], "indent": 4}
{"namespace": "pymc.backends.base._squeeze_cat", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/backends/base.py", "signature_position": [571, 571], "body_position": [574, 581], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Squeeze and concatenate the results based on the values of `combine` and `squeeze`. It concatenates the results if `combine` is True and squeezes the results if `squeeze` is True.", "Arguments": ":param results: List. The list of results to be concatenated or squeezed.\n:param combine: Bool. Whether to combine the results.\n:param squeeze: Bool. Whether to squeeze the results.\n:return: List or concatenated array. The squeezed or concatenated results."}, "tests": ["tests/backends/test_ndarray.py::TestSqueezeCat::test_combine_false_squeeze_false", "tests/backends/test_ndarray.py::TestSqueezeCat::test_combine_true_squeeze_true", "tests/backends/test_ndarray.py::TestSqueezeCat::test_combine_false_squeeze_true_more_than_one_item", "tests/backends/test_ndarray.py::TestSqueezeCat::test_combine_false_squeeze_true_one_item", "tests/backends/test_ndarray.py::TestSqueezeCat::test_combine_true_squeeze_false"], "indent": 4}
{"namespace": "pymc.logprob.transforms.SimplexTransform.forward", "type": "method", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/logprob/transforms.py", "signature_position": [1113, 1113], "body_position": [1114, 1118], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function performs a forward transformation on the input value using the Simplex transformation method. It calculates the log of the input value, computes the sum of the log values, and then returns the transformed value.", "Arguments": ":param value: Tensor. The input value to be transformed.\n:param inputs: Variable number of input tensors.\n:return: Tensor. The transformed value after applying the Simplex transformation."}, "tests": ["tests/distributions/test_transform.py::test_simplex_accuracy"], "indent": 8}
{"namespace": "pymc.logprob.transforms.SimplexTransform.backward", "type": "method", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/logprob/transforms.py", "signature_position": [1120, 1120], "body_position": [1121, 1123], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function performs the backward transformation of the Simplex transform. It takes the value and a variable number of inputs and returns the transformed value.", "Arguments": ":param value: The value to be transformed.\n:param *inputs: Variable number of inputs.\n:return: The transformed value."}, "tests": ["tests/distributions/test_transform.py::test_simplex_accuracy"], "indent": 8}
{"namespace": "pymc.logprob.utils.walk_model", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/logprob/utils.py", "signature_position": [70, 75], "body_position": [91, 106], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function walks through the model graphs and yields their nodes. It can be used to traverse the graph structure of a model and perform operations on the nodes.", "Arguments": ":param graphs: Iterable of TensorVariable. The graphs to walk.\n:param walk_past_rvs: Bool. If True, the walk will not terminate at MeasurableVariable nodes.\n:param stop_at_vars: Optional set of TensorVariable. A list of variables at which the walk will terminate.\n:param expand_fn: Callable function. A function that returns the next variable(s) to be traversed.\n:return: Generator of TensorVariable. A generator that yields the nodes of the model graphs.\n```"}, "tests": ["tests/logprob/test_utils.py::test_rvs_to_value_vars_intermediate_rv", "tests/logprob/test_utils.py::test_rvs_to_value_vars", "tests/logprob/test_basic.py::test_factorized_joint_logprob_basic", "tests/logprob/test_utils.py::test_walk_model", "tests/logprob/test_basic.py::test_joint_logp_basic"], "indent": 4}
{"namespace": "sacred.metrics_logger.linearize_metrics", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/metrics_logger.py", "signature_position": [80, 80], "body_position": [93, 105], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Group metrics by name. It takes a list of individual measurements, possibly belonging to different metrics and groups them by name.", "Arguments": ":param logged_metrics: A list of ScalarMetricLogEntries\n:return: Measured values grouped by the metric name:\n{\"metric_name1\": {\"steps\": [0,1,2], \"values\": [4, 5, 6],\n\"timestamps\": [datetime, datetime, datetime]},\n\"metric_name2\": {...}}"}, "tests": ["tests/test_observers/test_file_storage_observer.py::test_log_metrics", "tests/test_metrics_logger.py::test_linearize_metrics"], "indent": 4}
{"namespace": "sacred.utils.set_by_dotted_path", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/utils.py", "signature_position": [457, 457], "body_position": [474, 480], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function sets an entry in a nested dictionary using a dotted path. It creates dictionaries as needed.\nExamples\n--------\n>>> d = {'foo': {'bar': 7}}\n>>> set_by_dotted_path(d, 'foo.bar', 10)\n>>> d\n{'foo': {'bar': 10}}\n>>> set_by_dotted_path(d, 'foo.d.baz', 3)\n>>> d\n{'foo': {'bar': 10, 'd': {'baz': 3}}}", "Arguments": ":param d: Dictionary. The nested dictionary to be modified.\n:param path: String. The dotted path to the entry to be set.\n:param value: Any. The value to be set at the specified path.\n:return: No return value."}, "tests": ["tests/test_utils.py::test_set_by_dotted_path_creates_missing_dicts", "tests/test_utils.py::test_set_by_dotted_path"], "indent": 4}
{"namespace": "sacred.utils.get_by_dotted_path", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/utils.py", "signature_position": [483, 483], "body_position": [492, 500], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function retrieves an entry from nested dictionaries using a dotted path. It splits the path and iterates through the nested dictionaries to find the entry.\nExample:\n>>> get_by_dotted_path({'foo': {'a': 12}}, 'foo.a')\n12", "Arguments": ":param d: Dictionary. The nested dictionary from which to retrieve the entry.\n:param path: String. The dotted path to the entry in the nested dictionary.\n:param default: Any. The default value to return if the entry is not found. Defaults to None.\n:return: Any. The retrieved entry from the nested dictionary. If not found, returns the default value."}, "tests": ["tests/test_utils.py::test_get_by_dotted_path"], "indent": 4}
{"namespace": "pymc.logprob.scan.construct_scan", "type": "function", "project_path": "Scientific-Engineering/pymc", "completion_path": "Scientific-Engineering/pymc/pymc/logprob/scan.py", "signature_position": [295, 295], "body_position": [296, 299], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "It constructs a scan operation based on the given scan arguments and additional keyword arguments. It creates a scan operation and a node based on the input and output variables and returns the node outputs and updates.", "Arguments": ":param scan_args: ScanArgs. An instance of the ScanArgs class containing inner and outer inputs, outputs, and other information.\n:param kwargs: Additional keyword arguments.\n:return: Tuple. A tuple containing a list of TensorVariable and OrderedUpdates."}, "tests": ["tests/logprob/test_scan.py::test_convert_outer_out_to_in_sit_sot", "tests/logprob/test_scan.py::test_convert_outer_out_to_in_mit_sot"], "indent": 4}
{"namespace": "sacred.utils.is_prefix", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/utils.py", "signature_position": [522, 522], "body_position": [524, 526], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if pre_path is a path-prefix of path. It returns True if pre_path is a path-prefix of path, otherwise False.", "Arguments": ":param pre_path: String. The path-prefix to be checked.\n:param path: String. The path to be checked.\n:return: Bool. True if pre_path is a path-prefix of path, otherwise False."}, "tests": ["tests/test_utils.py::test_is_prefix"], "indent": 4}
{"namespace": "sacred.utils.get_inheritors", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/utils.py", "signature_position": [613, 613], "body_position": [615, 623], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a set of all classes that inherit from the given class. It iterates through all the subclasses of the given class and adds them to the set of subclasses.", "Arguments": ":param cls: Class. The class for which the inheritors are to be found.\n:return: Set. A set of all classes that inherit from the given class."}, "tests": ["tests/test_utils.py::test_get_inheritors"], "indent": 4}
{"namespace": "sacred.utils.convert_camel_case_to_snake_case", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/utils.py", "signature_position": [628, 628], "body_position": [630, 631], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert a string from CamelCase to snake_case.", "Arguments": ":param name: String. The input string in CamelCase.\n:return: String. The converted string in snake_case."}, "tests": ["tests/test_utils.py::test_convert_camel_case_to_snake_case"], "indent": 4}
{"namespace": "sacred.utils.module_exists", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/utils.py", "signature_position": [674, 674], "body_position": [676, 681], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if a module exists without actually importing it. It uses the pkgutil.find_loader method to check if the module exists.", "Arguments": ":param modname: String. The name of the module to check.\n:return: Bool. True if the module exists, False otherwise."}, "tests": ["tests/test_utils.py::test_module_exists_base_level_modules", "tests/test_utils.py::test_module_exists_does_not_import_module"], "indent": 4}
{"namespace": "sacred.utils.apply_backspaces_and_linefeeds", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/utils.py", "signature_position": [634, 634], "body_position": [644, 671], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Interpret backspaces and linefeeds in text like a terminal would. It removes backspace and linefeed characters and applies them line by line.", "Arguments": ":param text: String. The input text to be interpreted.\n:return: String. The interpreted text after removing backspace and linefeed characters."}, "tests": ["tests/test_experiment.py::test_captured_out_filter", "tests/test_utils.py::test_apply_backspaces_and_linefeeds", "tests/test_run.py::test_captured_out_filter"], "indent": 4}
{"namespace": "sacred.commands.help_for_command", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/commands.py", "signature_position": [118, 118], "body_position": [120, 122], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function retrieves the help text, including the signature and docstring, for a given command (function). It then removes any backspaces from the help text before returning it.", "Arguments": ":param command: The command (function) for which to retrieve the help text.\n:return: String. The help text for the given command."}, "tests": ["tests/test_commands.py::test_help_for_command"], "indent": 4}
{"namespace": "sacred.optional.optional_import", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/optional.py", "signature_position": [9, 9], "body_position": [10, 14], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function tries to import the given package names and returns the first successfully imported package. If none of the packages can be imported, it returns False and None.", "Arguments": ":param package_names: Tuple of strings. The names of the packages to be imported.\n:return: Tuple. The first element is a boolean indicating whether the import is successful. The second element is the first successfully imported package.\n```"}, "tests": ["tests/test_optional.py::test_optional_import", "tests/test_optional.py::test_optional_import_nonexisting"], "indent": 4}
{"namespace": "sacred.dependencies.get_py_file_if_possible", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/dependencies.py", "signature_position": [378, 378], "body_position": [380, 386], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Try to retrieve a .py file for a given .py[c] file. It first checks if the file ends with \".py\", \".so\", \".pyd\", or \".ipynb\". If so, it returns the file name. Otherwise, it checks if the .py file exists. If so, it returns the .py file name. Otherwise, it returns the original .pyc file name.", "Arguments": ":param pyc_name: String. The name of the .py[c] file.\n:return: String. The name of the .py file if found, otherwise the name of the .pyc file."}, "tests": ["tests/test_dependencies.py::test_get_py_file_if_possible_with_pyc_file", "tests/test_dependencies.py::test_get_py_file_if_possible_with_pyc_but_nonexistent_py_file", "tests/test_dependencies.py::test_get_py_file_if_possible_with_py_file"], "indent": 4}
{"namespace": "sacred.config.custom_containers.DogmaticDict.update", "type": "method", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/config/custom_containers.py", "signature_position": [97, 97], "body_position": [98, 106], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Update the DogmaticDict instance with the given iterable or keyword arguments. If the iterable is not None, it iterates through the keys and values of the iterable and updates the instance. If the iterable does not have keys, it iterates through the items of the iterable and updates the instance. Then, it updates the instance with the keyword arguments.", "Arguments": ":param self: DogmaticDict. An instance of the DogmaticDict class.\n:param iterable: Iterable. An iterable object to update the instance. Defaults to None.\n:param kwargs: Keyword arguments. Key-value pairs to update the instance.\n:return: No return values."}, "tests": ["tests/test_config/test_dogmatic_dict.py::test_dict_interface_update_with_list_of_items", "tests/test_config/test_dogmatic_dict.py::test_dict_interface_update_with_kwargs", "tests/test_config/test_dogmatic_dict.py::test_dict_interface_update_with_dict"], "indent": 8}
{"namespace": "sacred.config.config_scope.is_empty_or_comment", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/config/config_scope.py", "signature_position": [148, 148], "body_position": [149, 150], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the input line is empty or a comment. It removes leading and trailing whitespaces and checks if the line is empty or starts with a comment symbol.", "Arguments": ":param line: String. The input line to be checked.\n:return: Bool. True if the line is empty or a comment, False otherwise."}, "tests": ["tests/test_config/test_config_scope.py::test_is_empty_or_comment"], "indent": 4}
{"namespace": "boltons.funcutils.copy_function", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/funcutils.py", "signature_position": [194, 194], "body_position": [213, 220], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a shallow copy of the given function, including the code object, globals, closure, etc.", "Arguments": ":param orig: function. The function to be copied. Must be a function, not just any method or callable.\n:param copy_dict: bool. Also copy any attributes set on the function instance. Defaults to ``True``.\n:return: function. The copied function."}, "tests": ["tests/test_funcutils.py::test_copy_function"], "indent": 4}
{"namespace": "sacred.config.config_scope.dedent_line", "type": "function", "project_path": "Utilities/sacred", "completion_path": "Utilities/sacred/sacred/config/config_scope.py", "signature_position": [157, 157], "body_position": [158, 164], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function removes the common leading whitespace from the input line based on the given indent.", "Arguments": ":param line: String. The input line to be processed.\n:param indent: String. The indent to be removed from the input line.\n:return: String. The processed line with the common leading whitespace removed."}, "tests": ["tests/test_config/test_config_scope.py::test_dedent_line"], "indent": 4}
{"namespace": "boltons.funcutils.format_invocation", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/funcutils.py", "signature_position": [338, 338], "body_position": [350, 366], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function formats a basic Python-style function call based on the given name, positional arguments, and keyword arguments. It returns the formatted function call.\nExample:\n>>> print(format_invocation('func', args=(1, 2), kwargs={'c': 3}))\nfunc(1, 2, c=3)\n>>> print(format_invocation('a_func', args=(1,)))\na_func(1)\n>>> print(format_invocation('kw_func', kwargs=[('a', 1), ('b', 2)]))\nkw_func(a=1, b=2)", "Arguments": ":param name: String. The name of the function.\n:param args: Tuple. The positional arguments of the function.\n:param kwargs: Dictionary. The keyword arguments of the function.\n:param kw: Dictionary. Additional keyword arguments.\n:return: String. The formatted function call."}, "tests": ["tests/test_funcutils.py::test_format_invocation"], "indent": 4}
{"namespace": "boltons.listutils.SplayList.shift", "type": "method", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/listutils.py", "signature_position": [352, 352], "body_position": [353, 356], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Shift the item at the given index to the destination index in the SplayList instance. It first removes the item at the given index and then inserts it at the destination index.", "Arguments": ":param self: SplayList. An instance of the SplayList class.\n:param item_index: Integer. The index of the item to be shifted.\n:param dest_index: Integer. The index where the item is to be shifted. Defaults to 0.\n:return: No return values."}, "tests": ["tests/test_listutils.py::test_splay_list"], "indent": 8}
{"namespace": "boltons.strutils.gzip_bytes", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/strutils.py", "signature_position": [670, 670], "body_position": [685, 689], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Compress the input bytes using gzip compression with the specified compression level.", "Arguments": ":param bytestring: Bytes. The input bytes to be compressed.\n:param level: Integer. An integer between 1-9 controlling the speed/compression. 1 is fastest, least compressed, 9 is slowest, but most compressed. Defaults to 6.\n:return: Bytes. The compressed bytes."}, "tests": ["tests/test_strutils.py::test_roundzip"], "indent": 4}
{"namespace": "boltons.strutils.is_uuid", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/strutils.py", "signature_position": [745, 745], "body_position": [759, 766], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the input argument is a valid UUID object or string. It also checks if the UUID version matches the specified version.", "Arguments": ":param obj: object. The test target. Strings and UUID objects are supported.\n:param version: int. The target UUID version. Set to 0 to skip version check.\n:return: bool. True if the input is a valid UUID object or string, and the version matches the specified version. False otherwise."}, "tests": ["tests/test_strutils.py::test_is_uuid"], "indent": 4}
{"namespace": "boltons.strutils.parse_int_list", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/strutils.py", "signature_position": [911, 911], "body_position": [928, 945], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes a range string as input and returns a sorted list of positive integers based on the range string. It parses the input range string and returns a list of integers.\nExample:\n>>> parse_int_list('1,3,5-8,10-11,15')\n[1, 3, 5, 6, 7, 8, 10, 11, 15]", "Arguments": ":param range_string: String. The input range string containing comma-separated positive integers or ranges.\n:param delim: Char. The delimiter that separates integers and contiguous ranges of integers. Defaults to ','.\n:param range_delim: Char. The delimiter that indicates a contiguous range of integers. Defaults to '-'.\n:return: List of integers. A sorted list of positive integers based on the input range string."}, "tests": ["tests/test_strutils.py::test_parse_int_list"], "indent": 4}
{"namespace": "boltons.cacheutils.ThresholdCounter.get", "type": "method", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/cacheutils.py", "signature_position": [798, 798], "body_position": [800, 803], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Get the count for the given key in the ThresholdCounter instance. If the key is not found, it returns the default value.", "Arguments": ":param self: ThresholdCounter. An instance of the ThresholdCounter class.\n:param key: The key to get the count for.\n:param default: Integer. The value to return if the key is not found in the instance. Defaults to 0.\n:return: Integer. The count for the key, or the default value if the key is not found."}, "tests": ["tests/test_cacheutils.py::test_threshold_counter"], "indent": 8}
{"namespace": "boltons.iterutils.backoff_iter", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/iterutils.py", "signature_position": [561, 561], "body_position": [616, 652], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function generates a sequence of geometrically-increasing floats, suitable for usage with exponential backoff. It starts with the start value, increasing by a factor until the stop value is reached, optionally stopping iteration once a count of numbers are yielded.", "Arguments": ":param start (float): Positive number for baseline.\n:param stop (float): Positive number for maximum.\n:param count (int): Number of steps before stopping iteration. Defaults to the number of steps between start and stop. Pass the string, 'repeat', to continue iteration indefinitely.\n:param factor (float): Rate of exponential increase. Defaults to 2.0.\n:param jitter (float): A factor between -1.0 and 1.0, used to uniformly randomize and spread out timeouts in a distributed system, avoiding rhythm effects. Positive values use the base backoff curve as a maximum, negative values use the curve as a minimum. Set to 1.0 or True for a jitter approximating Ethernet's time-tested backoff solution. Defaults to False.\n:return: A sequence of geometrically-increasing floats."}, "tests": ["tests/test_iterutils.py::test_backoff_repeat"], "indent": 4}
{"namespace": "boltons.cacheutils.cached", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/cacheutils.py", "signature_position": [543, 543], "body_position": [576, 578], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a decorator that caches the result of a function. It takes a cache object and returns a decorator that can be used to cache the result of a function.", "Arguments": ":param cache: Mapping. Any dict-like object suitable for use as a cache. Instances of the LRU and LRI are good choices, but a plain dict can work in some cases, as well. This argument can also be a callable which accepts no arguments and returns a mapping.\n:param scoped: Bool. Whether the function itself is part of the cache key. True by default, different functions will not read one another's cache entries, but can evict one another's results. False can be useful for certain shared cache use cases. More advanced behavior can be produced through the key argument.\n:param typed: Bool. Whether to factor argument types into the cache check. Default False, setting to True causes the cache keys for 3 and 3.0 to be considered unequal.\n:param key: The key to be used for caching. Defaults to None.\n:return: The decorator function that can be used to cache the result of a function."}, "tests": ["tests/test_cacheutils.py::test_callable_cached_dec", "tests/test_cacheutils.py::test_cached_dec", "tests/test_cacheutils.py::test_unscoped_cached_dec"], "indent": 4}
{"namespace": "boltons.timeutils.total_seconds", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/timeutils.py", "signature_position": [62, 62], "body_position": [75, 78], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function calculates the total number of seconds in a given timedelta object.", "Arguments": ":param td: datetime.timedelta. The timedelta to convert to seconds.\n:return: float. The total number of seconds in the given timedelta object."}, "tests": ["tests/test_timeutils.py::test_float_total_seconds"], "indent": 4}
{"namespace": "boltons.gcutils.get_all", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/gcutils.py", "signature_position": [71, 71], "body_position": [104, 119], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a list containing all instances of a given type. It works for the vast majority of types, but there are some exceptions. It is optimized for getting instances of user-created types quite fast. Setting *include_subtypes* to ``False`` will further increase performance in cases where instances of subtypes aren't required.", "Arguments": ":param type_obj: Type. The type of object to get all instances of.\n:param include_subtypes: Bool. Whether to include instances of subtypes. Defaults to True.\n:return: List. A list containing all instances of the given type."}, "tests": ["tests/test_gcutils.py::test_get_all"], "indent": 4}
{"namespace": "boltons.timeutils.daterange", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/timeutils.py", "signature_position": [312, 312], "body_position": [363, 398], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a generator that yields a sequence of datetime.date objects, starting at the start date, incrementing by step, until the stop date is reached. It can also yield an infinite sequence of dates if the stop date is set to None.", "Arguments": ":param start (datetime.date): The starting date The first value in the sequence.\n:param stop (datetime.date): The stopping date. By default not included in return. Can be `None` to yield an infinite sequence.\n:param step (int): The value to increment *start* by to reach *stop*. Can be an :class:`int` number of days, a :class:`datetime.timedelta`, or a :class:`tuple` of integers, `(year, month, day)`. Positive and negative *step* values are supported.\n:param inclusive (bool): Whether or not the *stop* date can be returned. *stop* is only returned when a *step* falls evenly on it.\n:return: A generator that yields a sequence of datetime.date objects."}, "tests": ["tests/test_timeutils.py::test_daterange_years_step", "tests/test_timeutils.py::test_daterange_infinite", "tests/test_timeutils.py::test_daterange_years", "tests/test_timeutils.py::test_daterange_with_same_start_stop"], "indent": 4}
{"namespace": "boltons.mathutils.clamp", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/mathutils.py", "signature_position": [43, 43], "body_position": [69, 72], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Limit a value to a given range. The function takes a number and limits it to a given range. The returned value is guaranteed to be between the lower and upper bounds.", "Arguments": ":param x: int or float. Number to be clamped.\n:param lower: int or float. Minimum value for x. Defaults to negative infinity.\n:param upper: int or float. Maximum value for x. Defaults to positive infinity.\n:return: int or float. The clamped value.\nThe returned value is guaranteed to be between *lower* and *upper*. Integers, floats, and other comparable types can be mixed.\nThe function also provides examples of how to use it."}, "tests": ["tests/test_mathutils.py::test_clamp_examples", "tests/test_mathutils.py::test_clamp_transparent"], "indent": 4}
{"namespace": "boltons.mathutils.ceil", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/mathutils.py", "signature_position": [75, 75], "body_position": [91, 97], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Return the ceiling of the input number. If the options are set, return the smallest integer or float from the options that is greater than or equal to the input number.", "Arguments": ":param x: int or float. Number to be tested.\n:param options: iterable. Optional iterable of arbitrary numbers (ints or floats).\n:return: int or float. The ceiling of x. If options is not None, return the smallest integer or float from the options that is greater than or equal to x."}, "tests": ["tests/test_mathutils.py::test_ceil_basic", "tests/test_mathutils.py::test_ceil_oor_lower", "tests/test_mathutils.py::test_ceil_oor_upper"], "indent": 4}
{"namespace": "boltons.formatutils.get_format_args", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/formatutils.py", "signature_position": [156, 156], "body_position": [172, 200], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes a format string and returns two lists of arguments referenced by the format string. One list contains positional arguments, and the other contains named arguments. Each element of the list includes the name and the nominal type of the field.", "Arguments": ":param fstr: String. The format string to be processed.\n:return: Tuple. Two lists of arguments referenced by the format string. The first list contains positional arguments, and the second list contains named arguments."}, "tests": ["tests/test_formatutils.py::test_get_fstr_args"], "indent": 4}
{"namespace": "boltons.mathutils.floor", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/mathutils.py", "signature_position": [100, 100], "body_position": [117, 124], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Return the floor of the input number. If the options are set, return the largest integer or float from the options that is less than or equal to the input number.", "Arguments": ":param x: int or float. Number to be tested.\n:param options: iterable. Optional iterable of arbitrary numbers (ints or floats).\n:return: int or float. The floor of x. If options is not None, return the largest integer or float from the options that is less than or equal to the input number."}, "tests": ["tests/test_mathutils.py::test_floor_basic", "tests/test_mathutils.py::test_floor_oor_lower", "tests/test_mathutils.py::test_floor_oor_upper"], "indent": 4}
{"namespace": "boltons.dictutils.OneToOne.setdefault", "type": "method", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/dictutils.py", "signature_position": [869, 869], "body_position": [870, 872], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Set the default value for the key if the key is not in the instance, else returns the value.", "Arguments": ":param self: OneToOne. An instance of the OneToOne class.\n:param key: The key to set the default value.\n:param default: The default value to set for the key. Defaults to None.\n:return: The value corresponding to the key."}, "tests": ["tests/test_dictutils.py::test_one_to_one"], "indent": 8}
{"namespace": "boltons.dictutils.OneToOne.update", "type": "method", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/dictutils.py", "signature_position": [874, 874], "body_position": [875, 888], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Update the OneToOne instance with the given dictionary or iterable and keyword arguments. It first checks if the input is a dictionary or an iterable and then updates the instance with the input values.", "Arguments": ":param self: OneToOne. An instance of the OneToOne class.\n:param dict_or_iterable: Dictionary or Iterable. The dictionary or iterable to update the instance with.\n:param kw: Keyword arguments. Additional keyword arguments to update the instance with.\n:return: No return values."}, "tests": ["tests/test_dictutils.py::test_one_to_one"], "indent": 8}
{"namespace": "boltons.dictutils.ManyToMany.get", "type": "method", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/dictutils.py", "signature_position": [920, 920], "body_position": [921, 924], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the value corresponding to the key in the ManyToMany instance. If the key is not found, it returns the default value.", "Arguments": ":param self: ManyToMany. An instance of the ManyToMany class.\n:param key: The key to retrieve the value from the instance.\n:param default: Frozenset. The value to return if the key is not found in the instance. Defaults to an empty frozenset.\n:return: The value corresponding to the key or the default value."}, "tests": ["tests/test_dictutils.py::test_many_to_many"], "indent": 8}
{"namespace": "boltons.dictutils.FrozenDict.updated", "type": "method", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/dictutils.py", "signature_position": [1071, 1071], "body_position": [1076, 1078], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Make a copy of the FrozenDict and add items from a dictionary or iterable (and/or keyword arguments), overwriting values under an existing key.", "Arguments": ":param self: FrozenDict. An instance of the FrozenDict class.\n:param *a: Tuple. A tuple of dictionaries or iterables.\n:param **kw: Dict. A dictionary of keyword arguments.\n:return: The updated FrozenDict instance."}, "tests": ["tests/test_dictutils.py::test_frozendict"], "indent": 8}
{"namespace": "boltons.dictutils.subdict", "type": "function", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/dictutils.py", "signature_position": [1020, 1020], "body_position": [1042, 1049], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function computes the \"subdictionary\" of a dictionary. It returns a new dictionary with any keys in *drop* removed, and any keys in *keep* still present, provided they were in the original dictionary.", "Arguments": ":param d: Dictionary. The original dictionary.\n:param keep: List. The list of keys to keep in the original dictionary. Defaults to all keys.\n:param drop: List. The list of keys to remove from the original dictionary. Defaults to empty.\n:return: Dictionary. The subdictionary of the original dictionary."}, "tests": ["tests/test_dictutils.py::test_subdict_keep_type", "tests/test_dictutils.py::test_subdict"], "indent": 4}
{"namespace": "boltons.dictutils.FrozenDict.__repr__", "type": "method", "project_path": "Utilities/boltons", "completion_path": "Utilities/boltons/boltons/dictutils.py", "signature_position": [1085, 1085], "body_position": [1086, 1087], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a string representation of the FrozenDict instance. The format is f'{class_name}({dict_repr})'", "Arguments": ":param self: FrozenDict. An instance of the FrozenDict class.\n:return: String. The string representation of the FrozenDict instance."}, "tests": ["tests/test_dictutils.py::test_frozendict"], "indent": 8}
{"namespace": "gunicorn.config.validate_callable", "type": "function", "project_path": "Utilities/gunicorn", "completion_path": "Utilities/gunicorn/gunicorn/config.py", "signature_position": [420, 420], "body_position": [421, 441], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function validates the input value to ensure it is a callable object with the specified arity. It first checks if the input value is a string, then tries to import the module and get the object. If the input value is not callable or has a different arity, it raises a TypeError.", "Arguments": ":param arity: Integer. The arity of the callable object. If set to -1, it means the arity can be any value.\n:return: Callable. The validated callable object."}, "tests": ["tests/test_config.py::test_callable_validation_for_string"], "indent": 4}
{"namespace": "gunicorn.config.get_default_config_file", "type": "function", "project_path": "Utilities/gunicorn", "completion_path": "Utilities/gunicorn/gunicorn/config.py", "signature_position": [529, 529], "body_position": [530, 534], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the path of the default configuration file for Gunicorn. It first creates the path by joining the current working directory with the file name 'gunicorn.conf.py'. Then, it checks if the file exists and returns the path if it does.", "Arguments": ":param: No input parameters.\n:return: String. The path of the default configuration file for Gunicorn. If the file does not exist, it returns None."}, "tests": ["tests/test_config.py::test_default_config_file"], "indent": 4}
{"namespace": "gunicorn.util.is_ipv6", "type": "function", "project_path": "Utilities/gunicorn", "completion_path": "Utilities/gunicorn/gunicorn/util.py", "signature_position": [217, 217], "body_position": [218, 224], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if the given address is a valid IPv6 address.", "Arguments": ":param addr: String. The address to be checked.\n:return: Bool. True if the address is a valid IPv6 address, False otherwise."}, "tests": ["tests/test_util.py::test_is_ipv6"], "indent": 4}
{"namespace": "gunicorn.systemd.listen_fds", "type": "function", "project_path": "Utilities/gunicorn", "completion_path": "Utilities/gunicorn/gunicorn/systemd.py", "signature_position": [12, 12], "body_position": [36, 46], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function gets the number of sockets inherited from systemd socket activation. It returns zero immediately if $LISTEN_PID is not set to the current pid. Otherwise, it returns the number of systemd activation sockets specified by $LISTEN_FDS. It also unsets the environment variables if the unset_environment flag is True.", "Arguments": ":param unset_environment: Bool. Clear systemd environment variables unless False.\n:return: Int. The number of sockets to inherit from systemd socket activation."}, "tests": ["tests/test_systemd.py::test_listen_fds_ignores_wrong_pid", "tests/test_systemd.py::test_listen_fds_returns_count"], "indent": 4}
{"namespace": "gunicorn.util.http_date", "type": "function", "project_path": "Utilities/gunicorn", "completion_path": "Utilities/gunicorn/gunicorn/util.py", "signature_position": [460, 460], "body_position": [462, 465], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the current date and time formatted for a message header. If the timestamp is not provided, it uses the current time.", "Arguments": ":param timestamp: Float. The timestamp to be formatted. Defaults to None.\n:return: String. The formatted date and time for a message header."}, "tests": ["tests/test_util.py::test_http_date"], "indent": 4}
{"namespace": "gunicorn.util.parse_address", "type": "function", "project_path": "Utilities/gunicorn", "completion_path": "Utilities/gunicorn/gunicorn/util.py", "signature_position": [227, 227], "body_position": [228, 255], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function parses the address and returns the host and port. It first checks if the address is a unix socket, then a file descriptor, and finally a TCP address. It then returns the host and port based on the address.", "Arguments": ":param netloc: String. The network location to parse.\n:param default_port: String. The default port to use if the port is not specified in the address. Defaults to '8000'.\n:return: Tuple. A tuple containing the host and port."}, "tests": ["tests/test_util.py::test_parse_fd_invalid", "tests/test_util.py::test_parse_address_invalid", "tests/test_util.py::test_parse_address"], "indent": 4}
{"namespace": "gunicorn.util.to_bytestring", "type": "function", "project_path": "Utilities/gunicorn", "completion_path": "Utilities/gunicorn/gunicorn/util.py", "signature_position": [573, 573], "body_position": [575, 580], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Converts a string argument to a byte string using the specified encoding.", "Arguments": ":param value: String. The input string to be converted to a byte string.\n:param encoding: String. The encoding to be used for the conversion. Defaults to \"utf8\".\n:return: Bytes. The byte string converted from the input string."}, "tests": ["tests/test_util.py::test_to_bytestring", "tests/test_http.py::test_http_header_encoding"], "indent": 4}
{"namespace": "gunicorn.util.warn", "type": "function", "project_path": "Utilities/gunicorn", "completion_path": "Utilities/gunicorn/gunicorn/util.py", "signature_position": [596, 596], "body_position": [597, 606], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Prints a warning message to the standard error output. The format of the message is \"WARNING: %s\\n\" % msg.", "Arguments": ":param msg: String. The warning message to be printed.\n:return: No return values."}, "tests": ["tests/test_util.py::test_warn"], "indent": 4}
{"namespace": "gunicorn.util.split_request_uri", "type": "function", "project_path": "Utilities/gunicorn", "completion_path": "Utilities/gunicorn/gunicorn/util.py", "signature_position": [622, 622], "body_position": [623, 631], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function splits the given URI into its components. If the URI starts with \"//\", it is considered as a relative URI, but the function considers it as an absolute path. It uses a temporary dot prefix to work around this behavior.", "Arguments": ":param uri: String. The URI to be split.\n:return: The components of the URI."}, "tests": ["tests/test_util.py::test_split_request_uri"], "indent": 4}
{"namespace": "praw.models.listing.listing.ModNoteListing.after", "type": "method", "project_path": "Utilities/praw", "completion_path": "Utilities/praw/praw/models/listing/listing.py", "signature_position": [46, 46], "body_position": [48, 50], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This method returns the next attribute or None based on the condition. If the \"has_next_page\" attribute is False, it returns None. Otherwise, it returns the \"end_cursor\" attribute.", "Arguments": ":param self: ModNoteListing. An instance of the ModNoteListing class.\n:return: Optional[Any]. The next attribute or None."}, "tests": ["tests/unit/models/listing/test_listing.py::TestModNoteListing::test_has_next_page"], "indent": 8}
{"namespace": "praw.models.util.permissions_string", "type": "function", "project_path": "Utilities/praw", "completion_path": "Utilities/praw/praw/models/util.py", "signature_position": [11, 13], "body_position": [25, 32], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a comma-separated string of permission changes. It takes a set of known permissions and a list of permissions and returns a string of permission changes.", "Arguments": ":param known_permissions: Set of strings. A set of strings representing the available permissions.\n:param permissions: List of strings or None. A list of strings, or ``None``. These strings can exclusively contain ``+`` or ``-`` prefixes, or contain no prefixes at all. When prefixed, the resulting string will simply be the joining of these inputs. When not prefixed, all permissions are considered to be additions, and all permissions in the ``known_permissions`` set that aren't provided are considered to be removals. When ``None``, the result is ``\"+all\"``.\n:return: str. A comma-separated string of permission changes."}, "tests": ["tests/unit/models/test_util.py::TestPermissionsString::test_permissions_string__all_explicit", "tests/unit/models/test_util.py::TestPermissionsString::test_permissions_string__none", "tests/unit/models/test_util.py::TestPermissionsString::test_permissions_string__with_additional_permissions", "tests/unit/models/test_util.py::TestPermissionsString::test_permissions_string__empty_list"], "indent": 4}
{"namespace": "jc.cli.JcCli.json_out", "type": "method", "project_path": "Utilities/jc", "completion_path": "Utilities/jc/jc/cli.py", "signature_position": [382, 382], "body_position": [387, 406], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a JSON formatted string. The string may include color codes or be pretty printed based on the input parameters.", "Arguments": ":param self: JcCli. An instance of the JcCli class.\n:return: str. The JSON formatted string."}, "tests": ["tests/test_jc_cli.py::MyTests::test_cli_json_out_mono", "tests/test_jc_cli.py::MyTests::test_cli_json_out"], "indent": 8}
{"namespace": "pythonforandroid.pythonpackage.transform_dep_for_pip", "type": "function", "project_path": "Utilities/python-for-android", "completion_path": "Utilities/python-for-android/pythonforandroid/pythonpackage.py", "signature_position": [55, 55], "body_position": [56, 74], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function transforms the dependency for pip. It checks if the dependency contains \"@\" and \"://\". If it does, it transforms the dependency to a URL format that pip can install. If not, it returns the original dependency.", "Arguments": ":param dependency: String. The dependency to be transformed.\n:return: String. The transformed dependency for pip."}, "tests": ["tests/test_pythonpackage_basic.py::test_transform_dep_for_pip"], "indent": 4}
{"namespace": "pythonforandroid.graph.fix_deplist", "type": "function", "project_path": "Utilities/python-for-android", "completion_path": "Utilities/python-for-android/pythonforandroid/graph.py", "signature_position": [10, 10], "body_position": [14, 22], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function turns a dependency list into lowercase and ensures that all entries that are just a string become a tuple of strings.", "Arguments": ":param deps: List. A list of dependencies.\n:return: List. The modified dependency list."}, "tests": ["tests/test_graph.py::test_misc_obvious_conflict_checker", "tests/test_graph.py::test_valid_obvious_conflict_checker", "tests/test_graph.py::test_invalid_obvious_conflict_checker", "tests/test_graph.py::test_multichoice_obvious_conflict_checker", "tests/test_graph.py::test_indirectconflict_obvious_conflict_checker"], "indent": 4}
{"namespace": "pythonforandroid.util.walk_valid_filens", "type": "function", "project_path": "Utilities/python-for-android", "completion_path": "Utilities/python-for-android/pythonforandroid/util.py", "signature_position": [48, 48], "body_position": [62, 75], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function walks through all the files and directories in the base directory, ignoring the directories and files that match the specified patterns. It yields the full path of the valid files.", "Arguments": ":param base_dir: String. The base directory to start walking from.\n:param invalid_dir_names: List of strings. A list of invalid directory names to be ignored.\n:param invalid_file_patterns: List of strings. A list of glob patterns to be compared against the full file path.\n:return: Yield the full path of the valid files."}, "tests": ["tests/test_util.py::TestUtil::test_walk_valid_filens"], "indent": 4}
{"namespace": "pythonforandroid.bootstrap._cmp_bootstraps_by_priority", "type": "function", "project_path": "Utilities/python-for-android", "completion_path": "Utilities/python-for-android/pythonforandroid/bootstrap.py", "signature_position": [50, 50], "body_position": [51, 67], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function compares two bootstraps based on their priority and name. It first ranks the bootstraps based on their priority and then compares their names.", "Arguments": ":param a: The first bootstrap to compare.\n:param b: The second bootstrap to compare.\n:return: Integer. The difference in the priority of the two bootstraps."}, "tests": ["tests/test_bootstrap.py::TestBootstrapBasic::test__cmp_bootstraps_by_priority"], "indent": 4}
{"namespace": "pythonforandroid.bootstrap.Bootstrap.all_bootstraps", "type": "method", "project_path": "Utilities/python-for-android", "completion_path": "Utilities/python-for-android/pythonforandroid/bootstrap.py", "signature_position": [194, 194], "body_position": [196, 205], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Find all the available bootstraps and return them. It first finds the bootstraps directory and then iterates through the files in the directory to find the available bootstraps.", "Arguments": ":param cls: Class. The class instance.\n:return: Set. A set of available bootstraps."}, "tests": ["tests/test_bootstrap.py::TestBootstrapBasic::test_all_bootstraps"], "indent": 8}
{"namespace": "mmcv.image.colorspace._convert_input_type_range", "type": "function", "project_path": "Utilities/mmcv", "completion_path": "Utilities/mmcv/mmcv/image/colorspace.py", "signature_position": [86, 86], "body_position": [102, 111], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts the type and range of the input image. It converts the input image to np.float32 type and range of [0, 1]. It is mainly used for pre-processing the input image in colorspace conversion functions such as rgb2ycbcr and ycbcr2rgb.", "Arguments": ":param img: ndarray. The input image. It accepts: 1. np.uint8 type with range [0, 255]; 2. np.float32 type with range [0, 1].\n:return: ndarray. The converted image with type of np.float32 and range of [0, 1]."}, "tests": ["tests/test_image/test_colorspace.py::test_convert_input_type_range"], "indent": 4}
{"namespace": "mackup.utils.error", "type": "function", "project_path": "Utilities/mackup", "completion_path": "Utilities/mackup/mackup/utils.py", "signature_position": [184, 184], "body_position": [191, 193], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Throw an error with the given message and immediately quit the program.", "Arguments": ":param message: str. The message to display when the error occurs.\n:return: No return values."}, "tests": ["tests/utils_test.py::TestMackup::test_error"], "indent": 4}
{"namespace": "mmcv.image.colorspace._convert_output_type_range", "type": "function", "project_path": "Utilities/mmcv", "completion_path": "Utilities/mmcv/mmcv/image/colorspace.py", "signature_position": [114, 115], "body_position": [136, 143], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert the type and range of the input image according to the specified destination type. It converts the image to the desired type and range based on the destination type.", "Arguments": ":param img: np.ndarray. The input image to be converted with np.float32 type and range [0, 255].\n:param dst_type: Union[np.uint8, np.float32]. The destination type to which the image should be converted. If dst_type is np.uint8, it converts the image to np.uint8 type with range [0, 255]. If dst_type is np.float32, it converts the image to np.float32 type with range [0, 1].\n:return: np.ndarray. The converted image with the desired type and range."}, "tests": ["tests/test_image/test_colorspace.py::test_convert_output_type_range"], "indent": 4}
{"namespace": "mackup.utils.is_process_running", "type": "function", "project_path": "Utilities/mackup", "completion_path": "Utilities/mackup/mackup/utils.py", "signature_position": [301, 301], "body_position": [311, 319], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if a process with the given name is running. It uses the pgrep command to check if the process is running.", "Arguments": ":param process_name: str. The name of the process to check.\n:return: bool. True if the process is running, False otherwise."}, "tests": ["tests/utils_test.py::TestMackup::test_is_process_running"], "indent": 4}
{"namespace": "stellar.operations._get_pid_column", "type": "function", "project_path": "Utilities/stellar", "completion_path": "Utilities/stellar/stellar/operations.py", "signature_position": [28, 29], "body_position": [30, 33], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the name of the column that contains the process ID based on the server version. It first retrieves the server version from the raw connection and then processes it to extract the version number. It then compares the version number with a predefined value and returns the column name accordingly.", "Arguments": ":param raw_conn: The raw connection to the database.\n:return: String. The name of the column that contains the process ID."}, "tests": ["tests/test_operations.py::TestGetPidColumn::test_returns_procpid_for_version_older_than_9_2", "tests/test_operations.py::TestGetPidColumn::test_returns_pid_for_version_equal_or_newer_than_9_2"], "indent": 4}
{"namespace": "imapclient.imap_utf7.encode", "type": "function", "project_path": "Communications/IMAPClient", "completion_path": "Communications/IMAPClient/imapclient/imap_utf7.py", "signature_position": [14, 14], "body_position": [20, 55], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Encode a folder name using IMAP modified UTF-7 encoding. It takes a string or bytes as input and returns the encoded bytes. If the input is not a string, it returns the input unchanged.", "Arguments": ":param s: Union[str, bytes]. The input string to be encoded.\n:return: bytes. The encoded bytes of the input string."}, "tests": ["tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_encode", "tests/test_imap_utf7.py::IMAP4UTF7TestCase::test_printable_singletons"], "indent": 4}
{"namespace": "imapclient.version._imapclient_version_string", "type": "function", "project_path": "Communications/IMAPClient", "completion_path": "Communications/IMAPClient/imapclient/version.py", "signature_position": [10, 10], "body_position": [11, 15], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "It creates a version string based on the given version information. It first extracts the major, minor, micro, and release level from the version information and then creates a version string based on the extracted information.", "Arguments": ":param vinfo: Tuple. A tuple containing version information in the format (major, minor, micro, releaselevel).\n:return: String. The version string created based on the version information."}, "tests": ["tests/test_version.py::TestVersionString::test_alpha", "tests/test_version.py::TestVersionString::test_dot_oh", "tests/test_version.py::TestVersionString::test_beta_point", "tests/test_version.py::TestVersionString::test_minor", "tests/test_version.py::TestVersionString::test_point_release"], "indent": 4}
{"namespace": "telethon.helpers.generate_key_data_from_nonce", "type": "function", "project_path": "Communications/Telethon", "completion_path": "Communications/Telethon/telethon/helpers.py", "signature_position": [271, 271], "body_position": [273, 281], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function generates the key data corresponding to the given nonce. It first converts the server_nonce and new_nonce to bytes and then uses them to generate hash1, hash2, and hash3. Finally, it combines hash1 and the first 12 bytes of hash2 to form the key, and combines the remaining bytes of hash2, hash3, and the first 4 bytes of new_nonce to form the iv.", "Arguments": ":param server_nonce: int. The server nonce.\n:param new_nonce: int. The new nonce.\n:return: Tuple. The key and iv generated from the nonces."}, "tests": ["tests/telethon/test_helpers.py::test_generate_key_data_from_nonce"], "indent": 4}
{"namespace": "hbmqtt.codecs.bytes_to_int", "type": "function", "project_path": "Communications/hbmqtt", "completion_path": "Communications/hbmqtt/hbmqtt/codecs.py", "signature_position": [18, 18], "body_position": [24, 27], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert a sequence of bytes to an integer using big endian byte ordering. It first converts the byte sequence to an integer using big endian byte ordering.", "Arguments": ":param data: byte sequence. The sequence of bytes to be converted to an integer.\n:return: integer value. The integer value converted from the byte sequence."}, "tests": ["tests/test_codecs.py::TestCodecs::test_bytes_to_int"], "indent": 4}
{"namespace": "zulipterminal.helper.display_error_if_present", "type": "function", "project_path": "Communications/zulip-term", "completion_path": "Communications/zulip-term/zulipterminal/helper.py", "signature_position": [658, 658], "body_position": [659, 660], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if the response contains an error and if the controller has a \"view\" attribute. If both conditions are met, it reports the error message.", "Arguments": ":param response: Dict[str, Any]. A dictionary containing the response data.\n:param controller: Any. An object that may have a \"view\" attribute.\n:return: None. No return value."}, "tests": ["tests/helper/test_helper.py::test_display_error_if_present"], "indent": 4}
{"namespace": "zulipterminal.ui_tools.buttons.MessageLinkButton._decode_message_id", "type": "method", "project_path": "Communications/zulip-term", "completion_path": "Communications/zulip-term/zulipterminal/ui_tools/buttons.py", "signature_position": [455, 455], "body_position": [459, 462], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function decodes the message ID to an integer if it is compatible, otherwise, it returns None.", "Arguments": ":param message_id: str. The message ID to be decoded.\n:return: Optional[int]. The compatible near message ID or None."}, "tests": ["tests/ui_tools/test_buttons.py::TestMessageLinkButton::test__decode_message_id"], "indent": 8}
{"namespace": "zulipterminal.ui_tools.buttons.MessageLinkButton.handle_narrow_link", "type": "method", "project_path": "Communications/zulip-term", "completion_path": "Communications/zulip-term/zulipterminal/ui_tools/buttons.py", "signature_position": [608, 608], "body_position": [613, 623], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function narrows to the respective narrow if the narrow link is valid or updates the footer with an appropriate validation error message.", "Arguments": ":param self: MessageLinkButton. An instance of the MessageLinkButton class.\n:return: None. No return value."}, "tests": ["tests/ui_tools/test_buttons.py::TestMessageLinkButton::test_handle_narrow_link"], "indent": 8}
{"namespace": "zulipterminal.config.color.color_properties", "type": "function", "project_path": "Communications/zulip-term", "completion_path": "Communications/zulip-term/zulipterminal/config/color.py", "signature_position": [55, 55], "body_position": [68, 77], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function adds properties(Bold, Italics, etc...) to Enum Colors in theme files. It creates a new Enum with the given properties and returns it.", "Arguments": ":param colors: Any. The Enum colors to which properties are to be added.\n:param prop: str. The properties to be added to the Enum colors.\n:return: Any. The updated Enum with the added properties."}, "tests": ["tests/config/test_color.py::test_color_properties"], "indent": 4}
{"namespace": "twilio.base.deserialize.decimal", "type": "function", "project_path": "Communications/twilio-fatisar", "completion_path": "Communications/twilio-fatisar/twilio/base/deserialize.py", "signature_position": [56, 56], "body_position": [61, 63], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function parses a decimal string into a Decimal object using the BasicContext.", "Arguments": ":param d: Optional string. The decimal string to be parsed.\n:return: Union[Decimal, str]. The parsed Decimal object or the original string if it is empty."}, "tests": ["tests/unit/base/test_deserialize.py::DecimalTestCase::test_positive_string", "tests/unit/base/test_deserialize.py::DecimalTestCase::test_zero_string", "tests/unit/base/test_deserialize.py::DecimalTestCase::test_empty_string", "tests/unit/base/test_deserialize.py::DecimalTestCase::test_zero", "tests/unit/base/test_deserialize.py::DecimalTestCase::test_negative_string"], "indent": 4}
{"namespace": "twilio.base.deserialize.integer", "type": "function", "project_path": "Communications/twilio-fatisar", "completion_path": "Communications/twilio-fatisar/twilio/base/deserialize.py", "signature_position": [66, 66], "body_position": [72, 75], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function parses an integer string into an integer. If the input string is not a valid integer, it returns the input string as it is.", "Arguments": ":param i: str. The input integer string.\n:return: Union[int, str]. The parsed integer if the input string is a valid integer, otherwise the input string itself."}, "tests": ["tests/unit/base/test_deserialize.py::IntegerTestCase::test_empty_string", "tests/unit/base/test_deserialize.py::IntegerTestCase::test_zero_string", "tests/unit/base/test_deserialize.py::IntegerTestCase::test_zero", "tests/unit/base/test_deserialize.py::IntegerTestCase::test_positive_string", "tests/unit/base/test_deserialize.py::IntegerTestCase::test_negative_string"], "indent": 4}
{"namespace": "twilio.base.serialize.object", "type": "function", "project_path": "Communications/twilio-fatisar", "completion_path": "Communications/twilio-fatisar/twilio/base/serialize.py", "signature_position": [64, 64], "body_position": [69, 71], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a JSON string representation of the input object if the object is JSONifiable. Otherwise, it returns the object untouched.", "Arguments": ":param obj: Any. The input object to be converted to a JSON string.\n:return: String. The JSON string representation of the input object if it is JSONifiable, otherwise the input object itself."}, "tests": ["tests/unit/base/test_serialize.py::ObjectTestCase::test_object", "tests/unit/base/test_serialize.py::ObjectTestCase::test_list", "tests/unit/base/test_serialize.py::ObjectTestCase::test_does_not_change_other_types"], "indent": 4}
{"namespace": "twilio.base.serialize.map", "type": "function", "project_path": "Communications/twilio-fatisar", "completion_path": "Communications/twilio-fatisar/twilio/base/serialize.py", "signature_position": [74, 74], "body_position": [78, 80], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function applies the serialize_func to every element in the input list lst.", "Arguments": ":param lst: list. The input list.\n:param serialize_func: function. The function to be applied to every element in the list.\n:return: list. The list of elements after applying the serialize_func to each element."}, "tests": ["tests/unit/base/test_serialize.py::MapTestCase::test_maps_func_to_list", "tests/unit/base/test_serialize.py::MapTestCase::test_does_not_change_other_types"], "indent": 4}
{"namespace": "twilio.base.obsolete.deprecated_method", "type": "function", "project_path": "Communications/twilio-fatisar", "completion_path": "Communications/twilio-fatisar/twilio/base/obsolete.py", "signature_position": [24, 24], "body_position": [30, 47], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a decorator that can be used to mark deprecated methods. It will report a DeprecationWarning being emitted to stderr when the deprecated method is used.", "Arguments": ":param new_func: Function. The new function that replaces the deprecated method.\n:return: The deprecated_method_wrapper function."}, "tests": ["tests/unit/base/test_deprecation.py::DeprecatedMethodTest::test_deprecation_decorator", "tests/unit/base/test_deprecation.py::DeprecatedMethodTest::test_deprecation_decorator_with_new_method"], "indent": 4}
{"namespace": "chatette.utils.sample_indulgent", "type": "function", "project_path": "Communications/chatette", "completion_path": "Communications/chatette/chatette/utils.py", "signature_position": [87, 87], "body_position": [93, 95], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is similar to the random.sample function but does not raise an error if the number of items to be sampled is larger than the length of the array. In that case, it simply returns a copy of the whole array.", "Arguments": ":param array: List. The input array from which items are to be sampled.\n:param nb_items: Integer. The number of items to be sampled from the array.\n:return: List. The sampled items from the array or a copy of the whole array if nb_items is larger than the length of the array."}, "tests": ["tests/unit-testing/test_utils.py::TestSampleIndulgent::test_sample", "tests/unit-testing/test_utils.py::TestSampleIndulgent::test_empty"], "indent": 4}
{"namespace": "chatette.utils.rchop", "type": "function", "project_path": "Communications/chatette", "completion_path": "Communications/chatette/chatette/utils.py", "signature_position": [98, 98], "body_position": [100, 102], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function removes a specified substring from the end of a given string.", "Arguments": ":param string: String. The input string from which the substring will be removed.\n:param ending: String. The substring to be removed from the end of the input string.\n:return: String. The modified string after removing the specified substring from the end. If the input string does not end with the specified substring, the original string is returned."}, "tests": ["tests/unit-testing/test_utils.py::TestRChop::test_not_ending", "tests/unit-testing/test_utils.py::TestRChop::test_ending"], "indent": 4}
{"namespace": "chatette.utils.str_to_bool", "type": "function", "project_path": "Communications/chatette", "completion_path": "Communications/chatette/chatette/utils.py", "signature_position": [105, 105], "body_position": [110, 115], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function transforms the strings 'True' and 'False' to their boolean counterparts. It raises a `ValueError` if `text` is neither of them.", "Arguments": ":param text: String. The input string to be transformed into a boolean.\n:return: Bool. The boolean counterpart of the input string."}, "tests": ["tests/unit-testing/test_utils.py::TestStrToBool::test_not_bool", "tests/unit-testing/test_utils.py::TestStrToBool::test_str_to_bool"], "indent": 4}
{"namespace": "chatette.utils.min_if_exist", "type": "function", "project_path": "Communications/chatette", "completion_path": "Communications/chatette/chatette/utils.py", "signature_position": [122, 122], "body_position": [127, 133], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the minimum between two numbers, or the only defined number (in case the other is `None`) or `None` if none of the numbers are defined.", "Arguments": ":param n1: The first number.\n:param n2: The second number.\n:return: The minimum between the two numbers, or the only defined number, or `None` if none of the numbers are defined."}, "tests": ["tests/unit-testing/test_utils.py::TestMinIfExist::test_min_if_exist"], "indent": 4}
{"namespace": "chatette.utils.append_to_list_in_dict", "type": "function", "project_path": "Communications/chatette", "completion_path": "Communications/chatette/chatette/utils.py", "signature_position": [143, 143], "body_position": [149, 152], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function appends the value to the list at the given key in the dictionary. If the list does not exist, it creates a new list containing the value and puts it at the key.", "Arguments": ":param dict_of_lists: Dictionary. The dictionary of key->lists.\n:param key: The key to which the value is to be appended.\n:param value: The value to be appended to the list at the given key.\n:return: No return values."}, "tests": ["tests/unit-testing/test_utils.py::TestAppendToListInDict::test_append"], "indent": 4}
{"namespace": "chatette.utils.extend_list_in_dict", "type": "function", "project_path": "Communications/chatette", "completion_path": "Communications/chatette/chatette/utils.py", "signature_position": [154, 154], "body_position": [160, 163], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function extends the list at the given key in the dictionary with the given values if the list exists. Otherwise, it puts the list of values at the given key.", "Arguments": ":param dict_of_lists: Dictionary. The dictionary of key->lists.\n:param key: The key in the dictionary.\n:param values: List. The list of values to be extended or put in the dictionary.\n:return: No return values."}, "tests": ["tests/unit-testing/test_utils.py::TestExtendListInDict::test_extend"], "indent": 4}
{"namespace": "chatette.cli.interactive_commands.command_strategy.CommandStrategy._is_end_regex", "type": "method", "project_path": "Communications/chatette", "completion_path": "Communications/chatette/chatette/cli/interactive_commands/command_strategy.py", "signature_position": [87, 87], "body_position": [89, 92], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if the given word is the end of a regex '\\/(g?i?|i?g?)$'.", "Arguments": ":param word: String. The word to be checked.\n:return: Bool. True if the word is the end of a regex, False otherwise."}, "tests": ["tests/unit-testing/cli/interactive_commands/test_command_strategy.py::TestIsEndRegex::test_regexes"], "indent": 8}
{"namespace": "chatette.cli.interactive_commands.command_strategy.CommandStrategy.execute", "type": "method", "project_path": "Communications/chatette", "completion_path": "Communications/chatette/chatette/cli/interactive_commands/command_strategy.py", "signature_position": [272, 272], "body_position": [279, 314], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function executes the whole command represented by the object. It can be overridden by subclasses if a different algorithm is required.", "Arguments": ":param self: CommandStrategy. An instance of the CommandStrategy class.\n:return: No return values."}, "tests": ["tests/unit-testing/cli/interactive_commands/test_show_command.py::test_err", "tests/unit-testing/cli/interactive_commands/test_hide_command.py::test_err", "tests/unit-testing/cli/interactive_commands/test_hide_command.py::test_execute", "tests/unit-testing/cli/interactive_commands/test_show_command.py::test_execute", "tests/unit-testing/cli/interactive_commands/test_hide_command.py::test_variations"], "indent": 8}
{"namespace": "aioxmpp.network.group_and_order_srv_records", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/network.py", "signature_position": [399, 399], "body_position": [409, 435], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function orders a list of SRV record information and groups and orders them as specified by the RFC. It returns an iterable, yielding each ``(hostname, port)`` tuple inside the SRV records in the order specified by the RFC. For hosts with the same priority, the given `rng` implementation is used (if none is given, the :mod:`random` module is used).", "Arguments": ":param all_records: List. A list of SRV record information.\n:param rng: Random. The random number generator to be used for hosts with the same priority. Defaults to None.\n:return: Iterable. An iterable, yielding each ``(hostname, port)`` tuple inside the SRV records in the order specified by the RFC."}, "tests": ["tests/test_network.py::Testgroup_and_order_srv_records::test_group_by_priority", "tests/test_network.py::Testgroup_and_order_srv_records::test_one_record_with_zero_weight", "tests/test_network.py::Testgroup_and_order_srv_records::test_equal_prio_weight_and_uncomparable_object"], "indent": 4}
{"namespace": "aioxmpp.nonza.StreamFeatures.get_feature", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/nonza.py", "signature_position": [272, 272], "body_position": [279, 282], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the first instance of a feature of the given `feature_cls` type if it is contained in the current stream features set. Otherwise, it returns the default value.", "Arguments": ":param self: StreamFeatures. An instance of the StreamFeatures class.\n:param feature_cls: The type of feature to be returned.\n:param default: The value to return if the feature is not found in the instance. Defaults to None.\n:return: The first instance of the feature of the given `feature_cls` type if it is contained in the current stream features set. Otherwise, it returns the default value."}, "tests": ["tests/test_nonza.py::TestStreamFeatures::test_get_feature"], "indent": 8}
{"namespace": "aioxmpp.connector.XMPPOverTLSConnector._context_factory_factory", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/connector.py", "signature_position": [291, 291], "body_position": [292, 310], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function creates a context factory for the XMPPOverTLSConnector. It sets the ALPN protocol to \"xmpp-client\" if the ssl_context has the set_alpn_protos method. It also sets up the context with the verifier and returns the ssl_context.", "Arguments": ":param self: XMPPOverTLSConnector. An instance of the XMPPOverTLSConnector class.\n:param logger: The logger to be used for logging.\n:param metadata: The metadata to be used for creating the ssl context.\n:param verifier: The verifier to be used for setting up the context.\n:return: The context factory function."}, "tests": ["tests/test_connector.py::TestXMPPOverTLSConnector::test_context_factory_warns_if_set_alpn_protos_is_not_defined", "tests/test_connector.py::TestXMPPOverTLSConnector::test_context_factory", "tests/test_connector.py::TestXMPPOverTLSConnector::test_context_factory_warns_if_set_alpn_protos_raises"], "indent": 8}
{"namespace": "aioxmpp.xmltestutils.element_path", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/xmltestutils.py", "signature_position": [25, 25], "body_position": [26, 42], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the path of the given element in the XML tree. It starts from the given element and goes up to the root element or the specified element. It constructs the path based on the tag name and index of the element in the parent.", "Arguments": ":param el: Element. The given element for which the path is to be constructed.\n:param upto: Element. The element up to which the path is to be constructed. Defaults to None, which means the root element.\n:return: String. The constructed path of the element."}, "tests": ["tests/test_xmltestutils.py::TestTestUtils::test_element_path"], "indent": 4}
{"namespace": "aioxmpp.structs.JID.fromstr", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/structs.py", "signature_position": [796, 796], "body_position": [811, 819], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Construct a JID instance from a string containing it. It parses the input string and constructs a JID instance based on the parsed components.", "Arguments": ":param s: The string to parse.\n:type s: :class:`str`\n:param strict: Whether to enable strict parsing.\n:type strict: :class:`bool`\n:raises: See :class:`JID`\n:return: The parsed JID\n:rtype: :class:`JID`"}, "tests": ["tests/test_protocol.py::TestXMLStream::test_send_xso"], "indent": 8}
{"namespace": "aioxmpp.security_layer.extract_python_dict_from_x509", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/security_layer.py", "signature_position": [140, 140], "body_position": [151, 178], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function extracts a python dictionary from the given X509 object. It extracts the subject and subjectAltName attributes from the X509 object and puts them in the result dictionary.", "Arguments": ":param x509: X509. The X509 object from which the dictionary is to be extracted.\n:return: Dictionary. The extracted python dictionary containing the subject and subjectAltName attributes."}, "tests": ["tests/test_security_layer.py::Testextract_python_dict_from_x509::test_zombofant_net"], "indent": 4}
{"namespace": "aioxmpp.security_layer.extract_blob", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/security_layer.py", "signature_position": [181, 181], "body_position": [187, 189], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Extract an ASN.1 blob from the given X509 certificate. It returns the resulting bytes object.", "Arguments": ":param x509: X509. The OpenSSL.crypto.X509 certificate from which the ASN.1 blob is to be extracted.\n:return: bytes. The resulting ASN.1 blob."}, "tests": ["tests/test_security_layer.py::Testextract_blob::test_generic"], "indent": 4}
{"namespace": "aioxmpp.security_layer.blob_to_pyasn1", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/security_layer.py", "signature_position": [192, 192], "body_position": [198, 201], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts an ASN.1 encoded certificate to a pyasn1 structure and returns the result.", "Arguments": ":param blob: The ASN.1 encoded certificate to be converted to a pyasn1 structure.\n:return: The pyasn1 structure of the ASN.1 encoded certificate."}, "tests": ["tests/test_security_layer.py::Testblob_to_pyasn1::test_generic"], "indent": 4}
{"namespace": "aioxmpp.security_layer.extract_pk_blob_from_pyasn1", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/security_layer.py", "signature_position": [204, 204], "body_position": [210, 216], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function extracts an ASN.1 encoded public key blob from the given pyasn1 structure, which must represent a certificate.", "Arguments": ":param pyasn1_struct: The pyasn1 structure that represents a certificate.\n:return: The ASN.1 encoded public key blob extracted from the given pyasn1 structure."}, "tests": ["tests/test_security_layer.py::Testextract_pk_blob_from_pyasn1::test_generic"], "indent": 4}
{"namespace": "aioxmpp.callbacks.AdHocSignal.ASYNC_WITH_LOOP", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/callbacks.py", "signature_position": [389, 389], "body_position": [390, 400], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "The function creates a wrapper for the given function to be executed asynchronously with the given event loop. It first checks if the loop is provided, if not, it gets the default event loop. Then, it creates a wrapper for the given function to be executed asynchronously with the provided loop.", "Arguments": ":param cls: Class. The class instance.\n:param loop: Event loop. The event loop to be used for asynchronous execution. Defaults to None.\n:return: Wrapper function. The wrapper function for the given function to be executed asynchronously with the provided loop."}, "tests": ["tests/test_callbacks.py::TestAdHocSignal::test_connect_async", "tests/test_callbacks.py::TestAdHocSignal::test_ASYNC_WITH_LOOP_rejects_non_callable"], "indent": 8}
{"namespace": "aioxmpp.callbacks.AdHocSignal.SPAWN_WITH_LOOP", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/callbacks.py", "signature_position": [431, 431], "body_position": [432, 450], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Create a spawn function that can be used to spawn a coroutine function. It ensures that the function is a coroutine and then adds a done callback to the task to log the spawned task.", "Arguments": ":param cls: AdHocSignal. The class instance.\n:param loop: The event loop to be used. If not specified, the default event loop is used.\n:return: The spawn function."}, "tests": ["tests/test_callbacks.py::TestAdHocSignal::test_connect_spawn", "tests/test_callbacks.py::TestAdHocSignal::test_SPAWN_rejects_non_coroutine", "tests/test_callbacks.py::TestAdHocSignal::test_connect_spawn_emits_always"], "indent": 8}
{"namespace": "aioxmpp.callbacks.first_signal", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/callbacks.py", "signature_position": [850, 850], "body_position": [892, 895], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function connects to multiple signals and waits for the first signal to emit. It returns an awaitable for the first signal to emit. The awaitable returns the first argument passed to the signal. If the first argument is an exception, the exception is re-raised from the awaitable.", "Arguments": ":param signals: Signals to connect to. It can be of type AdHocSignal.\n:return: An awaitable for the first signal to emit."}, "tests": ["tests/test_callbacks.py::Testfirst_signal::test_works_for_common_use_case_with_success", "tests/test_callbacks.py::Testfirst_signal::test_works_for_common_use_case_with_exception", "tests/test_callbacks.py::Testfirst_signal::test_connects_future_to_both_and_returns_future"], "indent": 4}
{"namespace": "aioxmpp.tasks.TaskPool.spawn", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/tasks.py", "signature_position": [165, 165], "body_position": [198, 200], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function starts a new coroutine and adds it to the pool atomically. It checks if the groups have free slots available for the coroutine to be spawned and raises a RuntimeError if the limit on any of the groups or the total limit is exhausted.", "Arguments": ":param self: TaskPool. An instance of the TaskPool class.\n:param __groups: Set of group keys. The groups the coroutine belongs to.\n:param __coro_fun: Coroutine function to run.\n:param args: Positional arguments to pass to `coro_fun`.\n:param kwargs: Keyword arguments to pass to `coro_fun`.\n:raise RuntimeError: If the limit on any of the groups or the total limit is exhausted.\n:return: asyncio.Task. The task in which the coroutine runs."}, "tests": ["tests/test_tasks.py::TestTaskPool::test_spawn_accounting", "tests/test_tasks.py::TestTaskPool::test_spawn_starts_coroutine_and_returns_task"], "indent": 8}
{"namespace": "aioxmpp.protocol.send_and_wait_for", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/protocol.py", "signature_position": [872, 874], "body_position": [875, 920], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function sends a message and waits for a response. It sends a message to the xmlstream and waits for a response. If the response is not received within the specified timeout, a TimeoutError is raised.", "Arguments": ":param xmlstream: The xmlstream to send the message to and wait for a response.\n:param send: The message to be sent.\n:param wait_for: The response to wait for.\n:param timeout: The time to wait for the response. If None, it waits indefinitely.\n:param cb: The callback function to be called when a response is received.\n:return: The response received from the xmlstream."}, "tests": ["tests/test_protocol.py::Testsend_and_wait_for::test_handles_setup_issues_properly", "tests/test_protocol.py::Testsend_and_wait_for::test_handles_send_issues_properly", "tests/test_protocol.py::Testsend_and_wait_for::test_receive_handler_invokes_cb"], "indent": 4}
{"namespace": "aioxmpp.testutils.run_coroutine_with_peer", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/testutils.py", "signature_position": [91, 95], "body_position": [96, 135], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Run the given coroutine and its peer coroutine concurrently with a timeout. It waits for both coroutines to complete and raises a timeout error if the timeout is reached.", "Arguments": ":param coroutine: Coroutine. The coroutine to be run.\n:param peer_coroutine: Coroutine. The peer coroutine to be run concurrently.\n:param timeout: Float. The maximum time to wait for the coroutines to complete. Defaults to 1.0.\n:param loop: Event loop. The event loop to run the coroutines. Defaults to None.\n:return: The result of the local future."}, "tests": ["tests/test_highlevel.py::TestProtocol::test_malformed_sm_failed_does_not_cause_loop", "tests/test_highlevel.py::TestProtocol::test_sm_bootstrap_race", "tests/test_highlevel.py::TestProtocol::test_sm_works_correctly_with_invalid_payload", "tests/test_highlevel.py::TestProtocol::test_sm_works_correctly_with_entirely_broken_stanza", "tests/test_testutils.py::TestTransportMock::test_starttls"], "indent": 4}
{"namespace": "aioxmpp.testutils.make_listener", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/testutils.py", "signature_position": [138, 138], "body_position": [145, 159], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a unittest.mock.Mock object which has children connected to each aioxmpp.callbacks.Signal of the given instance. The children are named exactly like the signals.", "Arguments": ":param instance: The instance for which the listener is to be created.\n:return: unittest.mock.Mock. The created mock object with children connected to each signal of the instance."}, "tests": ["tests/test_testutils.py::Testmake_listener::test_connects_to_signals", "tests/test_testutils.py::Testmake_listener::test_connects_to_signals_of_base_class", "tests/test_testutils.py::Testmake_listener::test_handles_overridden_attributes", "tests/muc/test_service.py::TestService::test_on_failure_is_emitted_on_join_error", "tests/muc/test_service.py::TestService::test_on_failure_is_emitted_on_stream_destruction_without_autorejoin"], "indent": 4}
{"namespace": "aioxmpp.vcard.service.VCardService.set_vcard", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/vcard/service.py", "signature_position": [69, 69], "body_position": [86, 91], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function stores the vCard `vcard` for the connected entity. It creates an IQ instance with the vCard payload and sends it to the client.", "Arguments": ":param self: VCardService. An instance of the VCardService class.\n:param vcard: The vCard to store.\n:param jid: The JID to which the vCard is to be stored. Defaults to None.\n:return: No return value."}, "tests": ["tests/vcard/test_service.py::TestService::test_set_vcard_for_foreign_jid", "tests/vcard/test_service.py::TestService::test_set_vcard"], "indent": 8}
{"namespace": "aioxmpp.rsm.xso.ResultSetMetadata.limit", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/rsm/xso.py", "signature_position": [217, 217], "body_position": [232, 237], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Limit the result set to a given number of items. It creates a new request set up to request at most `max_` items.", "Arguments": ":param self: ResultSetMetadata. An instance of the ResultSetMetadata class.\n:param max_: Maximum number of items to return.\n:return: A new request set up to request at most `max_` items."}, "tests": ["tests/rsm/test_xso.py::TestResultSetMetadata::test_limit_cls", "tests/rsm/test_xso.py::TestResultSetMetadata::test_limit_before_after_obj", "tests/rsm/test_xso.py::TestResultSetMetadata::test_limit_index_obj"], "indent": 8}
{"namespace": "aioxmpp.muc.service.Room.features", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/muc/service.py", "signature_position": [1019, 1019], "body_position": [1026, 1036], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a set of features supported by the MUC (Multi-User Chat) instance. The features may vary depending on the features exported by the MUC service.", "Arguments": ":param self: Room. An instance of the Room class.\n:return: Set. The set of features supported by the MUC instance."}, "tests": ["tests/muc/test_service.py::TestRoom::test_features", "tests/muc/test_service.py::TestRoom::test_expose_invite_features"], "indent": 8}
{"namespace": "aioxmpp.xso.query.EvaluationContext.eval_bool", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/xso/query.py", "signature_position": [168, 168], "body_position": [174, 184], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Evaluate the expression `expr` and return the truthness of its result. A result of an expression is said to be true if it contains at least one value. It has the same semantics as :func:`bool` on sequences.", "Arguments": ":param self: EvaluationContext. An instance of the EvaluationContext class.\n:param expr: The expression to be evaluated.\n:return: Boolean. The truthness of the evaluated expression."}, "tests": ["tests/xso/test_query.py::TestEvaluationContext::test_eval_bool_with_false_sequence", "tests/xso/test_query.py::TestEvaluationContext::test_eval_bool_with_true_generator", "tests/xso/test_query.py::TestEvaluationContext::test_eval_bool_with_false_generator", "tests/xso/test_query.py::TestEvaluationContext::test_eval_bool_with_true_sequence"], "indent": 8}
{"namespace": "aioxmpp.xso.query._BoolOpMixin.eval", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/xso/query.py", "signature_position": [341, 341], "body_position": [342, 343], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function evaluates the given expression context and yields True if the leaf is evaluated to True.", "Arguments": ":param self: _BoolOpMixin. An instance of the _BoolOpMixin class.\n:param ec: The expression context to be evaluated.\n:return: True if the leaf is evaluated to True."}, "tests": ["tests/xso/test_query.py::TestCmpOp::test_eval_returns_list_with_single_True_on_true", "tests/xso/test_query.py::TestNotOp::test_eval_returns_empty_list_on_false", "tests/xso/test_query.py::TestCmpOp::test_eval_returns_empty_list_on_false", "tests/xso/test_query.py::TestNotOp::test_eval_returns_list_with_single_True_on_true"], "indent": 8}
{"namespace": "aioxmpp.xso.model.drop_handler", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/xso/model.py", "signature_position": [2681, 2681], "body_position": [2682, 2688], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a generator that drops events until the depth is zero. It yields events until the depth is zero.", "Arguments": ":param ev_args: The event arguments.\n:return: No return values."}, "tests": ["tests/xso/test_model.py::Testdrop_handler::test_drop_handler"], "indent": 4}
{"namespace": "aioxmpp.xso.model.guard", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/xso/model.py", "signature_position": [2702, 2702], "body_position": [2703, 2722], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a generator that guards the destination generator. It sends events to the destination generator and returns the value of the destination generator when it is done. It also handles the exception and ensures that the depth is zero when the function is done.", "Arguments": ":param dest: The destination generator to be guarded.\n:param ev_args: The events to be sent to the destination generator.\n:return: The value of the destination generator when it is done."}, "tests": ["tests/xso/test_model.py::Testguard::test_return_only_after_end_even_on_exception_and_reraise", "tests/xso/test_model.py::Testguard::test_forward_to_argument_and_return_after_end", "tests/xso/test_model.py::Testguard::test_handles_increasing_nesting_while_dropping", "tests/xso/test_model.py::Testguard::test_eat_end_after_exception_on_start", "tests/xso/test_model.py::Testguard::test_handles_increasing_nesting_while_after_error_during_start"], "indent": 4}
{"namespace": "aioxmpp.xso.model.capture_events", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/xso/model.py", "signature_position": [2736, 2736], "body_position": [2755, 2798], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Capture all events sent to `receiver` in the sequence `dest`. This is a generator, and it is best used with ``yield from``. The observable effect of using this generator with ``yield from`` is identical to the effect of using `receiver` with ``yield from`` directly (including the return value), but in addition, the values which are *sent* to the receiver are captured in `dest`.\nIf `receiver` raises an exception or the generator is closed prematurely using its :meth:`close`, `dest` is cleared.\nThis is used to implement :class:`CapturingXSO`. See the documentation there for use cases.", "Arguments": ":param receiver: The receiver to capture events from.\n:param dest: The sequence to capture the events in.\n:return: return the value of the yield from generator."}, "tests": ["tests/xso/test_model.py::Testcapture_events::test_capture_initiation", "tests/xso/test_model.py::Testcapture_events::test_capture_and_forward_events", "tests/xso/test_model.py::Testcapture_events::test_clear_destination_on_exception", "tests/xso/test_model.py::Testcapture_events::test_clear_destination_on_exception_during_startup", "tests/xso/test_model.py::Testcapture_events::test_clear_destination_on_close_while_active"], "indent": 4}
{"namespace": "aioxmpp.xso.model.events_to_sax", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/xso/model.py", "signature_position": [2801, 2801], "body_position": [2806, 2817], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts an iterable `events` of XSO events to SAX events by calling the matching SAX methods on `dest`. It iterates through the events and calls the corresponding SAX methods on `dest` based on the event type.", "Arguments": ":param events: Iterable. An iterable of XSO events.\n:param dest: Object. The destination object on which the matching SAX methods will be called.\n:return: No return values."}, "tests": ["tests/xso/test_model.py::Testevents_to_sax::test_start", "tests/xso/test_model.py::Testevents_to_sax::test_start_and_end", "tests/xso/test_model.py::Testevents_to_sax::test_text", "tests/xso/test_model.py::Testevents_to_sax::test_nested_stuff"], "indent": 4}
{"namespace": "aioxmpp.adhoc.service.AdHocClient.get_command_info", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/adhoc/service.py", "signature_position": [93, 93], "body_position": [115, 120], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function obtains information about a command from a peer. It sends a service discovery query to the service discovery node of the command and returns the service discovery information about the command.", "Arguments": ":param self: AdHocClient. An instance of the AdHocClient class.\n:param peer_jid: JID. The JID of the peer to query.\n:param command_name: String. The node name of the command.\n:return: InfoQuery. Service discovery information about the command."}, "tests": ["tests/adhoc/test_service.py::TestAdHocClient::test_get_command_info_uses_disco"], "indent": 8}
{"namespace": "aioxmpp.entitycaps.caps115.build_identities_string", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/entitycaps/caps115.py", "signature_position": [34, 34], "body_position": [35, 50], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function builds a string of identities based on the given list of identities. It first processes each identity in the list and encodes it into a byte string. Then, it checks for duplicate identities and sorts the identities before joining them into a single byte string.", "Arguments": ":param identities: List of Identity. A list of identity objects.\n:return: Byte string. The concatenated byte string of identities which is seperated by '<'."}, "tests": ["tests/entitycaps/test_caps115.py::Testbuild_identities_string::test_escaping", "tests/entitycaps/test_caps115.py::Testbuild_identities_string::test_identities", "tests/entitycaps/test_caps115.py::Testbuild_identities_string::test_reject_duplicate_identities"], "indent": 4}
{"namespace": "aioxmpp.entitycaps.caps115.build_features_string", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/entitycaps/caps115.py", "signature_position": [53, 53], "body_position": [54, 61], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function builds a string of features. It first escapes each feature and encodes it in utf-8. Then, it checks for duplicate features and raises a ValueError if found. Finally, it sorts the features and joins them with \"<\".", "Arguments": ":param features: List. A list of features to be processed.\n:return: Bytes. The built features string which is seperated by '<'."}, "tests": ["tests/entitycaps/test_caps115.py::Testbuild_features_string::test_escaping", "tests/entitycaps/test_caps115.py::Testbuild_features_string::test_reject_duplicate_features", "tests/entitycaps/test_caps115.py::Testbuild_features_string::test_features"], "indent": 4}
{"namespace": "aioxmpp.entitycaps.caps115.build_forms_string", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/entitycaps/caps115.py", "signature_position": [64, 64], "body_position": [65, 110], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function builds a string of forms based on the input forms. It first processes the input forms and builds a list of forms. Then, it sorts the forms and builds a string based on the sorted forms.", "Arguments": ":param forms: List. A list of forms to be processed.\n:return: Bytes. The built string of forms, and the different parts are seperated by '<'."}, "tests": ["tests/entitycaps/test_caps115.py::Testbuild_forms_string::test_value_and_var_escaping", "tests/entitycaps/test_caps115.py::Testbuild_forms_string::test_reject_form_with_multiple_different_types", "tests/entitycaps/test_caps115.py::Testbuild_forms_string::test_reject_multiple_identical_form_types", "tests/entitycaps/test_caps115.py::Testbuild_forms_string::test_ignore_form_without_type", "tests/entitycaps/test_caps115.py::Testbuild_forms_string::test_xep_form"], "indent": 4}
{"namespace": "aioxmpp.entitycaps.caps115.Key.path", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/entitycaps/caps115.py", "signature_position": [133, 133], "body_position": [134, 136], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Return the path of the key. It first quotes the node and then returns the path of the key based on the quoted node, algorithm, and the directory \"hashes\".", "Arguments": ":param self: Key. An instance of the Key class.\n:return: Path. The path of the key, which is a pathlib.Path object."}, "tests": ["tests/entitycaps/test_caps115.py::TestKey::test_path_uses_urlescape", "tests/entitycaps/test_caps115.py::TestKey::test_path"], "indent": 8}
{"namespace": "aioxmpp.entitycaps.caps390._process_features", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/entitycaps/caps390.py", "signature_position": [33, 33], "body_position": [45, 50], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function generates the `Features String` from an iterable of features. It encodes the features into bytes and concatenates them to form the `Features String`.", "Arguments": ":param features: Iterable of str. The features to generate the features string from.\n:return: bytes. The `Features String` as bytes."}, "tests": ["tests/entitycaps/test_caps390.py::Test_process_features::test_on_large_testcase", "tests/entitycaps/test_caps390.py::Test_process_features::test_on_small_testcase"], "indent": 4}
{"namespace": "aioxmpp.entitycaps.caps390._process_identities", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/entitycaps/caps390.py", "signature_position": [62, 62], "body_position": [75, 80], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function generates the `Identities String` from an iterable of identities. It processes each identity in the iterable and generates the `Identities String` as specified in :xep:`390`.", "Arguments": ":param identities: Iterable. The identities to generate the features string from. It is an iterable of Identity objects.\n:return: Bytes. The `Identities String` generated from the given `identities`."}, "tests": ["tests/entitycaps/test_caps390.py::Test_process_identities::test_on_large_testcase", "tests/entitycaps/test_caps390.py::Test_process_identities::test_on_small_testcase"], "indent": 4}
{"namespace": "aioxmpp.entitycaps.caps390._process_extensions", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/entitycaps/caps390.py", "signature_position": [103, 103], "body_position": [116, 121], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Generate the `Extensions String` from an iterable of data forms. It generates the `Extensions String` from the given `exts` as specified in :xep:`390`.", "Arguments": ":param exts: The data forms to generate the extensions string from.\n:type exts: :class:`~collections.abc.Iterable` of :class:`~.forms.xso.Data`.\n:return: The `Extensions String` as `bytes`."}, "tests": ["tests/entitycaps/test_caps390.py::Test_process_extensions::test_on_small_testcase", "tests/entitycaps/test_caps390.py::Test_process_extensions::test_on_large_testcase"], "indent": 4}
{"namespace": "aioxmpp.entitycaps.caps390._calculate_hash", "type": "function", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/entitycaps/caps390.py", "signature_position": [132, 132], "body_position": [133, 135], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Calculate the hash of the given input using the specified algorithm.", "Arguments": ":param algo: String. The algorithm to be used for hashing.\n:param hash_input: The input data to be hashed.\n:return: The hash of the input data using the specified algorithm."}, "tests": ["tests/entitycaps/test_caps390.py::TestKey::test_verify_large_input_precalculated", "tests/entitycaps/test_caps390.py::Test_calculate_hash::test_uses_and_hash_from_algo", "tests/entitycaps/test_caps390.py::TestKey::test_verify_small_input", "tests/entitycaps/test_caps390.py::TestKey::test_verify_small_input_precalculated", "tests/entitycaps/test_caps390.py::TestKey::test_verify_large_input"], "indent": 4}
{"namespace": "aioxmpp.entitycaps.caps390.Key.node", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/entitycaps/caps390.py", "signature_position": [143, 143], "body_position": [144, 147], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns a node string based on the algorithm and digest of the Key instance.", "Arguments": ":param self: Key. An instance of the Key class.\n:return: String. The node string based on the algorithm and digest of the Key instance."}, "tests": ["tests/entitycaps/test_caps390.py::TestKey::test_node"], "indent": 8}
{"namespace": "aioxmpp.entitycaps.caps390.Key.path", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/entitycaps/caps390.py", "signature_position": [150, 150], "body_position": [151, 158], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function generates a path based on the given Key instance. It encodes the digest of the key and constructs a path using the encoded digest, algorithm, and file extension.", "Arguments": ":param self: Key. An instance of the Key class.\n:return: Path. The generated path based on the key instance."}, "tests": ["tests/entitycaps/test_caps390.py::TestKey::test_path", "tests/entitycaps/test_caps390.py::TestKey::test_path_urlencodes_algo"], "indent": 8}
{"namespace": "aioxmpp.entitycaps.caps390.Implementation.extract_keys", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/entitycaps/caps390.py", "signature_position": [172, 172], "body_position": [173, 180], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Extracts the keys from the presence instance if the xep0390_caps is not None. It returns the keys if the presence object contain information about the entity's capabilities, else it returns an empty generator.", "Arguments": ":param self: Implementation. An instance of the Implementation class.\n:param presence: Presence. The presence instance from which the keys are to be extracted.\n:return: The extracted keys as Tuple."}, "tests": ["tests/entitycaps/test_caps390.py::TestImplementation::test_extract_keys_returns_empty_if_caps_is_None", "tests/entitycaps/test_caps390.py::TestImplementation::test_extract_keys_creates_Key_objects_from_digests_and_checks_for_support"], "indent": 8}
{"namespace": "aioxmpp.roster.service.RosterClient.approve", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/roster/service.py", "signature_position": [693, 693], "body_position": [712, 715], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Approve a subscription request from the peer_jid. It sends a \"subscribed\" presence to the peer. If the peer has previously asked for a subscription, this will seal the deal and create the subscription. If the peer has not requested a subscription yet, it is marked as pre-approved by the server. A future subscription request by the peer will then be confirmed by the server automatically.", "Arguments": ":param self: RosterClient. An instance of the RosterClient class.\n:param peer_jid: The peer to (pre-)approve.\n:return: No return value."}, "tests": ["tests/roster/test_service.py::TestService::test_approve_sends_subscribed_presence"], "indent": 8}
{"namespace": "aioxmpp.roster.service.RosterClient.subscribe", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/roster/service.py", "signature_position": [717, 717], "body_position": [726, 729], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Request presence subscription with the given `peer_jid`. This is deliberately not a coroutine; we dont know whether the peer is online (usually) and they may defer the confirmation very long, if they confirm at all. Use :meth:`on_subscribed` to get notified when a peer accepted a subscription request.", "Arguments": ":param self: RosterClient. An instance of the RosterClient class.\n:param peer_jid: The peer JID to subscribe to.\n:return: No return values."}, "tests": ["tests/roster/test_service.py::TestService::test_subscribe_sends_subscribe_presence"], "indent": 8}
{"namespace": "aioxmpp.roster.service.RosterClient.unsubscribe", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/roster/service.py", "signature_position": [731, 731], "body_position": [735, 738], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Unsubscribe from the presence of the given `peer_jid`.", "Arguments": ":param self: RosterClient. An instance of the RosterClient class.\n:param peer_jid: The JID of the peer to unsubscribe from.\n:return: No return values."}, "tests": ["tests/roster/test_service.py::TestService::test_unsubscribe_sends_unsubscribe_presence"], "indent": 8}
{"namespace": "aioxmpp.forms.fields.BoundSingleValueField.value", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/forms/fields.py", "signature_position": [333, 333], "body_position": [334, 337], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Delete the value of the BoundSingleValueField instance if it exists.", "Arguments": ":param self: BoundSingleValueField. An instance of the BoundSingleValueField class.\n:return: No return values."}, "tests": ["tests/forms/test_fields.py::TestBoundSingleValueField::test_deleting_reverts_to_initial_behaviour"], "indent": 8}
{"namespace": "aioxmpp.forms.fields.BoundMultiValueField.value", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/forms/fields.py", "signature_position": [409, 409], "body_position": [410, 413], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is used to delete the value of the BoundMultiValueField instance.", "Arguments": ":param self: BoundMultiValueField. An instance of the BoundMultiValueField class.\n:return: No return values."}, "tests": ["tests/forms/test_fields.py::TestBoundMultiValueField::test_deleting_reverts_to_initial_behaviour"], "indent": 8}
{"namespace": "aioxmpp.forms.fields.BoundOptionsField.options", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/forms/fields.py", "signature_position": [510, 510], "body_position": [511, 514], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function removes the options attribute from the BoundOptionsField instance if it exists.", "Arguments": ":param self: BoundOptionsField. An instance of the BoundOptionsField class.\n:return: No return values."}, "tests": ["tests/forms/test_fields.py::TestBoundOptionsField::test_delete_resets_options_to_field"], "indent": 8}
{"namespace": "aioxmpp.forms.fields.BoundSelectField.value", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/forms/fields.py", "signature_position": [577, 577], "body_position": [578, 581], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function deletes the value of the BoundSelectField instance if it exists.", "Arguments": ":param self: BoundSelectField. An instance of the BoundSelectField class.\n:return: No return values."}, "tests": ["tests/forms/test_fields.py::TestBoundSelectField::test_deleting_reverts_to_initial_behaviour"], "indent": 8}
{"namespace": "aioxmpp.forms.fields.BoundMultiSelectField.value", "type": "method", "project_path": "Communications/aioxmpp", "completion_path": "Communications/aioxmpp/aioxmpp/forms/fields.py", "signature_position": [655, 655], "body_position": [656, 659], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function deletes the value of the BoundMultiSelectField instance if it exists.", "Arguments": ":param self: BoundMultiSelectField. An instance of the BoundMultiSelectField class.\n:return: No return values."}, "tests": ["tests/forms/test_fields.py::TestBoundMultiSelectField::test_deleting_reverts_to_initial_behaviour"], "indent": 8}
{"namespace": "cupy.random._generator.reset_states", "type": "function", "project_path": "Scientific-Engineering/cupy", "completion_path": "Scientific-Engineering/cupy/cupy/random/_generator.py", "signature_position": [1264, 1264], "body_position": [1265, 1266], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Reset the global variable _random_states to an empty dictionary.", "Arguments": ":param: No input parameters.\n:return: No return values."}, "tests": ["tests/cupy_tests/random_tests/test_generator.py::TestResetStates::test_reset_states"], "indent": 4}
{"namespace": "cupy.random._generator._check_and_get_dtype", "type": "function", "project_path": "Scientific-Engineering/cupy", "completion_path": "Scientific-Engineering/cupy/cupy/random/_generator.py", "signature_position": [1305, 1305], "body_position": [1306, 1309], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if the input data type is supported by cupy.random and returns the data type if it is supported. If it is not supported by cupy.random, raise an error.", "Arguments": ":param dtype: data type. The input data type to be checked.\n:return: numpy.dtype. The checked and converted data type."}, "tests": ["tests/cupy_tests/random_tests/test_generator.py::TestCheckAndGetDtype::test_int_type", "tests/cupy_tests/random_tests/test_generator.py::TestCheckAndGetDtype::test_float32_64_type", "tests/cupy_tests/random_tests/test_generator.py::TestCheckAndGetDtype::test_float16"], "indent": 4}
{"namespace": "cupy_builder._command.filter_files_by_extension", "type": "function", "project_path": "Scientific-Engineering/cupy", "completion_path": "Scientific-Engineering/cupy/install/cupy_builder/_command.py", "signature_position": [17, 20], "body_position": [21, 28], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Filter the files in the given list based on the file extension. It separates the files with the given extension from the rest of the files.", "Arguments": ":param sources: List of strings. The list of file paths to be filtered.\n:param extension: String. The file extension to be used for filtering.\n:return: Two lists of strings. The first list contains the files with the given extension, and the second list contains the rest of the files."}, "tests": ["tests/install_tests/test_cupy_builder/test_command.py::test_filter_files_by_extension"], "indent": 4}
{"namespace": "datasets.table._in_memory_arrow_table_from_file", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/table.py", "signature_position": [35, 35], "body_position": [36, 39], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function reads an Arrow file from the given filename and returns an in-memory Arrow table.", "Arguments": ":param filename: String. The name of the file to read the Arrow table from.\n:return: pa.Table. The in-memory Arrow table read from the file."}, "tests": ["tests/test_table.py::test_in_memory_arrow_table_from_file"], "indent": 4}
{"namespace": "datasets.table._in_memory_arrow_table_from_buffer", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/table.py", "signature_position": [42, 42], "body_position": [43, 46], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Create an in-memory Arrow table from the given buffer. It first creates a BufferReader instance from the buffer and then opens a stream from it. Finally, it reads all the data from the stream and returns it as a table.", "Arguments": ":param buffer: pa.Buffer. The buffer from which the in-memory Arrow table is to be created.\n:return: pa.Table. The in-memory Arrow table created from the buffer."}, "tests": ["tests/test_table.py::test_in_memory_arrow_table_from_buffer"], "indent": 4}
{"namespace": "datasets.table._interpolation_search", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/table.py", "signature_position": [90, 90], "body_position": [104, 113], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the position i of a sorted array so that arr[i] <= x < arr[i+1]. Raise `IndexError` if the array is empty or if the query is outside the array values.", "Arguments": ":param arr: List[int]. A non-empty sorted list of integers.\n:param x: int. The query.\n:return: int. The position i so that arr[i] <= x < arr[i+1]."}, "tests": ["tests/test_table.py::test_interpolation_search"], "indent": 4}
{"namespace": "datasets.data_files._is_inside_unrequested_special_dir", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/data_files.py", "signature_position": [135, 135], "body_position": [163, 165], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if a path is inside a special directory that is ignored by default. It also checks if the path is explicitly requested inside such a directory.", "Arguments": ":param matched_rel_path: str. The path to be checked.\n:param pattern: str. The pattern to be matched.\n:return: bool. True if the path is inside an unrequested special directory, False otherwise."}, "tests": ["tests/test_data_files.py::test_is_inside_unrequested_special_dir", "tests/test_data_files.py::test_is_unrequested_hidden_file_or_is_inside_unrequested_hidden_dir"], "indent": 4}
{"namespace": "datasets.data_files._is_unrequested_hidden_file_or_is_inside_unrequested_hidden_dir", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/data_files.py", "signature_position": [168, 168], "body_position": [221, 227], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Check if a path matches a pattern and if it's a hidden file or inside a hidden directory that is ignored by default.", "Arguments": ":param matched_rel_path: str. The path to be checked.\n:param pattern: str. The pattern to be matched.\n:return: bool. True if the path is a hidden file or inside a hidden directory that is ignored by default, False otherwise."}, "tests": ["tests/test_data_files.py::test_is_unrequested_hidden_file_or_is_inside_unrequested_hidden_dir"], "indent": 4}
{"namespace": "datasets.iterable_dataset._batch_to_examples", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/iterable_dataset.py", "signature_position": [78, 78], "body_position": [80, 82], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert a batch (dict of examples) to a list of examples. It iterates through the batch and creates a list of examples.", "Arguments": ":param batch: Dict. A dictionary of examples.\n:return: List of Dict. A list of examples."}, "tests": ["tests/test_iterable_dataset.py::test_mapped_examples_iterable", "tests/test_iterable_dataset.py::test_mapped_examples_iterable_drop_last_batch", "tests/test_iterable_dataset.py::test_mapped_examples_iterable_remove_columns", "tests/test_iterable_dataset.py::test_mapped_examples_iterable_with_indices", "tests/test_iterable_dataset.py::test_mapped_examples_iterable_fn_kwargs"], "indent": 4}
{"namespace": "datasets.iterable_dataset._examples_to_batch", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/iterable_dataset.py", "signature_position": [69, 71], "body_position": [72, 75], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function converts a list of dictionaries into a dictionary of lists. It first creates a set of columns based on the input examples. Then, it creates a list of lists where each list contains the values of a specific column from the input examples. Finally, it zips the columns and arrays into a dictionary.", "Arguments": ":param examples: List of dictionaries. The input list of dictionaries.\n:return: Dictionary of lists. The converted dictionary of lists."}, "tests": ["tests/test_iterable_dataset.py::test_mapped_examples_iterable", "tests/test_iterable_dataset.py::test_mapped_examples_iterable_drop_last_batch", "tests/test_iterable_dataset.py::test_mapped_examples_iterable_remove_columns", "tests/test_iterable_dataset.py::test_mapped_examples_iterable_with_indices", "tests/test_iterable_dataset.py::test_mapped_examples_iterable_fn_kwargs"], "indent": 4}
{"namespace": "datasets.iterable_dataset.RandomlyCyclingMultiSourcesExamplesIterable._iter_random_indices", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/iterable_dataset.py", "signature_position": [601, 606], "body_position": [608, 613], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns an infinite iterator that randomly samples the index of the source to pick examples from. It uses the numpy random number generator to achieve this.", "Arguments": ":param rng: np.random.Generator. The random number generator to be used.\n:param num_sources: int. The number of sources to pick examples from.\n:param random_batch_size: int. The size of the random batch. Defaults to 1000.\n:param p: List of float. The probabilities associated with each entry in the num_sources. Defaults to None.\n:return: Iterator of int. An infinite iterator that randomly samples the index of the source to pick examples from."}, "tests": ["tests/test_iterable_dataset.py::test_randomly_cycling_multi_sources_examples_iterable", "tests/test_iterable_dataset.py::test_interleave_datasets"], "indent": 8}
{"namespace": "datasets.iterable_dataset.BufferShuffledExamplesIterable._iter_random_indices", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/iterable_dataset.py", "signature_position": [972, 972], "body_position": [973, 974], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function is a generator that yields random indices from a buffer of shuffled examples. It uses a random number generator to generate random indices and yields them in batches.", "Arguments": ":param rng: np.random.Generator. A random number generator.\n:param buffer_size: int. The size of the buffer.\n:param random_batch_size: int. The size of the random batch to be generated. Defaults to 1000.\n:return: Iterator[int]. An iterator that yields random indices."}, "tests": ["tests/test_iterable_dataset.py::test_iterable_dataset_shuffle", "tests/test_iterable_dataset.py::test_buffer_shuffled_examples_iterable"], "indent": 8}
{"namespace": "datasets.iterable_dataset.IterableDataset.remove_columns", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/iterable_dataset.py", "signature_position": [1990, 1990], "body_position": [2015, 2028], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Remove one or several column(s) in the dataset and the features associated with them. The removal is done on-the-fly on the examples when iterating over the dataset.", "Arguments": ":param self: IterableDataset. An instance of the IterableDataset class.\n:param column_names (`Union[str, List[str]]`): Name of the column(s) to remove.\n:return: `IterableDataset`: A copy of the dataset object without the columns to remove."}, "tests": ["tests/test_iterable_dataset.py::test_concatenate_datasets_axis_1_resolves_features", "tests/test_iterable_dataset.py::test_concatenate_datasets_axis_1", "tests/test_iterable_dataset.py::test_concatenate_datasets_axis_1_with_different_lengths"], "indent": 8}
{"namespace": "datasets.dataset_dict.DatasetDict.with_format", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/dataset_dict.py", "signature_position": [643, 649], "body_position": [691, 693], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Set the `__getitem__` return format (type and columns) for the dataset. The data formatting is applied on-the-fly. The format `type` (for example \"numpy\") is used to format batches when using `__getitem__`. The format is set for every dataset in the dataset dictionary.", "Arguments": ":param type: Optional string. Output type selected in `[None, 'numpy', 'torch', 'tensorflow', 'pandas', 'arrow', 'jax']`. `None` means `__getitem__` returns python objects (default).\n:param columns: Optional list of strings. Columns to format in the output. `None` means `__getitem__` returns all columns (default).\n:param output_all_columns: Bool. Keep un-formatted columns as well in the output (as python objects). Defaults to `False`.\n:param **format_kwargs: Additional keyword arguments. Keywords arguments passed to the convert function like `np.array`, `torch.tensor` or `tensorflow.ragged.constant`.\n:return: DatasetDict. A new `DatasetDict` object with new `Dataset` objects."}, "tests": ["tests/test_dataset_dict.py::DatasetDictTest::test_with_format"], "indent": 8}
{"namespace": "datasets.dataset_dict.DatasetDict.with_transform", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/dataset_dict.py", "signature_position": [695, 700], "body_position": [745, 747], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Set `__getitem__` return format using this transform. The transform is applied on-the-fly on batches when `__getitem__` is called. The transform is set for every dataset in the dataset dictionary. It returns a new `DatasetDict` object with new `Dataset` objects.", "Arguments": ":param self: DatasetDict. An instance of the DatasetDict class.\n:param transform: Callable. User-defined formatting transform, replaces the format defined by [`~datasets.Dataset.set_format`].\n:param columns: List of string. Columns to format in the output. If specified, then the input batch of the transform only contains those columns.\n:param output_all_columns: Bool. Keep un-formatted columns as well in the output (as python objects). If set to `True`, then the other un-formatted columns are kept with the output of the transform.\n:return: \"DatasetDict\". The new `DatasetDict` object with new `Dataset` objects."}, "tests": ["tests/test_dataset_dict.py::DatasetDictTest::test_with_transform"], "indent": 8}
{"namespace": "datasets.dataset_dict.DatasetDict.align_labels_with_mapping", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/dataset_dict.py", "signature_position": [1549, 1549], "body_position": [1550, 1556], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Align the labels with the given mapping. It aligns the labels of the dataset with the given label2id mapping based on the label_column.", "Arguments": ":param self: DatasetDict. An instance of the DatasetDict class.\n:param label2id: Dict. A dictionary that maps labels to ids.\n:param label_column: String. The name of the label column.\n:return: DatasetDict. The updated DatasetDict instance."}, "tests": ["tests/test_dataset_dict.py::DatasetDictTest::test_align_labels_with_mapping"], "indent": 8}
{"namespace": "datasets.dataset_dict.IterableDatasetDict.map", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/dataset_dict.py", "signature_position": [1785, 1795], "body_position": [1858, 1872], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Apply a function to all the examples in the iterable dataset (individually or in batches) and update them. The function is applied on-the-fly on the examples when iterating over the dataset. The transformation is applied to all the datasets of the dataset dictionary.", "Arguments": ":param self: IterableDatasetDict. An instance of the IterableDatasetDict class.\n:param function: `Callable`, *optional*, defaults to `None`. Function applied on-the-fly on the examples when you iterate on the dataset.\n:param with_indices: `bool`, defaults to `False`. Provide example indices to `function`.\n:param input_columns: `[Union[str, List[str]]`, *optional*, defaults to `None`. The columns to be passed into `function` as positional arguments.\n:param batched: `bool`, defaults to `False`. Provide batch of examples to `function`.\n:param batch_size: `int`, *optional*, defaults to `1000`. Number of examples per batch provided to `function` if `batched=True`.\n:param drop_last_batch: `bool`, defaults to `False`. Whether a last batch smaller than the `batch_size` should be dropped instead of being processed by the function.\n:param remove_columns: `[List[str]]`, *optional*, defaults to `None`. Remove a selection of columns while doing the mapping.\n:param fn_kwargs: `Dict`, *optional*, defaults to `None`. Keyword arguments to be passed to `function`.\n:return: \"IterableDatasetDict\". The updated IterableDatasetDict instance."}, "tests": ["tests/test_dataset_dict.py::DatasetDictTest::test_iterable_map"], "indent": 8}
{"namespace": "datasets.dataset_dict.IterableDatasetDict.filter", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/dataset_dict.py", "signature_position": [1874, 1882], "body_position": [1923, 1935], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Apply a filter function to all the elements so that the dataset only includes examples according to the filter function. The filtering is done on-the-fly when iterating over the dataset. The filtering is applied to all the datasets of the dataset dictionary.", "Arguments": ":param self: IterableDatasetDict. An instance of the IterableDatasetDict class.\n:param function: Optional Callable. A function that filters the examples in the dataset. Defaults to an always True function if not provided.\n:param with_indices: Bool. Provide example indices to the function. Note that in this case the signature of the function should be def function(example, idx): ...\n:param input_columns: Optional Union of string or list of strings. The columns to be passed into the function as positional arguments. If None, a dict mapping to all formatted columns is passed as one argument.\n:param batched: Bool. Provide batch of examples to the function.\n:param batch_size: Optional int. Number of examples per batch provided to the function if batched=True.\n:param fn_kwargs: Optional dict. Keyword arguments to be passed to the function.\n:return: IterableDatasetDict. The filtered dataset dictionary."}, "tests": ["tests/test_dataset_dict.py::DatasetDictTest::test_iterable_filter"], "indent": 8}
{"namespace": "datasets.arrow_dataset.Dataset.num_rows", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/arrow_dataset.py", "signature_position": [1788, 1788], "body_position": [1800, 1802], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the number of rows in the dataset. It first checks if the indices are not None and returns the number of rows from the indices. If the indices are None, it returns the number of rows from the data.", "Arguments": ":param self: Dataset. An instance of the Dataset class.\n:return: int. The number of rows in the dataset."}, "tests": ["tests/test_arrow_reader.py::BaseReaderTest::test_read_files", "tests/test_arrow_reader.py::BaseReaderTest::test_read_sharded", "tests/test_arrow_reader.py::BaseReaderTest::test_read"], "indent": 8}
{"namespace": "datasets.filesystems.extract_path_from_uri", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/filesystems/__init__.py", "signature_position": [33, 33], "body_position": [41, 43], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function preprocesses the `dataset_path` and removes the remote filesystem (e.g. removing `s3://`).", "Arguments": ":param dataset_path: str. The path or remote uri of the dataset directory.\n:return: str. The preprocessed dataset path."}, "tests": ["tests/test_filesystem.py::test_extract_path_from_uri"], "indent": 4}
{"namespace": "datasets.filesystems.is_remote_filesystem", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/filesystems/__init__.py", "signature_position": [46, 46], "body_position": [54, 58], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function checks if the given filesystem has a remote protocol.", "Arguments": ":param fs: fsspec.AbstractFileSystem. An abstract super-class for pythonic file-systems, e.g. `fsspec.filesystem('file')` or [`datasets.filesystems.S3FileSystem`].\n:return: bool. True if the filesystem has a remote protocol, False otherwise."}, "tests": ["tests/test_filesystem.py::test_is_remote_filesystem"], "indent": 4}
{"namespace": "datasets.utils.file_utils.hash_url_to_filename", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/utils/file_utils.py", "signature_position": [125, 125], "body_position": [134, 146], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function takes a URL and an optional etag and converts the URL into a hashed filename in a repeatable way. If the etag is specified, it appends its hash to the URL's hash, delimited by a period. If the URL ends with .h5 (Keras HDF5 weights), it adds '.h5' to the name so that TF 2.0 can identify it as an HDF5 file.", "Arguments": ":param url: String. The URL to be hashed into a filename.\n:param etag: String. The etag to be hashed and appended to the URL's hash. Defaults to None.\n:return: String. The hashed filename."}, "tests": ["tests/test_download_manager.py::test_download_manager_extract"], "indent": 4}
{"namespace": "datasets.utils.hub.hf_hub_url", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/utils/hub.py", "signature_position": [8, 8], "body_position": [9, 12], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the URL of a file in the Hugging Face Hub based on the given repository ID, file path, and revision. It first checks the version of the Hugging Face Hub and encodes the file path if the version is older than 0.11.0.", "Arguments": ":param repo_id: String. The ID of the repository in the Hugging Face Hub.\n:param path: String. The file path in the repository.\n:param revision: String. The revision of the file. Defaults to None.\n:return: String. The URL of the file in the Hugging Face Hub."}, "tests": ["tests/test_hub.py::test_hf_hub_url"], "indent": 4}
{"namespace": "datasets.utils.sharding._number_of_shards_in_gen_kwargs", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/utils/sharding.py", "signature_position": [6, 6], "body_position": [10, 22], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function returns the number of possible shards according to the input gen_kwargs. It checks the length of the lists in the input dictionary and raises an error if the lengths are different.", "Arguments": ":param gen_kwargs: dict. The input dictionary containing the gen_kwargs.\n:return: int. The number of possible shards."}, "tests": ["tests/test_sharding_utils.py::test_number_of_shards_in_gen_kwargs"], "indent": 4}
{"namespace": "datasets.utils.sharding._distribute_shards", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/utils/sharding.py", "signature_position": [25, 25], "body_position": [41, 49], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function distributes the shards among the jobs. It returns the range of shard indices per job. If the number of shards is less than the maximum number of jobs, then each job is given a range of one shard. The order of shard indices is preserved, and all the jobs are given approximately the same number of shards.", "Arguments": ":param num_shards: int. The total number of shards.\n:param max_num_jobs: int. The maximum number of jobs.\n:return: List[range]. The range of shard indices per job."}, "tests": ["tests/test_sharding_utils.py::test_distribute_shards"], "indent": 4}
{"namespace": "datasets.utils.py_utils.temporary_assignment", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/utils/py_utils.py", "signature_position": [229, 229], "body_position": [231, 236], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Temporarily assign the value to the attribute of the object. It first gets the original value of the attribute, then sets the attribute to the new value. After the execution of the block, it sets the attribute back to the original value.", "Arguments": ":param obj: Object. The object to which the attribute belongs.\n:param attr: String. The name of the attribute to be temporarily assigned.\n:param value: Any. The value to be temporarily assigned to the attribute.\n:return: No return values."}, "tests": ["tests/test_py_utils.py::PyUtilsTest::test_temporary_assignment"], "indent": 4}
{"namespace": "datasets.utils.extract.TarExtractor.extract", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/utils/extract.py", "signature_position": [125, 125], "body_position": [126, 129], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function extracts the contents of a tar file to the specified output path. It first creates the output directory if it does not exist, then opens the tar file, extracts all its contents to the output path, and closes the tar file.", "Arguments": ":param input_path: Union[Path, str]. The path to the input tar file.\n:param output_path: Union[Path, str]. The path to the output directory where the contents will be extracted.\n:return: No return value."}, "tests": ["tests/test_extract.py::test_tar_extract_insecure_files"], "indent": 8}
{"namespace": "datasets.utils.extract.Extractor.infer_extractor_format", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/utils/extract.py", "signature_position": [314, 314], "body_position": [315, 319], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "This function infers the format of the extractor based on the given path. It reads the magic number from the file and checks if the extractor is extractable for the given path and magic number.", "Arguments": ":param cls: Extractor. The class itself.\n:param path: Union[Path, str]. The path of the file to infer the extractor format.\n:return: str. The inferred extractor format."}, "tests": ["tests/test_extract.py::test_extractor"], "indent": 8}
{"namespace": "datasets.utils.py_utils.asdict", "type": "function", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/utils/py_utils.py", "signature_position": [189, 189], "body_position": [197, 225], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Convert an object to its dictionary representation recursively. It first checks if the object is a dataclass instance. If it is, it converts the object to a dictionary representation. If not, it checks if the object is a namedtuple, list, tuple, or dictionary and converts it accordingly.", "Arguments": ":param obj: Any. The object to be converted to a dictionary representation.\n:return: Dict. The dictionary representation of the input object."}, "tests": ["tests/test_tasks.py::test_reload_task_from_dict", "tests/test_splits.py::test_split_dict_asdict_has_dataset_name", "tests/test_py_utils.py::test_asdict", "tests/features/test_features.py::FeaturesTest::test_feature_named_self_as_kwarg", "tests/features/test_features.py::FeaturesTest::test_feature_named_type"], "indent": 4}
{"namespace": "datasets.utils.metadata.MetadataConfigs.from_dataset_card_data", "type": "method", "project_path": "Scientific-Engineering/datasets", "completion_path": "Scientific-Engineering/datasets/src/datasets/utils/metadata.py", "signature_position": [173, 173], "body_position": [174, 191], "dependency": {"intra_class": [], "intra_file": [], "cross_file": []}, "requirement": {"Functionality": "Create a MetadataConfigs instance based on the given dataset card data. It first checks if the dataset card data contains the field name. If it does, it processes the metadata configurations and creates a MetadataConfigs instance.", "Arguments": ":param cls: Class. The class itself.\n:param dataset_card_data: DatasetCardData. The dataset card data to be used to create the MetadataConfigs instance.\n:return: MetadataConfigs. The created MetadataConfigs instance."}, "tests": ["tests/test_metadata_util.py::test_metadata_configs_incorrect_yaml", "tests/test_metadata_util.py::test_metadata_configs_dataset_card_data"], "indent": 8}
