{"namespace": "benedict.utils.type_util.is_json_serializable", "completion": "```python\ndef is_json_serializable(val):\n    \"\"\"\n    Check if the input value is JSON serializable. It checks if the input value is of the JSON serializable types.\n    Input-Output Arguments\n    :param val: Any. The input value to be checked for JSON serializability.\n    :return: Bool. True if the input value is JSON serializable, False otherwise.\n    \"\"\"\n    from datetime import datetime\n    from decimal import Decimal\n    import pathlib\n\n    # Check for JSON serializable types\n    if isinstance(val, (str, int, float, bool, type(None))):\n        return True\n    elif isinstance(val, (list, dict, set, tuple)):\n        return all(is_json_serializable(item) for item in val)\n    elif isinstance(val, Decimal):\n        return True\n    elif isinstance(val, datetime):\n        return True\n    elif isinstance(val, pathlib.Path):\n        return True\n    return False\n```"}
{"namespace": "feedparser.urls.convert_to_idn", "completion": "```python\ndef convert_to_idn(url):\n    \"\"\"\n    Convert a URL to IDN notation. It checks if the host can be encoded in ASCII. If not, it converts the host to IDN form.\n    Input-Output Arguments\n    :param url: String. The URL to be converted to IDN notation.\n    :return: String. The URL in IDN notation.\n    \"\"\"\n    # Parse the URL into components\n    parsed_url = urllib.parse.urlparse(url)\n    \n    # Convert the netloc (host) to IDN if necessary\n    if not all(ord(c) < 128 for c in parsed_url.hostname):\n        # Use the idna codec to convert to IDN\n        idn_hostname = parsed_url.hostname.encode('utf-8').decode('idna')\n    else:\n        idn_hostname = parsed_url.hostname\n\n    # Rebuild the URL with the IDN hostname\n    idn_url = urllib.parse.urlunparse((\n        parsed_url.scheme,\n        idn_hostname,\n        parsed_url.path,\n        parsed_url.params,\n        parsed_url.query,\n        parsed_url.fragment\n    ))\n\n    return idn_url\n```"}
{"namespace": "mistune.toc.add_toc_hook", "completion": "```python\ndef add_toc_hook(md, min_level=1, max_level=3, heading_id=None):\n    \"\"\"\n    This function adds a hook to save table of contents (TOC) items into the state.env. It is usually helpful for doc generator.\n    Input-Output Arguments\n    :param md: Markdown instance. The instance of the Markdown class.\n    :param min_level: Integer. The minimum heading level to include in the TOC.\n    :param max_level: Integer. The maximum heading level to include in the TOC.\n    :param heading_id: Function. A function to generate heading_id.\n    :return: No return values.\n    \"\"\"\n    toc_items = []\n\n    def toc_hook(token):\n        level = token['level']\n        if min_level <= level <= max_level:\n            id = heading_id(token, len(toc_items)) if heading_id else token['id']\n            toc_items.append((level, id, token['text']))\n\n    md.inline.register('toc', toc_hook)\n    md.state.env['toc_items'] = toc_items\n```"}
{"namespace": "mistune.plugins.table.table_in_quote", "completion": "```python\ndef table_in_quote(md):\n    \"\"\"\n    This function enables the table plugin in block quotes by inserting rules for table and nptable before the paragraph in the block quote rules.\n    Input-Output Arguments\n    :param md: Markdown. The Markdown instance.\n    :return: No return values.\n    \"\"\"\n    md.block.insert_rule(md.block.block_quote_rules, 'table', before='paragraph')\n    md.block.insert_rule(md.block.block_quote_rules, 'nptable', before='paragraph')\n```"}
{"namespace": "mistune.plugins.table.table_in_list", "completion": "```python\ndef table_in_list(md):\n    \"\"\"\n    This function enables the table plugin in the list. It inserts the table and nptable rules before the paragraph rule in the list.\n    Input-Output Arguments\n    :param md: Markdown. The Markdown instance to enable the table plugin in the list.\n    :return: No return values.\n    \"\"\"\n    md.block.insert_rule(md.block.list_rules, 'table', before='paragraph')\n    md.block.insert_rule(md.block.list_rules, 'nptable', before='paragraph')\n```"}
{"namespace": "xmnlp.utils.parallel_handler", "completion": "```python\ndef parallel_handler(callback: Callable, texts: List[str], n_jobs: int = 2, **kwargs) -> Generator[List[Any], None, None]:\n    \"\"\"\n    This function is a parallel handler that takes a callback function and a list of texts as input. It then processes the texts using the callback function in parallel using a thread pool executor. If the input `texts` is not a list, raise a ValueError(\"You should pass a list of texts\").\n    Input-Output Arguments\n    :param callback: Callable. The callback function to be applied to the list of texts.\n    :param texts: List[str]. The list of texts to be processed.\n    :param n_jobs: int. The pool size of threads. Defaults to 2.\n    :param kwargs: Any additional keyword arguments to be passed to the callback function.\n    :return: Generator[List[Any], None, None]. A generator that yields the results of applying the callback function to the texts in parallel.\n    \"\"\"\n    if not isinstance(texts, list):\n        raise ValueError(\"You should pass a list of texts\")\n\n    with futures.ThreadPoolExecutor(max_workers=n_jobs) as executor:\n        future_to_text = {executor.submit(callback, text, **kwargs): text for text in texts}\n        for future in futures.as_completed(future_to_text):\n            yield future.result()\n```"}
{"namespace": "parsel.utils.shorten", "completion": "```python\ndef shorten(text: str, width: int, suffix: str = \"...\") -> str:\n    \"\"\"\n    Shorten the given text to fit in the given width. If the length of the text is less than or equal to the width, the original text is returned. If the width is greater than the length of the suffix, the text is truncated to fit the width and the suffix is added. If the width is greater than or equal to 0, the suffix is returned based on the width. Otherwise, a ValueError(\"width must be equal or greater than 0\") is raised.\n    Input-Output Arguments\n    :param text: String. The input text to be shortened.\n    :param width: Integer. The width to which the text should be shortened.\n    :param suffix: String. The suffix to be added at the end of the shortened text. Defaults to \"...\".\n    :return: String. The shortened text.\n    \"\"\"\n    if width < 0:\n        raise ValueError(\"width must be equal or greater than 0\")\n    \n    if len(text) <= width:\n        return text\n    \n    if width > len(suffix):\n        return text[:width - len(suffix)] + suffix\n    \n    return suffix\n```"}
{"namespace": "parsel.xpathfuncs.set_xpathfunc", "completion": "```python\ndef set_xpathfunc(fname: str, func: Optional[Callable]) -> None:  # type: ignore[type-arg]\n    \"\"\"\n    This function registers a custom extension function to use in XPath expressions. The function registered under the fname identifier will be called for every matching node, being passed a context parameter as well as any parameters passed from the corresponding XPath expression.\n    Input-Output Arguments\n    :param fname: String. The identifier under which the function will be registered.\n    :param func: Callable. The function to be registered. If None, the extension function will be removed.\n    :return: No return values.\n    \"\"\"\n    if func is None:\n        # Remove the function if func is None\n        if fname in registered_functions:\n            del registered_functions[fname]\n    else:\n        # Register the function\n        registered_functions[fname] = func\n```"}
{"namespace": "dominate.dom_tag._get_thread_context", "completion": "```python\ndef _get_thread_context():\n    \"\"\"\n    This function returns the hash value of the current thread context. It first creates a list of the current thread and greenlet (if available) and then returns the hash value of the tuple of the context list.\n    Input-Output Arguments\n    :param: No input parameters.\n    :return: Integer. The hash value of the current thread context.\n    \"\"\"\n    current_thread = threading.current_thread().ident\n    current_greenlet = greenlet.getcurrent().id if greenlet else None\n    context_tuple = (current_thread, current_greenlet)\n    return hash(context_tuple)\n```"}
{"namespace": "dominate.util.system", "completion": "```python\nimport subprocess\n\ndef system(cmd, data=None):\n    \"\"\"\n    This function runs a system command and returns the output as a string. It uses the subprocess module to run the command and capture the output.\n    Input-Output Arguments\n    :param cmd: String. The system command to be executed.\n    :param data: Bytes. Optional input data to be passed to the command.\n    :return: String. The output of the system command as a decoded string.\n    \"\"\"\n    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)\n    output, error = process.communicate(input=data)\n    \n    if process.returncode != 0:\n        raise Exception(f\"Command failed with error: {error.decode().strip()}\")\n    \n    return output.decode().strip()\n```"}
